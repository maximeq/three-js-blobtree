!(function(t, e) {
"object" == typeof exports && "undefined" != typeof module
? (module.exports = e(require("three")))
: "function" == typeof define && define.amd
? define(["three"], e)
: (t.Blobtree = e(t.THREE));
})(this, function(t) {
"use strict";
(t = t && t.hasOwnProperty("default") ? t.default : t),
(function() {
THREE.BufferGeometryUtils = class {
static computeTangents(t) {
t.computeTangents(),
console.warn(
"THREE.BufferGeometryUtils: .computeTangents() has been removed. Use THREE.BufferGeometry.computeTangents() instead."
);
}
static mergeBufferGeometries(t, e = !1) {
const i = null !== t[0].index,
r = new Set(Object.keys(t[0].attributes)),
s = new Set(Object.keys(t[0].morphAttributes)),
o = {},
n = {},
h = t[0].morphTargetsRelative,
a = new THREE.BufferGeometry();
let c = 0;
for (let p = 0; p < t.length; ++p) {
const l = t[p];
let u = 0;
if (i !== (null !== l.index))
return (
console.error(
"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
p +
". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."
),
null
);
for (const t in l.attributes) {
if (!r.has(t))
return (
console.error(
"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
p +
'. All geometries must have compatible attributes; make sure "' +
t +
'" attribute exists among all geometries, or in none of them.'
),
null
);
void 0 === o[t] && (o[t] = []), o[t].push(l.attributes[t]), u++;
}
if (u !== r.size)
return (
console.error(
"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
p +
". Make sure all geometries have the same number of attributes."
),
null
);
if (h !== l.morphTargetsRelative)
return (
console.error(
"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
p +
". .morphTargetsRelative must be consistent throughout all geometries."
),
null
);
for (const t in l.morphAttributes) {
if (!s.has(t))
return (
console.error(
"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
p +
".  .morphAttributes must be consistent throughout all geometries."
),
null
);
void 0 === n[t] && (n[t] = []), n[t].push(l.morphAttributes[t]);
}
if (
((a.userData.mergedUserData = a.userData.mergedUserData || []),
a.userData.mergedUserData.push(l.userData),
e)
) {
let t;
if (i) t = l.index.count;
else {
if (void 0 === l.attributes.position)
return (
console.error(
"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
p +
". The geometry must have either an index or a position attribute"
),
null
);
t = l.attributes.position.count;
}
a.addGroup(c, t, p), (c += t);
}
}
if (i) {
let e = 0;
const i = [];
for (let r = 0; r < t.length; ++r) {
const s = t[r].index;
for (let t = 0; t < s.count; ++t) i.push(s.getX(t) + e);
e += t[r].attributes.position.count;
}
a.setIndex(i);
}
for (const t in o) {
const e = this.mergeBufferAttributes(o[t]);
if (!e)
return (
console.error(
"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " +
t +
" attribute."
),
null
);
a.setAttribute(t, e);
}
for (const t in n) {
const e = n[t][0].length;
if (0 === e) break;
(a.morphAttributes = a.morphAttributes || {}), (a.morphAttributes[t] = []);
for (let i = 0; i < e; ++i) {
const e = [];
for (let r = 0; r < n[t].length; ++r) e.push(n[t][r][i]);
const r = this.mergeBufferAttributes(e);
if (!r)
return (
console.error(
"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " +
t +
" morphAttribute."
),
null
);
a.morphAttributes[t].push(r);
}
}
return a;
}
static mergeBufferAttributes(t) {
let e,
i,
r,
s = 0;
for (let o = 0; o < t.length; ++o) {
const n = t[o];
if (n.isInterleavedBufferAttribute)
return (
console.error(
"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."
),
null
);
if ((void 0 === e && (e = n.array.constructor), e !== n.array.constructor))
return (
console.error(
"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. THREE.BufferAttribute.array must be of consistent array types across matching attributes."
),
null
);
if ((void 0 === i && (i = n.itemSize), i !== n.itemSize))
return (
console.error(
"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. THREE.BufferAttribute.itemSize must be consistent across matching attributes."
),
null
);
if ((void 0 === r && (r = n.normalized), r !== n.normalized))
return (
console.error(
"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. THREE.BufferAttribute.normalized must be consistent across matching attributes."
),
null
);
s += n.array.length;
}
const o = new e(s);
let n = 0;
for (let e = 0; e < t.length; ++e)
o.set(t[e].array, n), (n += t[e].array.length);
return new THREE.BufferAttribute(o, i, r);
}
static interleaveAttributes(t) {
let e,
i = 0,
r = 0;
for (let s = 0, o = t.length; s < o; ++s) {
const o = t[s];
if ((void 0 === e && (e = o.array.constructor), e !== o.array.constructor))
return (
console.error("AttributeBuffers of different types cannot be interleaved"), null
);
(i += o.array.length), (r += o.itemSize);
}
const s = new THREE.InterleavedBuffer(new e(i), r);
let o = 0;
const n = [],
h = ["getX", "getY", "getZ", "getW"],
a = ["setX", "setY", "setZ", "setW"];
for (let e = 0, i = t.length; e < i; e++) {
const i = t[e],
r = i.itemSize,
c = i.count,
p = new THREE.InterleavedBufferAttribute(s, r, o, i.normalized);
n.push(p), (o += r);
for (let t = 0; t < c; t++) for (let e = 0; e < r; e++) p[a[e]](t, i[h[e]](t));
}
return n;
}
static estimateBytesUsed(t) {
let e = 0;
for (const i in t.attributes) {
const r = t.getAttribute(i);
e += r.count * r.itemSize * r.array.BYTES_PER_ELEMENT;
}
const i = t.getIndex();
return (e += i ? i.count * i.itemSize * i.array.BYTES_PER_ELEMENT : 0);
}
static mergeVertices(t, e = 1e-4) {
e = Math.max(e, Number.EPSILON);
const i = {},
r = t.getIndex(),
s = t.getAttribute("position"),
o = r ? r.count : s.count;
let n = 0;
const h = Object.keys(t.attributes),
a = {},
c = {},
p = [],
l = ["getX", "getY", "getZ", "getW"];
for (let e = 0, i = h.length; e < i; e++) {
const i = h[e];
a[i] = [];
const r = t.morphAttributes[i];
r && (c[i] = new Array(r.length).fill().map(() => []));
}
const u = Math.log10(1 / e),
m = Math.pow(10, u);
for (let e = 0; e < o; e++) {
const s = r ? r.getX(e) : e;
let o = "";
for (let e = 0, i = h.length; e < i; e++) {
const i = h[e],
r = t.getAttribute(i),
n = r.itemSize;
for (let t = 0; t < n; t++) o += `${~~(r[l[t]](s) * m)},`;
}
if (o in i) p.push(i[o]);
else {
for (let e = 0, i = h.length; e < i; e++) {
const i = h[e],
r = t.getAttribute(i),
o = t.morphAttributes[i],
n = r.itemSize,
p = a[i],
u = c[i];
for (let t = 0; t < n; t++) {
const e = l[t];
if ((p.push(r[e](s)), o))
for (let t = 0, i = o.length; t < i; t++) u[t].push(o[t][e](s));
}
}
(i[o] = n), p.push(n), n++;
}
}
const g = t.clone();
for (let e = 0, i = h.length; e < i; e++) {
const i = h[e],
r = t.getAttribute(i),
s = new r.array.constructor(a[i]),
o = new THREE.BufferAttribute(s, r.itemSize, r.normalized);
if ((g.setAttribute(i, o), i in c))
for (let e = 0; e < c[i].length; e++) {
const r = t.morphAttributes[i][e],
s = new r.array.constructor(c[i][e]),
o = new THREE.BufferAttribute(s, r.itemSize, r.normalized);
g.morphAttributes[i][e] = o;
}
}
return g.setIndex(p), g;
}
static toTrianglesDrawMode(t, e) {
if (e === THREE.TrianglesDrawMode)
return (
console.warn(
"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."
),
t
);
if (e === THREE.TriangleFanDrawMode || e === THREE.TriangleStripDrawMode) {
let i = t.getIndex();
if (null === i) {
const e = [],
r = t.getAttribute("position");
if (void 0 === r)
return (
console.error(
"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
),
t
);
for (let t = 0; t < r.count; t++) e.push(t);
t.setIndex(e), (i = t.getIndex());
}
const r = i.count - 2,
s = [];
if (e === THREE.TriangleFanDrawMode)
for (let t = 1; t <= r; t++)
s.push(i.getX(0)), s.push(i.getX(t)), s.push(i.getX(t + 1));
else
for (let t = 0; t < r; t++)
t % 2 == 0
? (s.push(i.getX(t)), s.push(i.getX(t + 1)), s.push(i.getX(t + 2)))
: (s.push(i.getX(t + 2)), s.push(i.getX(t + 1)), s.push(i.getX(t)));
s.length / 3 !== r &&
console.error(
"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
);
const o = t.clone();
return o.setIndex(s), o.clearGroups(), o;
}
return (
console.error(
"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",
e
),
t
);
}
static computeMorphedAttributes(t) {
if (!0 !== t.geometry.isBufferGeometry)
return (
console.error(
"THREE.BufferGeometryUtils: Geometry is not of type THREE.BufferGeometry."
),
null
);
const e = new THREE.Vector3(),
i = new THREE.Vector3(),
r = new THREE.Vector3(),
s = new THREE.Vector3(),
o = new THREE.Vector3(),
n = new THREE.Vector3(),
h = new THREE.Vector3(),
a = new THREE.Vector3(),
c = new THREE.Vector3();
function p(t, p, l, u, m, g, v, _, y) {
e.fromBufferAttribute(l, g),
i.fromBufferAttribute(l, v),
r.fromBufferAttribute(l, _);
const f = t.morphTargetInfluences;
if (p.morphTargets && u && f) {
h.set(0, 0, 0), a.set(0, 0, 0), c.set(0, 0, 0);
for (let t = 0, p = u.length; t < p; t++) {
const p = f[t],
l = u[t];
0 !== p &&
(s.fromBufferAttribute(l, g),
o.fromBufferAttribute(l, v),
n.fromBufferAttribute(l, _),
m
? (h.addScaledVector(s, p), a.addScaledVector(o, p), c.addScaledVector(n, p))
: (h.addScaledVector(s.sub(e), p),
  a.addScaledVector(o.sub(i), p),
  c.addScaledVector(n.sub(r), p)));
}
e.add(h), i.add(a), r.add(c);
}
t.isSkinnedMesh &&
(t.boneTransform(g, e), t.boneTransform(v, i), t.boneTransform(_, r)),
(y[3 * g + 0] = e.x),
(y[3 * g + 1] = e.y),
(y[3 * g + 2] = e.z),
(y[3 * v + 0] = i.x),
(y[3 * v + 1] = i.y),
(y[3 * v + 2] = i.z),
(y[3 * _ + 0] = r.x),
(y[3 * _ + 1] = r.y),
(y[3 * _ + 2] = r.z);
}
const l = t.geometry,
u = t.material;
let m, g, v;
const _ = l.index,
y = l.attributes.position,
f = l.morphAttributes.position,
d = l.morphTargetsRelative,
b = l.attributes.normal,
w = l.morphAttributes.position,
x = l.groups,
V = l.drawRange;
let A, S, T, B, M, E, P, k;
const N = new Float32Array(y.count * y.itemSize),
F = new Float32Array(b.count * b.itemSize);
if (null !== _)
if (Array.isArray(u))
for (A = 0, T = x.length; A < T; A++)
for (
E = u[(M = x[A]).materialIndex],
S = P = Math.max(M.start, V.start),
B = k = Math.min(M.start + M.count, V.start + V.count);
S < B;
S += 3
)
p(t, E, y, f, d, (m = _.getX(S)), (g = _.getX(S + 1)), (v = _.getX(S + 2)), N),
p(t, E, b, w, d, m, g, v, F);
else
for (
A = P = Math.max(0, V.start), T = k = Math.min(_.count, V.start + V.count);
A < T;
A += 3
)
p(t, u, y, f, d, (m = _.getX(A)), (g = _.getX(A + 1)), (v = _.getX(A + 2)), N),
p(t, u, b, w, d, m, g, v, F);
else if (void 0 !== y)
if (Array.isArray(u))
for (A = 0, T = x.length; A < T; A++)
for (
E = u[(M = x[A]).materialIndex],
S = P = Math.max(M.start, V.start),
B = k = Math.min(M.start + M.count, V.start + V.count);
S < B;
S += 3
)
p(t, E, y, f, d, (m = S), (g = S + 1), (v = S + 2), N),
p(t, E, b, w, d, m, g, v, F);
else
for (
A = P = Math.max(0, V.start), T = k = Math.min(y.count, V.start + V.count);
A < T;
A += 3
)
p(t, u, y, f, d, (m = A), (g = A + 1), (v = A + 2), N),
p(t, u, b, w, d, m, g, v, F);
return {
positionAttribute: y,
normalAttribute: b,
morphedPositionAttribute: new THREE.Float32BufferAttribute(N, 3),
morphedNormalAttribute: new THREE.Float32BufferAttribute(F, 3)
};
}
};
})();
var e,
i,
r = Object.freeze({}),
s = {
types: {},
register: function(t, e) {
if (this.types[t])
throw "Error : cannot register type " +
t +
", this name is already registered.";
this.types[t] = e;
},
fromJSON: function(t) {
var e = this.types[t.type];
if (!e)
throw "Error : type found in JSON (" +
t.type +
" is not registered in the Blobtree library.";
return e.fromJSON(t);
}
},
o = s,
n = 0,
h = function() {
(this.id = n++),
(this.aabb = new t.Box3()),
(this.valid_aabb = !1),
(this.parentNode = null);
};
(h.prototype.constructor = h),
(h.type = "Element"),
o.register(h.type, h),
(h.prototype.toJSON = function() {
return {type: this.getType()};
}),
(h.prototype.clone = function() {
return o.fromJSON(this.toJSON());
}),
(h.prototype.getParentNode = function() {
return this.parentNode;
}),
(h.prototype.getType = function() {
return h.type;
}),
(h.prototype.computeHelpVariables = function() {
this.computeAABB();
}),
(h.prototype.computeAABB = function() {
throw "Error : computeAABB is abstract, should have been overwritten";
}),
(h.prototype.getAABB = function() {
return this.aabb;
}),
(h.prototype.isValidAABB = function() {
return this.valid_aabb;
}),
(h.prototype.invalidAABB = function() {
(this.valid_aabb = !1),
null !== this.parentNode &&
this.parentNode.isValidAABB() &&
this.parentNode.invalidAABB();
}),
(h.prototype.invalidAll = function() {
this.invalidAABB();
}),
(h.prototype.prepareForEval = function() {
throw "ERROR : prepareForEval is a virtual function, should be re-implemented in all element(error occured in Element.js";
}),
(h.prototype.value = function(t, e) {
throw "ERROR : value is an abstract function, should be re-implemented in all primitives(error occured in " +
this.getType() +
" primitive)";
}),
(h.prototype.numericalGradient =
((e = {v: 0}),
(i = ["x", "y", "z"]),
function(t, r, s) {
for (var o = s || 1e-5, n = 0; n < 3; ++n)
(t[i[n]] = t[i[n]] + o),
this.value(t, e),
(r[i[n]] = e.v),
(t[i[n]] = t[i[n]] - 2 * o),
this.value(t, e),
(r[i[n]] = (r[i[n]] - e.v) / (2 * o)),
(t[i[n]] = t[i[n]] + o);
})),
(h.prototype.getAreas = function() {
return [];
}),
(h.prototype.distanceTo = function(t) {
throw "ERROR : distanceTo is a virtual function, should be re-implemented in all primitives(error occured in " +
this.getType() +
" primitive)";
}),
(h.prototype.heuristicStepWithin = function() {
throw "ERROR : heuristicStepWithin is a virtual function, should be re-implemented in all primitives(error occured in " +
this.getType() +
" primitive)";
}),
(h.prototype.trim = function(t, e, i) {}),
(h.prototype.count = function(t) {
return 0;
});
var a = h,
p = function() {
a.call(this), (this.children = []);
};
((p.prototype = Object.create(a.prototype)).constructor = p),
(p.type = "Node"),
o.register(p.type, p),
(p.prototype.getType = function() {
return p.type;
}),
(p.prototype.toJSON = function() {
var t = a.prototype.toJSON.call(this);
t.children = [];
for (var e = 0; e < this.children.length; ++e)
t.children.push(this.children[e].toJSON());
return t;
}),
(p.prototype.clone = function() {
return o.fromJSON(this.toJSON());
}),
(p.prototype.prepareForEval = function() {
console.error(
"prepareForEval is a pure virtual function, should be reimplemented in every node class"
);
}),
(p.prototype.invalidAll = function() {
if ((this.invalidAABB(), this.children))
for (var t = 0; t < this.children.length; t++) this.children[t].invalidAll();
}),
(p.prototype.destroy = function() {
for (
var t = this.children.slice(0, this.children.length), e = 0;
e < t.length;
e++
)
t[e].destroy();
if (0 !== this.children.length) throw "Error : children length should be 0";
if (
(null !== this.parentNode && this.parentNode.removeChild(this),
null !== this.parentNode)
)
throw "Error : parent node should be null at this point";
this.children.length = 0;
}),
(p.prototype.addChild = function(t) {
null !== t.parentNode && t.parentNode.removeChild(t),
this.children.push(t),
(t.parentNode = this),
this.invalidAABB();
}),
(p.prototype.removeChild = function(t) {
for (var e = 0, i = this.children; i[e] !== t && e < i.length; ) ++e;
if (e == i.length) throw "c does not belong to the children of this node";
(i[e] = i[i.length - 1]), i.pop(), this.invalidAABB(), (t.parentNode = null);
}),
(p.prototype.computeAABB = function() {
this.aabb.makeEmpty();
for (var t = 0; t < this.children.length; t++)
this.children[t].computeAABB(), this.aabb.union(this.children[t].getAABB());
}),
(p.prototype.getAreas = function() {
if (!this.valid_aabb)
throw "Error : cannot call getAreas on a not prepared for eval nod, please call PrepareForEval first. Node concerned is a " +
this.getType();
for (var t = [], e = 0; e < this.children.length; e++)
t.push.apply(t, this.children[e].getAreas());
return t;
}),
(p.prototype.distanceTo = function(t) {
for (var e = 1e7, i = 0; i < this.children.length; i++)
e = Math.min(e, this.children[i].distanceTo(t));
return e;
}),
(p.prototype.heuristicStepWithin = function() {
for (var t = 1e7, e = 0; e < this.children.length; e++)
t = Math.min(t, this.children[e].heuristicStepWithin());
return t;
}),
(p.prototype.trim = function(t, e, i) {
for (var r = e.length, s = 0; s < this.children.length; s++)
this.children[s].getAABB().intersectsBox(t) ||
(e.push(this.children[s]), i.push(this));
for (s = r; s < e.length; ++s) this.removeChild(e[s]);
for (s = 0; s < this.children.length; s++) this.children[s].trim(t, e, i);
}),
(p.prototype.count = function(t) {
var e = 0;
this instanceof t && e++;
for (var i = 0; i < this.children.length; i++) e += this.children[i].count(t);
return e;
});
var l = p,
u = {};
(u.last_mov_pt = new t.Vector3()),
(u.grad = new t.Vector3()),
(u.eval_res_g = new t.Vector3(0, 0, 0)),
(u.eval_res = {v: 0, g: null}),
(u.vec = new t.Vector3()),
(u.safeNewton3D = function(t, e, i, r, s, o, n) {
n.copy(e);
for (var h = 1, a = 0, c = !1; 2 != a && h <= s && !c; ) {
if (
(this.last_mov_pt.copy(n),
(this.eval_res.g = this.eval_res_g),
t.value(n, this.eval_res),
this.grad.copy(this.eval_res.g),
0 !== this.grad.x || 0 !== this.grad.y || 0 !== this.grad.z)
) {
var p = this.grad.length(),
l = (i - this.eval_res.v) / p;
if (
(l < r && l > -r ? ((l = l > 0 ? r / p : -r / p), a++) : (a = 0),
this.grad.normalize().multiplyScalar(l),
n.add(this.grad),
this.vec.subVectors(n, e).lengthSq() > o * o)
)
return void n.copy(e);
} else c = !0;
++h;
}
c && n.copy(e);
}),
(u.safeNewton1D = function(e, i, r, s, o, n, h, a, c, p) {
if (((this.eval_res.g = this.eval_res_g), 0 === r.x && 0 === r.y && 0 === r.z))
throw "Error : search direction is null";
if (a <= 0)
throw "Error: epsilon <= 0, convergence will nuke your face or loop";
if (n < s || n > o) throw "Error : starting absc is not in boundaries";
for (var l = n, u = new t.Vector3(), m = 0, g = 0; o - s > a && g < c; )
e.value(
u
.copy(r)
.multiplyScalar(l)
.add(i),
this.eval_res
),
this.eval_res.v > h ? (s = l) : (o = l),
0 !== (m = this.eval_res.g.dot(r))
? ((l += (h - this.eval_res.v) / m) >= o || l <= s) && (l = 0.5 * (o + s))
: (l = 0.5 * (o + s)),
++g;
(p.p_absc = 0.5 * (o + s)),
p.p
.copy(r)
.multiplyScalar(l)
.add(i),
void 0 !== p.g &&
(0 === g && e.value(p.p, this.eval_res), p.g.copy(this.eval_res.g));
}),
(u.dichotomy1D = function(e, i, r, s, o, n, h, a) {
this.eval_res.g = null;
var c = new t.Vector3().copy(i),
p = new t.Vector3(),
l = -(s /= 2),
u = l;
i.sub(p.copy(r).multiplyScalar(s));
for (var m = 0; s > n && m < h; )
m++,
c.copy(i),
(u = l),
(s /= 2),
e.value(i, this.eval_res),
this.eval_res.v < o
? (i.add(p.copy(r).multiplyScalar(s)), (l += s))
: (i.sub(p.copy(r).multiplyScalar(s)), (l -= s));
a.p.copy(i.add(c).divideScalar(2)),
(a.p_absc = (u + l) / 2),
a.p.copy(i),
(a.p_absc = l),
a.g &&
((this.eval_res.g = this.eval_res_g),
e.value(a.p, this.eval_res),
a.g.copy(this.eval_res.g));
});
var m = u,
g = function(e) {
if (((e = e || {}), void 0 !== arguments[1]))
throw "Error : Blobtree Material now takes only 1 argument.";
(this.color = new t.Color(void 0 !== e.color ? e.color : 11184810)),
(this.roughness = void 0 !== e.roughness ? e.roughness : 0),
(this.metalness = void 0 !== e.metalness ? e.metalness : 0),
(this.emissive = new t.Color(void 0 !== e.emissive ? e.emissive : 0));
};
(g.prototype.toJSON = function() {
return {
color: "#" + this.color.getHexString(),
roughness: this.roughness,
metalness: this.metalness,
emissive: `#${this.emissive.getHexString()}`
};
}),
(g.fromJSON = function(e) {
return new g({
color: new t.Color(e.color),
roughness: e.roughness,
metalness: e.metalness,
emissive: e.emissive
});
}),
(g.prototype.clone = function() {
return new g({
color: this.color,
roughness: this.roughness,
metalness: this.metalness,
emissive: this.emissive
});
}),
(g.prototype.copy = function(t) {
this.color.copy(t.color),
(this.roughness = t.roughness),
(this.metalness = t.metalness),
this.emissive.copy(t.emissive);
}),
(g.prototype.set = function(t, e, i) {
this.color.copy(t), (this.roughness = e), (this.metalness = i);
}),
(g.prototype.setParams = function(t) {
this.color.copy(t.color ? t.color : this.color),
(this.roughness = void 0 !== t.roughness ? t.roughness : this.roughness),
(this.metalness = void 0 !== t.metalness ? t.metalness : this.metalness),
this.emissive.copy(void 0 !== t.emissive ? t.emissive : this.emissive);
}),
(g.prototype.getColor = function() {
return this.color;
}),
(g.prototype.getRoughness = function() {
return this.roughness;
}),
(g.prototype.getMetalness = function() {
return this.metalness;
}),
(g.prototype.getEmissive = function() {
return this.emissive;
}),
(g.prototype.equals = function(t) {
return (
this.color.equals(t.color) &&
this.metalness === t.metalness &&
this.roughness === t.roughness &&
this.emissive.equals(t.emissive)
);
}),
(g.prototype.lerp = function(t, e) {
this.color.lerp(t.color, e),
(this.roughness = (1 - e) * this.roughness + e * t.roughness),
(this.metalness = (1 - e) * this.metalness + e * t.metalness),
this.emissive.lerp(t.emissive, e);
}),
(g.prototype.triMean = function(t, e, i, r, s, o, n) {
return (
(this.color.r = (r * t.color.r + s * e.color.r + o * i.color.r) / n),
(this.color.g = (r * t.color.g + s * e.color.g + o * i.color.g) / n),
(this.color.b = (r * t.color.b + s * e.color.b + o * i.color.b) / n),
(this.roughness = (r * t.roughness + s * e.roughness + o * i.roughness) / n),
(this.metalness = (r * t.metalness + s * e.metalness + o * i.metalness) / n),
(this.emissive.r =
(r * t.emissive.r + s * e.emissive.r + o * i.emissive.r) / n),
(this.emissive.g =
(r * t.emissive.g + s * e.emissive.g + o * i.emissive.g) / n),
(this.emissive.b =
(r * t.emissive.b + s * e.emissive.b + o * i.emissive.b) / n),
this
);
}),
(g.prototype.weightedMean = function(t, e, i) {
this.color.setRGB(0, 0, 0),
(this.roughness = 0),
(this.metalness = 0),
this.emissive.setScalar(0);
const r = void 0 === i ? t.length : i;
let s = 0;
for (let i = 0; i < r; ++i)
(this.color.r += e[i] * t[i].color.r),
(this.color.g += e[i] * t[i].color.g),
(this.color.b += e[i] * t[i].color.b),
(this.roughness += e[i] * t[i].roughness),
(this.metalness += e[i] * t[i].metalness),
(this.emissive.r += e[i] * t[i].emissive.r),
(this.emissive.g += e[i] * t[i].emissive.g),
(this.emissive.b += e[i] * t[i].emissive.b),
(s += e[i]);
return (
0 !== s
? ((this.color.r /= s),
  (this.color.g /= s),
  (this.color.b /= s),
  (this.roughness /= s),
  (this.metalness /= s),
  (this.emissive.r /= s),
  (this.emissive.g /= s),
  (this.emissive.b /= s))
: (this.color.setScalar(0),
  (this.roughness = 0),
  (this.metalness = 0),
  this.emissive.setScalar(0)),
this
);
}),
(g.areEqualsArrays = function(t, e, i, r, s) {
console.warn(
"Material.areEqualsArrays is deprecated, please use your own comparison function using Material.equals."
);
for (var o = !0, n = 1; n < arguments.length; n++)
o =
o &&
((null === t && null === arguments[n]) ||
(null !== t && null !== arguments[n]));
if (!o) return o;
if (null === t) return !0;
for (n = 1; n < arguments.length; n++) {
var h = !0;
if (arguments[n].length !== t.length) return !1;
for (var a = 0; a < t.length; ++a) h = h && t[a].equals(arguments[n][a]);
o = o && h;
}
return o;
}),
(g.defaultMaterial = new g());
var v = g,
_ = function(e, i) {
if ((l.call(this), (this.ricci_n = e), i)) {
var r = this;
i.forEach(function(t) {
r.addChild(t);
});
}
(this.tmp_v_arr = new Float32Array(0)),
(this.tmp_m_arr = new Array(0)),
(this.tmp_res = {v: 0, g: null, m: null}),
(this.tmp_g = new t.Vector3()),
(this.tmp_m = new v());
};
((_.prototype = Object.create(l.prototype)).constructor = _),
(_.type = "RicciNode"),
o.register(_.type, _),
(_.prototype.getType = function() {
return _.type;
}),
(_.prototype.toJSON = function() {
var t = l.prototype.toJSON.call(this);
return (t.ricci = this.ricci_n), t;
}),
(_.fromJSON = function(t) {
for (var e = new _(t.ricci), i = 0; i < t.children.length; ++i)
e.addChild(o.fromJSON(t.children[i]));
return e;
}),
(_.prototype.prepareForEval = function() {
if (!this.valid_aabb) {
this.aabb = new t.Box3();
for (var e = 0; e < this.children.length; ++e) {
var i = this.children[e];
i.prepareForEval(), this.aabb.union(i.getAABB());
}
if (((this.valid_aabb = !0), this.tmp_v_arr.length < this.children.length)) {
(this.tmp_v_arr = new Float32Array(2 * this.children.length)),
(this.tmp_m_arr.length = 2 * this.children.length);
for (e = 0; e < this.tmp_m_arr.length; ++e)
this.tmp_m_arr[e] = new v({roughness: 0, metalness: 0});
}
}
}),
(_.prototype.value = function(t, e) {
var i = this.children.length,
r = this.tmp_res;
if (
((r.g = e.g ? this.tmp_g : null),
(r.m = e.m ? this.tmp_m : null),
(e.v = 0),
e.m && e.m.copy(v.defaultMaterial),
e.g ? e.g.set(0, 0, 0) : void 0 !== e.step && (e.step = 1e9),
this.aabb.containsPoint(t) && 0 !== i)
) {
for (
var s = this.tmp_v_arr, o = this.tmp_m_arr, n = 0, h = 0, a = 0;
a < i;
++a
)
if (this.children[a].aabb.containsPoint(t))
if ((this.children[a].value(t, r), r.v > 0)) {
var c = Math.pow(r.v, this.ricci_n - 1);
(h += r.v * c),
e.g && (r.g.multiplyScalar(c), e.g.add(r.g)),
e.m && ((s[n] = r.v * c), o[n].copy(r.m), n++),
(e.step || e.stepOrtho) &&
(e.step = Math.min(e.step, this.children[a].heuristicStepWithin()));
} else
void 0 !== e.step &&
(e.step = Math.min(e.step, this.children[a].distanceTo(t)));
else
(e.step || e.stepOrtho) &&
(e.step = Math.min(e.step, this.children[a].distanceTo(t)));
(e.v = Math.pow(h, 1 / this.ricci_n)),
0 !== e.v &&
(e.g && e.g.multiplyScalar(e.v / h), e.m && e.m.weightedMean(o, s, n));
} else if (void 0 !== e.step && 0 !== this.children.length) {
var p = this.children[0].heuristicStepWithin();
for (a = 1; a < this.children.length; ++a)
p = Math.min(p, this.children[a].heuristicStepWithin());
e.step = this.aabb.distanceToPoint(t) + p;
}
void 0 !== e.stepOrtho && (e.stepOrtho = e.step);
}),
(_.prototype.setRicciN = function(t) {
this.ricci_n != t && ((this.ricci_n = t), this.invalidAABB());
}),
(_.prototype.getRicciN = function() {
return this.ricci_n;
});
var y,
f,
d,
b,
w,
x,
V,
A,
S = _,
T = function() {
S.call(this, 64),
(this.valid_aabb = !0),
(this.iso_value = 1),
(this.trimmed = []),
(this.trim_parents = []);
};
((T.prototype = Object.create(S.prototype)).constructor = T),
(T.type = "RootNode"),
o.register(T.type, T),
(T.prototype.getType = function() {
return T.type;
}),
(T.prototype.toJSON = function() {
var t = S.prototype.toJSON.call(this);
return (t.iso = this.iso_value), t;
}),
(T.fromJSON = function(t) {
for (var e = new T(t.ricci), i = 0; i < t.children.length; ++i)
e.addChild(o.fromJSON(t.children[i]));
return e;
}),
(T.prototype.getIsoValue = function() {
return this.iso_value;
}),
(T.prototype.setIsoValue = function(t) {
this.iso_value = t;
}),
(T.prototype.getNeutralValue = function() {
return 0;
}),
(T.prototype.invalidAABB = function() {
this.valid_aabb = !1;
}),
(T.prototype.internalTrim = function(t) {
if (0 !== this.trimmed.length || 0 !== this.trim_parents.length)
throw "Error : you should not call internal trim if you have not untrimmed before. Call untrim or use externalTrim";
this.trim(t, this.trimmed, this.trim_parents);
}),
(T.prototype.externalTrim = function(t, e, i) {
this.trim(t, e, i);
}),
(T.prototype.internalUntrim = function() {
this.untrim(this.trimmed, this.trim_parents),
(this.trimmed.length = 0),
(this.trim_parents.length = 0);
}),
(T.prototype.untrim = function(t, e) {
if (t.length !== e.length)
throw "Error : trimmed and parents arrays should have the same length";
for (var i = 0; i < t.length; ++i) e[i].addChild(t[i]);
}),
(T.prototype.isEmpty = function() {
return 0 == this.children.length;
}),
(T.prototype.intersectRayBlob =
((y = new t.Vector3()),
(f = new t.Vector3()),
(d = new t.Vector3()),
(b = {v: 0, g: new t.Vector3(), step: 0}),
(w = {p: new t.Vector3(), g: new t.Vector3(), p_absc: 0}),
(x = 0),
(V = 0),
(A = 0),
function(t, e, i, r) {
for (
y.copy(t.origin),
f.copy(t.direction),
f.normalize(),
A = 0,
b.g = null,
this.value(y, b);
b.v < this.iso_value && A < i;

)
y.add(d.copy(f).multiplyScalar(b.step)),
(A += b.step),
(x = b.step),
(V = b.v),
this.value(y, b);
return (
b.v >= this.iso_value &&
(m.safeNewton1D(
this,
y,
f.multiplyScalar(-1),
0,
x,
(x * (this.iso_value - b.v)) / (V - b.v),
this.iso_value,
x / 512,
10,
w
),
(e.distance = A - w.p_absc),
(e.point = w.p.clone()),
e.g && e.g.copy(w.g),
!0)
);
})),
(T.prototype.intersectOrthoRayBlob = (function() {
var e = new t.Vector3(),
i = new t.Vector3(),
r = {step: 0},
s = new t.Vector3(),
o = {},
n = 0,
h = 0,
a = -1;
return function(t, c, p, l) {
for (
l.axis.z
? e.set(this.aabb.min.x + t, this.aabb.min.y + c, this.aabb.min.z + 1e-7)
: l.axis.y
? e.set(this.aabb.min.x + t, this.aabb.min.y + 1e-7, this.aabb.min.z + c)
: l.axis.z &&
  e.set(this.aabb.min.x + 1e-7, this.aabb.min.y + t, this.aabb.min.z + c),
r.step = l.get(this.aabb.max) - l.get(this.aabb.min),
this.value(e, r),
n = 1e-7,
a = -1;
l.get(e) < l.get(this.aabb.max);

) {
for (; (r.v - 1) * a >= 0 && l.get(e) < l.get(this.aabb.max); )
l.add(e, r.step),
(n = r.step),
(r.step = l.get(this.aabb.max) - l.get(e)),
this.value(e, r);
if (l.get(e) < l.get(this.aabb.max)) {
for (
a *= -1, i.copy(e), h = l.get(e), n /= 2, l.add(e, -n), o.g = null;
n > 0.1;

)
(h = l.get(e)),
(n /= 2),
this.value(e, o),
(o.v - 1) * a < 0 ? l.add(e, n) : l.add(e, -n);
l.add(e, h),
l.divide(e, 2),
(o.g = s),
this.value(e, o),
p.push({point: e.clone(), gradient: o.g.clone()}),
e.copy(i);
}
}
};
})());
var B = T,
M = function(e, i, r) {
l.call(this),
this.addChild(e),
this.addChild(i),
(this.alpha = r || 1),
(this.clamped = 0),
(this.tmp_res0 = {v: 0, g: new t.Vector3(0, 0, 0), m: new v()}),
(this.tmp_res1 = {v: 0, g: new t.Vector3(0, 0, 0), m: new v()}),
(this.g0 = new t.Vector3()),
(this.m0 = new v()),
(this.g1 = new t.Vector3()),
(this.m1 = new v()),
(this.tmp_v_arr = new Float32Array(2)),
(this.tmp_m_arr = [null, null]);
};
((M.prototype = Object.create(l.prototype)).constructor = M),
(M.type = "DifferenceNode"),
o.register(M.type, M),
(M.prototype.getAlpha = function() {
return this.alpha;
}),
(M.prototype.setAlpha = function(t) {
this.alpha != t && ((this.alpha = t), this.invalidAABB());
}),
(M.prototype.toJSON = function() {
var t = l.prototype.toJSON.call(this);
return (t.alpha = this.alpha), t;
}),
(M.fromJSON = function(t) {
var e = new M();
return (
(this.children[0] = o.fromJSON(t.children[0])),
(this.children[1] = o.fromJSON(t.children[1])),
e
);
}),
(M.prototype.prepareForEval = function() {
this.valid_aabb ||
(this.children[0].prepareForEval(),
this.children[1].prepareForEval(),
this.aabb.copy(this.children[0].getAABB()),
(this.valid_aabb = !0));
}),
(M.prototype.value = function(t, e) {
this.children.length;
var i = this.tmp_v_arr,
r = this.tmp_m_arr,
s = this.tmp_res0,
o = this.tmp_res1;
if (
((s.g = e.g ? this.g0 : null),
(s.m = e.m ? this.m0 : null),
(o.g = e.g ? this.g1 : null),
(o.m = e.m ? this.m1 : null),
(e.v = 0),
(o.v = 0),
(s.v = 0),
e.m &&
(e.m.copy(v.defaultMaterial),
o.m.copy(v.defaultMaterial),
s.m.copy(v.defaultMaterial)),
e.g
? (e.g.set(0, 0, 0), o.g.set(0, 0, 0), s.g.set(0, 0, 0))
: void 0 !== e.step && (e.step = 1e9),
this.aabb.containsPoint(t))
) {
if (this.children[0].aabb.containsPoint(t))
if (
(this.children[0].value(t, s),
this.children[1].aabb.containsPoint(t) && this.children[1].value(t, o),
0 === o.v)
)
(e.v = s.v), e.g && e.g.copy(s.g), e.m && e.m.copy(s.m);
else {
var n = Math.pow(o.v, this.alpha);
(e.v = Math.max(this.clamped, s.v - o.v * Math.pow(o.v, this.alpha - 1))),
e.g &&
(e.v === this.clamped
? e.g.set(0, 0, 0)
: (o.g.multiplyScalar(n), e.g.subVectors(s.g, o.g))),
e.m &&
((i[0] = s.v),
(i[1] = o.v),
(r[0] = s.m),
(r[1] = o.m),
e.m.weightedMean(r, i, 2));
}
} else void 0 !== e.step && (e.step = this.aabb.distanceToPoint(t) + 0.3);
}),
(M.prototype.trim = function(t, e, i) {
for (var r = 0; r < this.children.length; r++) this.children[r].trim(t, e, i);
});
var E = M,
P = function(e) {
if ((l.call(this), e)) {
var i = this;
e.forEach(function(t) {
i.addChild(t);
});
}
(this.tmp_res = {v: 0, g: null, m: null}),
(this.tmp_g = new t.Vector3()),
(this.tmp_m = new v());
};
((P.prototype = Object.create(l.prototype)).constructor = P),
(P.type = "MinNode"),
o.register(P.type, P),
(P.prototype.getType = function() {
return P.type;
}),
(P.fromJSON = function(t) {
for (var e = new P(), i = 0; i < t.children.length; ++i)
e.addChild(o.fromJSON(t.children[i]));
return e;
}),
(P.prototype.prepareForEval = function() {
if (!this.valid_aabb) {
this.aabb = new t.Box3();
for (var e = 0; e < this.children.length; ++e) {
var i = this.children[e];
i.prepareForEval(), this.aabb.union(i.getAABB());
}
this.valid_aabb = !0;
}
}),
(P.prototype.value = function(t, e) {
var i = this.children.length,
r = this.tmp_res;
if (
((r.g = e.g ? this.tmp_g : null),
(r.m = e.m ? this.tmp_m : null),
(e.v = 0),
e.m && e.m.copy(v.defaultMaterial),
e.g ? e.g.set(0, 0, 0) : void 0 !== e.step && (e.step = 1e9),
this.aabb.containsPoint(t) && 0 !== i)
) {
e.v = Number.MAX_VALUE;
for (var s = 0; s < i; ++s) {
if (
(this.children[s].value(t, r),
r.v < e.v &&
((e.v = r.v),
e.g && e.g.copy(r.g),
e.m && e.m.copy(r.m),
e.step || e.stepOrtho))
)
throw "Not implemented";
e.v = Math.min(e.v, r.v);
}
} else if (e.steo || e.stepOrtho) throw "Not implemented";
}),
(P.prototype.trim = function(t, e, i) {
for (var r = 0; r < this.children.length; r++) this.children[r].trim(t, e, i);
});
var k = P,
N = function() {
a.call(this), (this.materials = []);
};
((N.prototype = Object.create(a.prototype)).constructor = N),
(N.type = "Primitive"),
o.register(N.type, N),
(N.prototype.toJSON = function(t) {
var e = a.prototype.toJSON.call(this);
e.materials = [];
for (var i = 0; i < this.materials.length; ++i)
e.materials.push(this.materials[i].toJSON());
return e;
}),
(N.prototype.setMaterials = function(t) {
if (t.length !== this.materials.length)
throw "Error : trying to set " +
t.length +
" materials on a primitive with only " +
this.materials.length;
for (var e = 0; e < t.length; ++e)
t[e].equals(this.materials[e]) ||
(this.materials[e].copy(t[e]), this.invalidAABB());
}),
(N.prototype.getMaterials = function() {
return this.materials;
}),
(N.prototype.computeAABB = function() {
throw "Primitive.prototype.computeAABB  Must be reimplemented in all inherited class.";
}),
(N.prototype.destroy = function() {
null !== this.parentNode && this.parentNode.removeChild(this);
}),
(N.prototype.getAreas = function() {
throw "ERROR : getAreas is an abstract function, should be re-implemented in all primitives(error occured in " +
this.getType() +
" primitive)";
}),
(N.prototype.computeHelpVariables = function() {
throw "ERROR : computeHelpVariables is a virtual function, should be re-implemented in all primitives(error occured in " +
this.getType() +
" primitive)";
}),
(N.prototype.count = function(t) {
return this instanceof t ? 1 : 0;
});
var F = N,
z = {KS: 2};
(z.KIS = 1 / z.KS),
(z.KS2 = 4),
(z.KIS2 = 1 / (z.KS * z.KS)),
(z.Poly6Eval = function(t) {
var e = 1 - z.KIS2 * t * t;
return e > 0 ? e * e * e : 0;
}),
(z.Poly6EvalSq = function(t) {
var e = 1 - z.KIS2 * t;
return e > 0 ? e * e * e : 0;
}),
(z.GetIsoValueAtDistanceGeom0D = function(t, e, i) {
if (t % 2 != 0) throw "degree should be even";
if (i < e) {
var r = 1 - (i * i) / (e * e);
return Math.pow(r, t / 2);
}
return 0;
}),
(z.Poly4NF0D = 1 / z.GetIsoValueAtDistanceGeom0D(4, z.KS, 1)),
(z.Poly6NF0D = 1 / z.GetIsoValueAtDistanceGeom0D(6, z.KS, 1)),
(z.GetIsoValueAtDistanceGeom1D = function(t, e, i) {
if (t % 2 != 0) throw "degree should be even";
if (i < e) {
for (var r = 1 - (i * i) / (e * e), s = 2 * e * Math.sqrt(r), o = 0; o != t; )
s *= ((o += 2) / (1 + o)) * r;
return s;
}
return 0;
}),
(z.Poly4NF1D = 1 / z.GetIsoValueAtDistanceGeom1D(4, z.KS, 1)),
(z.Poly6NF1D = 1 / z.GetIsoValueAtDistanceGeom1D(6, z.KS, 1)),
(z.GetIsoValueAtDistanceGeom2D = function(t, e, i) {
if (i < e) {
var r = t + 2,
s = 1 - (i * i) / (e * e);
return ((2 * Math.PI) / r) * e * e * Math.pow(s, 0.5 * r);
}
return 0;
}),
(z.Poly4NF2D = 1 / z.GetIsoValueAtDistanceGeom2D(4, z.KS, 1)),
(z.Poly6NF2D = 1 / z.GetIsoValueAtDistanceGeom2D(6, z.KS, 1));
var D = z,
R = function() {
F.call(this), (this.volType = R.DIST), (this.v = []);
};
(R.DIST = "dist"),
(R.CONVOL = "convol"),
(R.prototype = Object.create(F.prototype)),
(R.prototype.constructor = R),
(R.type = "ScalisPrimitive"),
o.register(R.type, R),
(R.prototype.getType = function() {
return R.type;
}),
(R.prototype.toJSON = function() {
var t = F.prototype.toJSON.call(this);
(t.v = []), (t.volType = this.volType);
for (var e = 0; e < this.v.length; ++e) t.v.push(this.v[e].toJSON());
return t;
}),
(R.prototype.mutableVolType = function() {
return !1;
}),
(R.prototype.setVolType = function(t) {
t !== this.volType && ((this.volType = t), this.invalidAABB());
}),
(R.prototype.getVolType = function() {
return this.volType;
}),
(R.prototype.computeAABB = function() {
this.aabb.makeEmpty();
for (var t = 0; t < this.v.length; t++) this.aabb.union(this.v[t].getAABB());
});
var O = R,
q = 0,
j = function(e, i) {
(this.pos = e.clone()),
(this.thickness = i),
(this.id = q++),
(this.prim = null),
(this.aabb = new t.Box3()),
(this.valid_aabb = !1);
};
(j.prototype.setPrimitive = function(t) {
null === this.prim && (this.prim = t);
}),
(j.prototype.toJSON = function() {
return {
position: {x: this.pos.x, y: this.pos.y, z: this.pos.z},
thickness: this.thickness
};
}),
(j.fromJSON = function(e) {
return new j(
new t.Vector3(e.position.x, e.position.y, e.position.z),
e.thickness
);
}),
(j.prototype.setPos = function(t) {
(this.valid_aabb = !1), this.pos.copy(t), this.prim.invalidAABB();
}),
(j.prototype.setThickness = function(t) {
(this.valid_aabb = !1), (this.thickness = t), this.prim.invalidAABB();
}),
(j.prototype.setAll = function(t, e) {
(this.valid_aabb = !1),
(this.pos = t),
(this.thickness = e),
this.prim.invalidAABB();
}),
(j.prototype.getPos = function() {
return this.pos;
}),
(j.prototype.getThickness = function() {
return this.thickness;
}),
(j.prototype.getAABB = function() {
return (
this.valid_aabb || (this.computeAABB(), (this.valid_aabb = !0)), this.aabb
);
}),
(j.prototype.computeAABB = function() {
var e = this.getPos(),
i = this.getThickness() * D.KS;
this.aabb.set(
new t.Vector3(e.x - i, e.y - i, e.z - i),
new t.Vector3(e.x + i, e.y + i, e.z + i)
);
}),
(j.prototype.equals = function(t) {
return this.pos.equals(t.pos) && this.thickness === t.thickness;
});
var C = j,
I = function() {};
(I.prototype.sphereIntersect = function(t) {
throw "Error : sphereIntersect is abstract, should have been overwritten";
}),
(I.prototype.contains = function(t) {
throw "Error : contains is abstract, should have been overwritten";
}),
(I.prototype.getAcc = function(t, e) {
throw "Error : getAcc is abstract, should have been overwritten";
}),
(I.prototype.getNiceAcc = function(t) {
throw "Error : getNiceAcc is abstract, should have been overwritten";
}),
(I.prototype.getCurrAcc = function(t) {
throw "Error : getCurrAcc is abstract, should have been overwritten";
}),
(I.prototype.getRawAcc = function(t) {
throw "Error : getRawAcc is abstract, should have been overwritten";
}),
(I.prototype.getMinAcc = function() {
throw "Error : getRawAcc is abstract, should have been overwritten";
}),
(I.prototype.getMinRawAcc = function() {
throw "Error : getRawAcc is abstract, should have been overwritten";
});
var J,
G = I,
H = {nice: 0.3, raw: 1, curr: 0.3},
K = H,
U = function(e, i, r) {
G.call(this),
(this.p = new t.Vector3(e.x, e.y, e.z)),
(this.r = i),
(this.accFactor = r || 1);
};
((U.prototype = Object.create(G.prototype)).constructor = U),
(U.prototype.sphereIntersect =
((J = new t.Vector3()),
function(t) {
J.subVectors(t.center, this.p);
var e = t.radius + this.radius;
return J.lengthSq() < e * e;
})),
(U.prototype.contains = (function() {
var e = new t.Vector3();
return function(t) {
return e.subVectors(t, this.p), e.lengthSq() < this.r * this.r;
};
})()),
(U.prototype.getAcc = function(t, e) {
return this.radius * e;
}),
(U.prototype.getNiceAcc = function(t) {
return this.getAcc(t, K.nice * this.accFactor);
}),
(U.prototype.getCurrAcc = function(t) {
return this.getAcc(t, K.curr * this.accFactor);
}),
(U.prototype.getRawAcc = function(t) {
return this.getAcc(t, K.raw * this.accFactor);
}),
(U.prototype.getMinAcc = function() {
return K.curr * this.r * this.accFactor;
}),
(U.prototype.getMinRawAcc = function() {
return K.raw * this.r * this.accFactor;
}),
(U.prototype.getAxisProjectionMinStep = function(t, e) {
var i = 1e8,
r = e - this.p[t];
return (
r < -2 * this.r
? (i = Math.min(
  i,
  Math.max(Math.abs(r + this.r), K.curr * this.r * this.accFactor)
  ))
: r < 2 * this.r && (i = Math.min(i, K.curr * this.r * this.accFactor)),
i
);
});
var X = U,
L = function(e, i, r, s) {
O.call(this),
this.v.push(e),
this.v[0].setPrimitive(this),
(this.volType = i),
(this.density = r),
this.materials.push(s),
(this.v_to_p = new t.Vector3());
};
((L.prototype = Object.create(O.prototype)).constructor = L),
(L.type = "ScalisPoint"),
o.register(L.type, L),
(L.prototype.getType = function() {
return L.type;
}),
(L.prototype.toJSON = function() {
var t = O.prototype.toJSON.call(this);
return (t.density = this.density), t;
}),
(L.fromJSON = function(t) {
var e = C.fromJSON(t.v[0]),
i = v.fromJSON(t.materials[0]);
return new L(e, t.volType, t.density, i);
}),
(L.prototype.setDensity = function(t) {
(this.density = t), this.invalidAABB();
}),
(L.prototype.getDensity = function() {
return this.density;
}),
(L.prototype.setMaterial = function(t) {
this.materials[0].copy(t), this.invalidAABB();
}),
(L.prototype.computeHelpVariables = function() {
this.computeAABB();
}),
(L.prototype.prepareForEval = function() {
this.valid_aabb || (this.computeHelpVariables(), (this.valid_aabb = !0));
}),
(L.prototype.getAreas = function() {
if (this.valid_aabb)
return [
{
aabb: this.aabb,
bv: new X(this.v[0].getPos(), D.KS * this.v[0].getThickness(), D.KIS),
obj: this
}
];
throw "ERROR : Cannot get area of invalid primitive";
}),
(L.prototype.heuristicStepWithin = function() {
return this.v[0].getThickness() / 3;
}),
(L.prototype.value = function(t, e) {
if (!this.valid_aabb) throw "Error : PrepareForEval should have been called";
var i = this.v[0].getThickness();
this.v_to_p.subVectors(t, this.v[0].getPos());
var r = this.v_to_p.lengthSq() / (i * i),
s = 1 - D.KIS2 * r;
if (s > 0) {
if (((e.v = this.density * s * s * s * D.Poly6NF0D), e.g)) {
var o =
(-this.density * D.KIS2 * 6 * this.v_to_p.length() * s * s * D.Poly6NF0D) /
(i * i);
e.g
.copy(this.v_to_p)
.normalize()
.multiplyScalar(o);
}
e.m && e.m.copy(this.materials[0]);
} else (e.v = 0), e.g && e.g.set(0, 0, 0), e.m && e.m.copy(v.defaultMaterial);
}),
(L.prototype.distanceTo = function(t) {
return t.distanceTo(this.v[0].getPos());
});
var W = L,
Z = function(e, i, r, s) {
G.call(this),
(this.p0 = new t.Vector3(e.x, e.y, e.z)),
(this.p1 = new t.Vector3(i.x, i.y, i.z)),
(this.thick0 = r),
(this.thick1 = s),
(this.unit_dir = new t.Vector3().subVectors(i, e)),
(this.length = this.unit_dir.length()),
this.unit_dir.normalize(),
(this.vector = new t.Vector3()),
(this.p0_to_p = this.vector),
(this.p0_to_p_sqrnorm = 0),
(this.x_p_2D = 0),
(this.y_p_2D = 0),
(this.y_p_2DSq = 0),
(this.ortho_vec_x = this.thick0 - this.thick1),
(this.ortho_vec_y = this.length),
(this.p_proj_x = 0),
(this.p_proj_y = 0),
(this.abs_diff_thick = Math.abs(this.ortho_vec_x));
};
((Z.prototype = Object.create(G.prototype)).constructor = Z),
(Z.prototype.proj_computation = function(t) {
(this.p0_to_p = this.vector),
this.p0_to_p.subVectors(t, this.p0),
(this.p0_to_p_sqrnorm = this.p0_to_p.lengthSq()),
(this.x_p_2D = this.p0_to_p.dot(this.unit_dir)),
(this.y_p_2DSq = this.p0_to_p_sqrnorm - this.x_p_2D * this.x_p_2D),
(this.y_p_2D = this.y_p_2DSq > 0 ? Math.sqrt(this.y_p_2DSq) : 0);
var e = -this.y_p_2D / this.ortho_vec_y;
(this.p_proj_x = this.x_p_2D + e * this.ortho_vec_x), (this.p_proj_y = 0);
}),
(Z.prototype.sphereIntersect = function(t) {
if ((this.proj_computation(t.center), this.p_proj_x < 0))
return Math.sqrt(this.p0_to_p_sqrnorm) - t.radius < this.thick0 * D.KS;
if (this.p_proj_x > this.length)
return (
this.vector.subVectors(t.center, this.p1),
Math.sqrt(this.vector.lengthSq()) - t.radius < this.thick1 * D.KS
);
var e = this.x_p_2D - this.p_proj_x,
i = e * e + this.y_p_2DSq,
r = this.p_proj_x / this.length,
s = this.thick0 * (1 - r) + r * this.thick1,
o = t.radius + s * D.KS;
return i < o * o;
}),
(Z.prototype.contains = function(t) {
if ((this.proj_computation(t), this.p_proj_x < 0))
return this.p0_to_p_sqrnorm < this.thick0 * this.thick0 * D.KS2;
if (this.p_proj_x > this.length)
return (
this.vector.subVectors(t, this.p1),
this.vector.lengthSq() < this.thick1 * this.thick1 * D.KS2
);
var e = this.x_p_2D - this.p_proj_x,
i = this.y_p_2D - this.p_proj_y,
r = e * e + i * i,
s = this.p_proj_x / this.length,
o = this.thick0 * (1 - s) + s * this.thick1;
return r < o * o * D.KS2;
}),
(Z.prototype.getAcc = function(t, e) {
this.proj_computation(t.center);
var i = this.abs_diff_thick / this.length,
r = t.radius * Math.sqrt(1 + i * i) * 0.5,
s = this.p_proj_x;
if ((s += this.thick0 > this.thick1 ? r : -r) < 0) return this.thick0 * e;
if (s > this.length) return this.thick1 * e;
var o = s / this.length;
return (this.thick0 * (1 - o) + o * this.thick1) * e;
}),
(Z.prototype.getNiceAcc = function(t) {
return this.getAcc(t, K.nice);
}),
(Z.prototype.getCurrAcc = function(t) {
return this.getAcc(t, K.curr);
}),
(Z.prototype.getRawAcc = function(t) {
return this.getAcc(t, K.raw);
}),
(Z.prototype.getMinAcc = function() {
return K.curr * Math.min(this.thick0, this.thick1);
}),
(Z.prototype.getMinRawAcc = function() {
return K.raw * Math.min(this.thick0, this.thick1);
}),
(Z.prototype.getAxisProjectionMinStep = function(t, e) {
var i,
r,
s,
o = Number.MAX_VALUE,
n = this.p0[t] < this.p1[t] ? this.p0 : this.p1;
n === this.p0
? ((i = this.p1), (r = this.thick0), (s = this.thick1))
: ((i = this.p0), (r = this.thick1), (s = this.thick0));
var h = e - n[t];
h < -2 * r
? (o = Math.min(o, Math.max(Math.abs(h + 2 * r), K.curr * r)))
: h < 2 * r && (o = Math.min(o, K.curr * r)),
(h = e - i[t]) < -2 * s
? (o = Math.min(o, Math.max(Math.abs(h + 2 * s), K.curr * s)))
: h < 2 * s && (o = Math.min(o, K.curr * s));
var a = e - n[t],
c = i[t] - n[t];
return (
a > 0 &&
a < c &&
0 !== c &&
(o = Math.min(o, K.curr * (r + (a / c) * (s - r)))),
o
);
});
var Y,
$,
Q,
tt,
et = Z,
it = function(e, i, r, s, o) {
O.call(this),
(this.v.length = 2),
(this.v[0] = e),
(this.v[1] = i),
e.setPrimitive(this),
i.setPrimitive(this),
(this.volType = r),
(this.density = s),
(this.materials = o),
(this.clipped_l1 = 1),
(this.clipped_l2 = 0),
(this.vector = new t.Vector3()),
(this.cycle = new t.Vector3()),
(this.proj = new t.Vector3()),
(this.v0_p = this.v[0].getPos()),
(this.v1_p = this.v[1].getPos()),
(this.dir = new t.Vector3()),
(this.lengthSq = 0),
(this.length = 0),
(this.unit_dir = new t.Vector3()),
(this.weight_p1 = 0),
(this.c0 = 0),
(this.c1 = 0),
(this.increase_unit_dir = new t.Vector3()),
(this.p_min = new t.Vector3()),
(this.weight_min = 0),
(this.inv_weight_min = 0),
(this.unit_delta_weight = 0),
(this.maxbound = 0),
(this.maxboundSq = 0),
(this.cyl_bd0 = 0),
(this.cyl_bd1 = 0),
(this.f0f1f2 = new t.Vector3()),
(this.tmpVec1 = new t.Vector3()),
(this.tmpVec2 = new t.Vector3()),
this.computeHelpVariables();
};
(it.prototype = Object.create(O.prototype)),
(it.constructor = it),
(it.type = "ScalisSegment"),
o.register(it.type, it),
(it.prototype.getType = function() {
return it.type;
}),
(it.prototype.toJSON = function() {
var t = O.prototype.toJSON.call(this);
return (t.density = this.density), t;
}),
(it.fromJSON = function(t) {
var e = C.fromJSON(t.v[0]),
i = C.fromJSON(t.v[1]),
r = [v.fromJSON(t.materials[0]), v.fromJSON(t.materials[1])];
return new it(e, i, t.volType, t.density, r);
}),
(it.prototype.mutableVolType = function() {
return !0;
}),
(it.prototype.setDensity = function(t) {
(this.density = t), this.invalidAABB();
}),
(it.prototype.getDensity = function() {
return this.density;
}),
(it.prototype.setVolType = function(t) {
if (t != O.CONVOL && t != O.DIST)
throw "ERROR : volType must be set to ScalisPrimitive.CONVOL or ScalisPrimitive.DIST";
this.volType != t && ((this.volType = t), this.invalidAABB());
}),
(it.prototype.getVolType = function() {
return this.volType;
}),
(it.prototype.prepareForEval = function() {
this.valid_aabb || (this.computeHelpVariables(), (this.valid_aabb = !0));
}),
(it.prototype.getAreas = function() {
if (this.valid_aabb)
return [
{
aabb: this.aabb,
bv: new et(
this.v[0].getPos(),
this.v[1].getPos(),
this.v[0].getThickness(),
this.v[1].getThickness(),
this.length,
this.unit_dir
),
obj: this
}
];
throw "ERROR : Cannot get area of invalid primitive";
}),
(it.prototype.computeHelpVariables = function() {
(this.v0_p = this.v[0].getPos()),
(this.v1_p = this.v[1].getPos()),
this.dir.subVectors(this.v1_p, this.v0_p),
(this.lengthSq = this.dir.lengthSq()),
(this.length = Math.sqrt(this.lengthSq)),
this.unit_dir.copy(this.dir).normalize(),
(this.weight_p1 = this.v[1].getThickness()),
(this.c0 = this.v[0].getThickness()),
(this.c1 = this.v[1].getThickness() - this.v[0].getThickness());
var t = this.v[0].getThickness() * D.KS,
e = this.v[1].getThickness() * D.KS;
(this.maxbound = Math.max(t, e)),
(this.maxboundSq = this.maxbound * this.maxbound),
(this.cyl_bd0 = Math.min(-t, this.length - e)),
(this.cyl_bd1 = Math.max(this.length + e, t)),
this.increase_unit_dir.copy(this.unit_dir),
this.c1 < 0
? (this.p_min.copy(this.v1_p),
  (this.weight_min = this.weight_p1),
  (this.inv_weight_min = 1 / this.weight_p1),
  this.increase_unit_dir.negate(),
  (this.unit_delta_weight = -this.c1 / this.length))
: (this.p_min.copy(this.v0_p),
  (this.weight_min = this.c0),
  (this.inv_weight_min = 1 / this.c0),
  (this.unit_delta_weight = this.c1 / this.length)),
this.computeAABB();
}),
(it.prototype.value = function(t, e) {
switch (this.volType) {
case O.DIST:
this.evalDist(t, e);
break;
case O.CONVOL:
this.evalConvol(t, e);
break;
default:
throw "Unknown volType, cannot evaluate.";
}
}),
(it.prototype.evalDist =
((Y = {v: 0}),
($ = new t.Vector3()),
function(t, e) {
var i = this.vector;
i.subVectors(t, this.v[0].getPos());
var r = i.dot(this.dir),
s = i.lengthSq(),
o = this.lengthSq * this.c0 + r * this.c1,
n = this.c1 < 0 ? 0 : 1;
o > 0 && (n = (n = r * this.c0 + s * this.c1) < 0 ? 0 : n > o ? 1 : n / o);
var h = Math.sqrt(n * (n * this.lengthSq - 2 * r) + s),
a = this.c0 + n * this.c1;
if (
((e.v = this.density * D.Poly6Eval(h / a) * D.Poly6NF0D),
e.m && this.evalMat(t, e),
e.g)
) {
var c = this.density / 1e-5;
$.copy(t),
($.x += 1e-5),
this.evalDist($, Y),
(e.g.x = c * (Y.v - e.v)),
($.x -= 1e-5),
($.y += 1e-5),
this.evalDist($, Y),
(e.g.y = c * (Y.v - e.v)),
($.y -= 1e-5),
($.z += 1e-5),
this.evalDist($, Y),
(e.g.z = c * (Y.v - e.v));
}
})),
(it.prototype.evalMat = function(t, e) {
var i = this.vector;
i.subVectors(t, this.v[0].getPos());
var r = this.unit_dir.dot(i) / this.length;
r > 1
? e.m.copy(this.materials[1])
: r <= 0
? e.m.copy(this.materials[0])
: (e.m.copy(this.materials[0]), e.m.lerp(this.materials[1], r));
}),
(it.prototype.HomotheticClippingSpecial = function(t) {
var e = -t.z,
i = -t.y,
r = -t.x,
s = i * i - e * r;
if (s >= 0) {
var o = i + Math.sqrt(s);
if (o < 0 || this.length * o < r) return !1;
var n = r / o;
this.clipped_l1 = n < 0 ? 0 : n;
var h = e * n;
return (
(this.clipped_l2 = 2 * i < h + e * this.length ? r / h : this.length), !0
);
}
return !1;
}),
(it.prototype.heuristicStepWithin = function() {
return this.weight_min / 3;
}),
(it.prototype.evalConvol = function(t, e) {
if (!this.valid_aabb) throw "Error : prepareForEval should have been called";
e.g && e.g.set(0, 0, 0), (e.v = 0);
var i = this.tmpVec1;
i.subVectors(t, this.p_min);
var r = this.increase_unit_dir.dot(i),
s = i.lengthSq(),
o = this.tmpVec2;
if (
(o.set(
this.weight_min * this.weight_min - D.KIS2 * s,
-this.unit_delta_weight * this.weight_min - D.KIS2 * r,
this.unit_delta_weight * this.unit_delta_weight - D.KIS2
),
this.HomotheticClippingSpecial(o))
) {
var n = 1 / (this.weight_min + this.clipped_l1 * this.unit_delta_weight);
(o.x = 1 - D.KIS2 * (this.clipped_l1 * (this.clipped_l1 - 2 * r) + s) * n * n),
(o.y = -this.unit_delta_weight - D.KIS2 * (r - this.clipped_l1) * n),
e.g
? (this.unit_delta_weight >= 0.06
  ? this.HomotheticCompactPolynomial_segment_FGradF_i6(
    (this.clipped_l2 - this.clipped_l1) * n,
    this.unit_delta_weight,
    o
    )
  : this.HomotheticCompactPolynomial_approx_segment_FGradF_i6(
    (this.clipped_l2 - this.clipped_l1) * n,
    this.unit_delta_weight,
    this.inv_weight_min,
    o
    ),
  (e.v = D.Poly6NF1D * this.f0f1f2.x),
  (this.f0f1f2.y *= n),
  e.g
  .copy(this.increase_unit_dir)
  .multiplyScalar(this.f0f1f2.z + this.clipped_l1 * this.f0f1f2.y)
  .sub(i.multiplyScalar(this.f0f1f2.y))
  .multiplyScalar(6 * D.Poly6NF1D * D.KIS2 * n))
: this.unit_delta_weight >= 0.06
? (e.v =
  D.Poly6NF1D *
  this.HomotheticCompactPolynomial_segment_F_i6(
  (this.clipped_l2 - this.clipped_l1) * n,
  this.unit_delta_weight,
  o
  ))
: (e.v =
  D.Poly6NF1D *
  this.HomotheticCompactPolynomial_approx_segment_F_i6(
  (this.clipped_l2 - this.clipped_l1) * n,
  this.unit_delta_weight,
  n,
  o
  )),
e.m && this.evalMat(t, e);
}
}),
(it.prototype.clamp = function(t, e, i) {
return Math.max(e, Math.min(i, t));
}),
(it.prototype.distanceTo =
((Q = new t.Vector3()),
(tt = new t.Vector3()),
function(t) {
var e = Q.subVectors(t, this.v[0].getPos()).dot(this.dir) / this.lengthSq;
return (
(e = this.clamp(e, 0, 1)),
tt
.copy(this.dir)
.multiplyScalar(e)
.add(this.v[0].getPos()),
t.distanceTo(tt)
);
})),
(it.prototype.HomotheticCompactPolynomial_segment_F_i6 = function(t, e, i) {
var r = e * t + 1,
s = 1 / r,
o = r * r,
n = 1 / (o * o),
h = i.y,
a = h * h,
c = 12 * a,
p = 1 / e,
l = h * p,
u = r * o,
m = t * t,
g = m * m,
v = t * m,
_ = t * g,
y = i.x,
f = i.z,
d = y * y,
b = f * f,
w = 1 / (u * u),
x = s * n,
V = 1 / u,
A = 1 / o;
return (
-b *
(((((-(s - 1) * p - t * A) * p - m * V) * p - v * n) * p - g * x) * p - _ * w) *
l +
((-y * (w - 1) * p) / 6 - ((-(x - 1) * p) / 5 - t * w) * l) * d +
(((y * c + 3 * f * d) * (0.4 * ((-(n - 1) * p) / 4 - t * x) * p - m * w) +
(3 * b * y + f * c) *
(0.8 *
(0.75 * ((2 / 3) * ((-(A - 1) * p) / 2 - t * V) * p - m * n) * p - v * x) *
p -
g * w) +
f *
b *
(1.2 *
((5 / 4) *
((4 / 3) * (1.5 * (2 * (Math.log(r) * p - t * s) * p - m * A) * p - v * V) * p -
g * n) *
p -
_ * x) *
p -
v * v * w) +
(-12 * f * y - 8 * a) *
(0.6 * ((((-(V - 1) * p) / 3 - t * n) * p) / 2 - m * x) * p - v * w) *
h) *
p) /
6
);
}),
(it.prototype.HomotheticCompactPolynomial_approx_segment_F_i6 = function(
t,
e,
i,
r
) {
var s = i * e,
o = s + 1,
n = 1 / o,
h = o * o,
a = n / (h * h) / h,
c = r.z,
p = r.y,
l = r.x,
u = t * t,
m = c * u - 2 * p * t + l,
g = c * l - p * p,
v = c * t - p,
_ = l * l,
y = p * _,
f = m * m,
d = v * f,
b = 1 / c,
w = g * b,
x =
(6 / 35) * ((4 / 3) * (2 * g * t + v * m + p * l) * w + d + y) * w +
(m * d) / 7 +
(l * y) / 7,
V = b * x,
A = n * a,
S = f * f,
T = p * V + S / 8 - (_ * _) / 8,
B = -t * S + (-10 * p * T + l * x) * b;
return (
V -
7 * e * T * b +
((-0.1111111111 * (3 * a - 3 + 7 * (2 + A) * s) * B -
((0.1 * (2 - 2 * a - 7 * (1 + A) * s)) / i) *
(-1 * u * S + (1.333333333 * p * B + 2 * l * T) * b)) *
b) /
(i * i)
);
}),
(it.prototype.HomotheticCompactPolynomial_segment_FGradF_i6 = function(
t,
e,
i
) {
var r = e * t + 1,
s = 1 / r,
o = r * r,
n = 1 / (o * o),
h = i.y,
a = h * h,
c = 2 * a,
p = i.z,
l = i.x,
u = (p * l) / 3 + (2 / 3) * a,
m = p * p,
g = m / 6,
v = (-2 / 3) * p,
_ = r * o,
y = 1 / _,
f = s * n,
d = 1 / (_ * _),
b = t * t,
w = 1 / e,
x = t * b,
V = 0.6 * ((((-(y - 1) * w) / 3 - t * n) * w) / 2 - b * f) * w - x * d,
A = V * h,
S = (-(f - 1) * w) / 5 - t * d,
T = l * l,
B = T * S,
M = 0.4 * ((-(n - 1) * w) / 4 - t * f) * w - b * d,
E = l * M,
P = (-T * (d - 1)) / 6,
k = b * b,
N = t * k,
F = 1 / o,
z =
0.8 *
(0.75 * ((2 / 3) * ((-(F - 1) * w) / 2 - t * y) * w - b * n) * w - x * f) *
w -
k * d,
D =
((((-(s - 1) * w - t * F) * w - b * y) * w - x * n) * w - k * f) * w - N * d,
R = x * x,
O = Math.log(r);
(this.f0f1f2.x =
(l * P -
h * B +
E * c -
(4 / 3) * a * A +
((T * M) / 2 + z * c - 2 * l * A) * p +
((l * z) / 2 -
h * D +
((-R * d) / 6 +
((-N * f) / 5 +
((-k * n) / 4 + ((-x * y) / 3 + ((-b * F) / 2 + (O * w - t * s) * w) * w) * w) *
w) *
w) *
p) *
m) *
w),
(this.f0f1f2.y = (P + M * u + z * g + ((-2 / 3) * l * S + V * v) * h) * w),
(this.f0f1f2.z = (B / 6 + V * u + D * g + ((-2 / 3) * E + z * v) * h) * w);
}),
(it.prototype.HomotheticCompactPolynomial_approx_segment_FGradF_i6 = function(
t,
e,
i,
r
) {
var s = i * e,
o = s + 1,
n = 1 / o,
h = 1 / (i * i),
a = o * o,
c = n / (a * a) / a,
p = r.x,
l = 2 * p,
u = r.z,
m = 1 / u,
g = e * m,
v = r.y,
_ = t * t,
y = u * _ - 2 * v * t + p,
f = y * y,
d = y * f,
b = p * p,
w = p * b,
x = u * p - v * v,
V = u * t - v,
A = x * m,
S = (4 / 3) * (2 * x * t + V * y + v * p) * A + V * f + v * b,
T = S / 5,
B = v * m * T + d / 6 - w / 6,
M = -t * d + (-8 * v * B + p * T) * m,
E = _ * d,
P = ((10 / 7) * v * M + B * l) * m - E,
k = -P / 8,
N = (6 / 35) * S * A + (V * d) / 7 + (v * w) / 7,
F = n * c,
z = (3 * c - 3 + 7 * (2 + F) * s) * h,
D = ((2 - 2 * c - 7 * (1 + F) * s) / i) * h,
R = m * z,
O = m * D,
q = m * N,
j = f * f,
C = v * q + j / 8 - (b * b) / 8,
I = -t * j + (-10 * v * C + p * N) * m;
(this.f0f1f2.x =
q -
7 * C * g -
(I * R) / 9 -
((-_ * j + ((4 / 3) * v * I + C * l) * m) * O) / 10),
(this.f0f1f2.y = (T - 7 * e * B - (M * z) / 7 + D * k) * m),
(this.f0f1f2.z =
B * m +
M * g +
R * k -
((-t * E + (1.5 * v * P - (3 / 7) * p * M) * m) * O) / 9);
});
var rt = it,
st = {},
ot = function(t, e) {
var i = t;
if (0 === e) throw "Lenght of the array should not be null";
return 1 === e ? 0 : (t < 0 && (i = (e + t) % e), t >= e && (i = t % e), i);
};
(st.computeVectorsDirs = function(e) {
var i = e.v[0].getPos(),
r = e.v[1].getPos(),
s = e.v[2].getPos();
e.p0p1.subVectors(r, i),
e.p1p2.subVectors(s, r),
e.p2p0.subVectors(i, s),
e.unit_normal.crossVectors(e.p0p1, e.p2p0),
e.unit_normal.normalize(),
(e.length_p0p1 = e.p0p1.length()),
e.unit_p0p1.copy(e.p0p1),
e.unit_p0p1.divideScalar(e.length_p0p1),
(e.diffThick_p0p1 = e.v[0].getThickness() - e.v[1].getThickness()),
(e.length_p1p2 = e.p1p2.length()),
e.unit_p1p2.copy(e.p1p2),
e.unit_p1p2.divideScalar(e.length_p1p2),
(e.diffThick_p1p2 = e.v[1].getThickness() - e.v[2].getThickness()),
(e.length_p2p0 = e.p2p0.length()),
e.unit_p2p0.copy(e.p2p0),
e.unit_p2p0.divideScalar(e.length_p2p0),
(e.diffThick_p2p0 = e.v[2].getThickness() - e.v[0].getThickness());
var o = [];
o.push({vert: e.v[0].getPos(), thick: e.v[0].getThickness(), idx: 0}),
o.push({vert: e.v[1].getPos(), thick: e.v[1].getThickness(), idx: 1}),
o.push({vert: e.v[2].getPos(), thick: e.v[2].getThickness(), idx: 2}),
o.sort(function(t, e) {
return t.thick - e.thick;
}),
(e.point_min = o[0].vert),
(e.weight_min = o[0].thick);
var n = ot(o[0].idx + 1, 3),
h = e.v[n].getPos(),
a = e.v[n].getThickness();
n = ot(o[0].idx + 2, 3);
var c = e.v[n].getPos(),
p = e.v[n].getThickness(),
l = new t.Vector3();
l = l.subVectors(h, e.point_min);
var u = new t.Vector3();
u = u.subVectors(c, e.point_min);
var m = a - e.weight_min,
g = p - e.weight_min;
if (m < 1e-6 || g < 1e-6) {
if (m < g) {
(e.ortho_dir = l.clone()),
e.ortho_dir.normalize(),
e.main_dir.crossVectors(e.ortho_dir, e.unit_normal),
e.main_dir.normalize(),
e.main_dir.dot(u) < 0 && e.main_dir.multiplyScalar(-1);
var v = -e.weight_min / g;
e.point_iso_zero = new t.Vector3(
e.point_min.x + v * u.x,
e.point_min.y + v * u.y,
e.point_min.z + v * u.z
);
} else {
(e.ortho_dir = u.clone()),
e.ortho_dir.normalize(),
e.main_dir.crossVectors(e.ortho_dir, e.unit_normal),
e.main_dir.normalize(),
e.main_dir.dot(l) < 0 && e.main_dir.multiplyScalar(-1);
v = -e.weight_min / m;
e.point_iso_zero = new t.Vector3(
e.point_min.x + v * l.x,
e.point_min.y + v * l.y,
e.point_min.z + v * l.z
);
}
Math.abs(m - g) < 1e-6 &&
((e.proj_dir = e.unit_normal.clone().multiplyScalar(-1)),
(e.equal_weights = !0));
} else {
var _ = -e.weight_min / m,
y = new t.Vector3(
e.point_min.x + _ * l.x,
e.point_min.y + _ * l.y,
e.point_min.z + _ * l.z
);
e.point_iso_zero = y;
var f = -e.weight_min / g,
d = new t.Vector3(
e.point_min.x + f * u.x,
e.point_min.y + f * u.y,
e.point_min.z + f * u.z
);
e.ortho_dir.subVectors(d, y),
e.ortho_dir.normalize(),
e.main_dir.crossVectors(e.ortho_dir, e.unit_normal),
e.main_dir.normalize(),
(e.main_dir.dot(l) < 0 || e.main_dir.dot(u) < 0) &&
e.main_dir.multiplyScalar(-1);
}
var b = l.dot(e.main_dir),
w = u.dot(e.main_dir),
x = null;
(b = b < 0 ? 0 : b) > (w = w < 0 ? 0 : w)
? ((x = l),
  (e.half_dir_1 = u),
  (e.point_half = c),
  (e.half_dir_2 = h.clone().subVectors(h, c)),
  (e.coord_max = b),
  (e.coord_middle = (w / b) * e.coord_max),
  (e.unit_delta_weight = m / e.coord_max))
: ((x = u),
  (e.half_dir_1 = l),
  (e.point_half = h),
  (e.half_dir_2 = c.clone().subVectors(c, h)),
  (e.coord_max = w),
  (e.coord_middle = (b / w) * e.coord_max),
  (e.unit_delta_weight = g / e.coord_max)),
(e.longest_dir_special = x.divideScalar(e.coord_max));
var V = new t.Vector3();
V.subVectors(
e.half_dir_1,
e.longest_dir_special.clone().multiplyScalar(e.coord_middle)
),
(e.max_seg_length = V.length()),
(e.unsigned_ortho_dir = e.ortho_dir.clone()),
e.ortho_dir.dot(V) < 0 && e.ortho_dir.multiplyScalar(-1);
}),
(st.getParametrisedVertexAttr = function(e, i, r) {
var s = st.getMeanThick(e, i, r),
o = new t.Vector3(),
n = o.subVectors(e.v[1].getPos(), e.v[0].getPos()).multiplyScalar(i),
h = o
.clone()
.subVectors(e.v[2].getPos(), e.v[0].getPos())
.multiplyScalar(r);
return o.addVectors(e.v[0].getPos(), n), o.addVectors(o, h), {pos: o, thick: s};
}),
(st.getMeanThick = function(t, e, i) {
return (
t.v[0].getThickness() * (1 - e - i) +
t.v[1].getThickness() * e +
t.v[2].getThickness() * i
);
}),
(st.getMeanMat = function(t, e, i) {
var r = new Material(),
s =
null === t.materials
? [t.v[0].getMaterial(), t.v[0].getMaterial(), t.v[0].getMaterial()]
: [t.materials[0], t.materials[1], t.materials[2]];
return r.weightedMean(s, [1 - e - i, e, i]), r;
}),
(st.getTriBaryCoord = function(e, i, r, s) {
var o = e,
n = i.clone().multiplyScalar(-1),
h = new t.Vector3().subVectors(s, r),
a = o.lengthSq(),
c = o.dot(n),
p = h.dot(o),
l = n.lengthSq(),
u = (a * h.dot(n) - c * p) / (a * l - c * c);
return {u: (p - u * c) / a, v: u};
}),
(st.getUVCoord = function(e, i, r, s) {
var o = new t.Vector3();
o.crossVectors(e, i);
var n = new t.Matrix4();
n.set(e.x, i.x, o.x, 0, e.y, i.y, o.y, 0, e.z, i.z, o.z, 0, 0, 0, 0, 1);
var h = new t.Matrix4();
h.copy(n).invert();
var a = new t.Vector3().subVectors(s, r);
return a.applyMatrix4(h), {u: a.x, v: a.y};
});
var nt = st,
ht = function(e, i, r, s, o, n) {
G.call(this),
(this.tmpVect = new t.Vector3()),
(this.min_thick = o),
(this.max_thick = n),
(this.v = e),
(this.p0p1 = this.tmpVect
.clone()
.subVectors(this.v[1].getPos(), this.v[0].getPos())),
(this.p2p0 = this.tmpVect
.clone()
.subVectors(this.v[0].getPos(), this.v[2].getPos())),
(this.unit_normal = i),
(this.main_dir = r);
var h = Math.abs(this.v[0].getThickness() - this.v[1].getThickness()),
a = Math.abs(this.v[1].getThickness() - this.v[2].getThickness());
(this.equal_weights =
h / Math.abs(this.v[0].getThickness() + this.v[1].getThickness()) < 0.001 &&
a / Math.abs(this.v[1].getThickness() + this.v[2].getThickness()) < 0.001),
(this.segParams = s),
(this.segAttr = {
p0_to_p: 0,
p0_to_p_sqrnorm: 0,
x_p_2D: 0,
y_p_2D: 0,
y_p_2DSq: 0,
p_proj_x: 0
});
var c = this.tmpVect
.clone()
.crossVectors(this.segParams[0].dir, this.unit_normal)
.normalize(),
p = this.tmpVect
.clone()
.crossVectors(this.segParams[1].dir, this.unit_normal)
.normalize(),
l = this.tmpVect
.clone()
.crossVectors(this.segParams[2].dir, this.unit_normal)
.normalize();
this.tmpVect.copy(this.unit_normal);
var u = [];
u.push(
this.tmpVect
.clone()
.addVectors(
this.v[0].getPos(),
this.tmpVect.multiplyScalar(this.v[0].getThickness() * D.KS)
)
),
this.tmpVect.copy(this.unit_normal),
u.push(
this.tmpVect
.clone()
.addVectors(
this.v[1].getPos(),
this.tmpVect.multiplyScalar(this.v[1].getThickness() * D.KS)
)
),
this.tmpVect.copy(this.unit_normal),
u.push(
this.tmpVect
.clone()
.addVectors(
this.v[2].getPos(),
this.tmpVect.multiplyScalar(this.v[2].getThickness() * D.KS)
)
),
this.tmpVect.copy(this.unit_normal),
u.push(
this.tmpVect
.clone()
.addVectors(
this.v[0].getPos(),
this.tmpVect.multiplyScalar(-this.v[0].getThickness() * D.KS)
)
),
this.tmpVect.copy(this.unit_normal),
u.push(
this.tmpVect
.clone()
.addVectors(
this.v[1].getPos(),
this.tmpVect.multiplyScalar(-this.v[1].getThickness() * D.KS)
)
),
this.tmpVect.copy(this.unit_normal),
u.push(
this.tmpVect
.clone()
.addVectors(
this.v[2].getPos(),
this.tmpVect.multiplyScalar(-this.v[2].getThickness() * D.KS)
)
);
var m = new t.Vector3();
this.tmpVect.subVectors(u[1], u[0]), m.subVectors(u[2], u[0]);
var g = this.tmpVect
.clone()
.crossVectors(this.tmpVect, m)
.normalize();
this.tmpVect.subVectors(u[5], u[3]), m.subVectors(u[4], u[3]);
var v = this.tmpVect
.clone()
.crossVectors(this.tmpVect, m)
.normalize();
(this.planeParams = []),
this.planeParams.push({orig: this.v[0].getPos(), n: c}),
this.planeParams.push({orig: this.v[1].getPos(), n: p}),
this.planeParams.push({orig: this.v[2].getPos(), n: l}),
this.planeParams.push({orig: u[0], n: g}),
this.planeParams.push({orig: u[3], n: v}),
(this.segAreas = []);
for (var _ = 0; _ < 3; ++_)
this.segAreas.push(
new et(
this.segParams[_].v[0].getPos(),
this.segParams[_].v[1].getPos(),
this.segParams[_].v[0].getThickness(),
this.segParams[_].v[1].getThickness(),
this.segParams[_].norm,
this.segParams[_].dir
)
);
};
((ht.prototype = Object.create(G.prototype)).constructor = ht),
(ht.prototype.proj_computation = function(t, e) {
(this.segAttr.p0_to_p = this.tmpVect),
this.segAttr.p0_to_p.subVectors(t, e.v[0].getPos()),
(this.segAttr.p0_to_p_sqrnorm = this.segAttr.p0_to_p.lengthSq()),
(this.segAttr.x_p_2D = this.segAttr.p0_to_p.dot(e.dir)),
(this.segAttr.y_p_2DSq =
this.segAttr.p0_to_p_sqrnorm - this.segAttr.x_p_2D * this.segAttr.x_p_2D),
(this.segAttr.y_p_2D =
this.segAttr.y_p_2DSq > 0 ? Math.sqrt(this.segAttr.y_p_2DSq) : 0);
var i = -this.segAttr.y_p_2D / e.ortho_vec_y;
this.segAttr.p_proj_x = this.segAttr.x_p_2D + i * e.ortho_vec_x;
}),
(ht.prototype.sphereIntersect = function(t) {
for (var e = 0; e < 3; e++) {
if (this.sphereIntersectSegment(t, this.segParams[e], D.KS)) return !0;
}
e = 0;
for (var i = !0; e < 5; e++) {
this.tmpVect.subVectors(t.center, this.planeParams[e].orig);
var r = this.tmpVect.dot(this.planeParams[e].n);
i = i && r + t.r > 0;
}
return i;
}),
(ht.prototype.sphereIntersectSegment = function(t, e, i) {
this.proj_computation(t.center, e);
var r = e.v[0].getThickness(),
s = e.v[1].getThickness();
if (this.segAttr.p_proj_x < 0)
return Math.sqrt(this.segAttr.p0_to_p_sqrnorm) - t.r < r * i;
if (this.segAttr.p_proj_x > e.norm)
return (
this.segAttr.p0_to_p.subVectors(t.center, e.v[1].getPos()),
this.segAttr.p0_to_p.length() - t.r < s * i
);
var o = this.segAttr.x_p_2D - this.segAttr.p_proj_x,
n = o * o + this.segAttr.y_p_2DSq,
h = this.segAttr.p_proj_x / e.norm,
a = r * (1 - h) + h * s,
c = t.r + a * i;
return n < c * c;
}),
(ht.prototype.contains = function(t) {
var e = {r: 0, c: t};
return this.sphereIntersect(e);
}),
(ht.prototype.getAccSegment = function(t, e) {
var i = {intersect: !1, currAcc: K.nice * this.min_thick};
if (this.sphereIntersectSegment(t, e, 1)) {
var r = Math.abs(e.diffThick) / e.norm,
s = t.r * Math.sqrt(1 + r * r) * 0.5,
o = e.v[0].getThickness(),
n = e.v[1].getThickness(),
h = this.segAttr.p_proj_x;
if ((h += o > n ? s : -s) <= 0) i.currAcc = o;
else if (h >= e.norm) i.currAcc = n;
else {
var a = h / e.norm;
i.currAcc = o * (1 - a) + a * n;
}
i.intersect = !0;
}
return i;
}),
(ht.prototype.getAccTri = function(t) {
if (this.equal_weights) return this.min_thick;
var e = this.v[0].getPos(),
i = this.tmpVect.addVectors(
t.center,
this.main_dir.clone().multiplyScalar(t.r)
);
this.tmpVect.subVectors(i, e);
var r = this.tmpVect.lengthSq(),
s = this.tmpVect.dot(this.unit_normal),
o = Math.sqrt(r - s * s),
n = this.tmpVect
.clone()
.addVectors(t.center, this.unit_normal.clone().multiplyScalar(-s)),
h = nt.getTriBaryCoord(this.p0p1, this.p2p0, this.v[0].getPos(), n),
a = nt.getMeanThick(this, h.u, h.v);
a = s >= 0 ? a : -a;
var c = o + (-s / o) * (this.v[0].getThickness() - a),
p = this.tmpVect.subVectors(e, n).normalize(),
l = this.tmpVect.addVectors(n, p.multiplyScalar(o - c));
return (h = nt.getTriBaryCoord(this.p0p1, this.p2p0, this.v[0].getPos(), l))
.u <= 1 &&
h.v <= 1 &&
h.u + h.v <= 1 &&
h.u >= 0 &&
h.v >= 0
? nt.getMeanThick(this, h.u, h.v)
: 1e4 * this.max_thick;
}),
(ht.prototype.getAcc = function(t, e) {
for (var i = 0, r = 1e5 * this.max_thick; i < 3; i++) {
var s = this.getAccSegment(t, this.segParams[i]);
s.intersect && (r = r > s.currAcc ? s.currAcc : r);
}
var o = 1e5 * this.max_thick;
r !== this.min_thick && (o = this.getAccTri(t));
var n = Math.min(r, o);
return n !== 1e5 * this.max_thick ? n * e : this.max_thick * e;
}),
(ht.prototype.getNiceAcc = function(t) {
return this.getAcc(t, K.nice);
}),
(ht.prototype.getCurrAcc = function(t) {
return this.getAcc(t, K.curr);
}),
(ht.prototype.getRawAcc = function(t) {
return this.getAcc(t, K.raw);
}),
(ht.prototype.getMinAcc = function() {
return K.curr * this.min_thick;
}),
(ht.prototype.getMinRawAcc = function() {
return K.raw * this.min_thick;
}),
(ht.prototype.getAxisProjectionMinStep = function(t, e) {
for (var i = Number.MAX_VALUE, r = 0; r < 3; ++r)
i = Math.min(i, this.segAreas[r].getAxisProjectionMinStep(t, e));
return i;
});
var at,
ct,
pt,
lt,
ut,
mt,
gt = ht,
vt = function(e, i, r, s) {
if ((O.call(this), 1 !== r))
throw "Error in ScalisTriangle : cannot use a density different from 1.0, not implemented.";
(this.volType = i),
(this.materials =
null !== s
? s
: [
  v.defaultMaterial.clone(),
  v.defaultMaterial.clone(),
  v.defaultMaterial.clone()
  ]),
(this.v = e),
this.v[0].setPrimitive(this),
this.v[1].setPrimitive(this),
this.v[2].setPrimitive(this),
(this.min_thick = Math.min(
this.v[0].getThickness(),
this.v[1].getThickness(),
this.v[2].getThickness()
)),
(this.max_thick = Math.max(
this.v[0].getThickness(),
this.v[1].getThickness(),
this.v[2].getThickness()
)),
(this.res_gseg = {}),
(this.tmp_res_gseg = {}),
(this.p0p1 = new t.Vector3()),
(this.p1p2 = new t.Vector3()),
(this.p2p0 = new t.Vector3()),
(this.unit_normal = new t.Vector3()),
(this.unit_p0p1 = new t.Vector3()),
(this.unit_p1p2 = new t.Vector3()),
(this.unit_p2p0 = new t.Vector3()),
(this.length_p0p1 = 0),
(this.length_p1p2 = 0),
(this.length_p2p0 = 0),
(this.diffThick_p0p1 = 0),
(this.diffThick_p0p1 = 0),
(this.diffThick_p0p1 = 0),
(this.main_dir = new t.Vector3()),
(this.point_iso_zero = new t.Vector3()),
(this.ortho_dir = new t.Vector3()),
(this.unsigned_ortho_dir = new t.Vector3()),
(this.proj_dir = new t.Vector3()),
(this.equal_weights = !1),
(this.coord_max = 0),
(this.coord_middle = 0),
(this.unit_delta_weight = 0),
(this.longest_dir_special = 0),
(this.max_seg_length = 0),
(this.half_dir_1 = new t.Vector3()),
(this.point_half = new t.Vector3()),
(this.half_dir_2 = new t.Vector3()),
(this.point_min = new t.Vector3()),
(this.weight_min = 0),
(this.valid_aabb = !1);
};
((vt.prototype = Object.create(O.prototype)).constructor = vt),
(vt.type = "ScalisTriangle"),
o.register(vt.type, vt),
(vt.prototype.getType = function() {
return vt.type;
}),
(vt.prototype.toJSON = function() {
return O.prototype.toJSON.call(this);
}),
(vt.fromJSON = function(t) {
var e = [C.fromJSON(t.v[0]), C.fromJSON(t.v[1]), C.fromJSON(t.v[2])],
i = [
v.fromJSON(t.materials[0]),
v.fromJSON(t.materials[1]),
v.fromJSON(t.materials[2])
];
return new vt(e, t.volType, 1, i);
}),
(vt.prototype.prepareForEval = function() {
this.valid_aabb || (this.computeHelpVariables(), (this.valid_aabb = !0));
}),
(vt.prototype.getAreas = function() {
if (this.valid_aabb) {
var t = [];
return (
t.push({
norm: this.length_p0p1,
diffThick: this.diffThick_p0p1,
dir: this.unit_p0p1,
v: [this.v[0], this.v[1]],
ortho_vec_x: this.v[0].getThickness() - this.v[1].getThickness(),
ortho_vec_y: this.length_p0p1
}),
t.push({
norm: this.length_p1p2,
diffThick: this.diffThick_p1p2,
dir: this.unit_p1p2,
v: [this.v[1], this.v[2]],
ortho_vec_x: this.v[1].getThickness() - this.v[2].getThickness(),
ortho_vec_y: this.length_p1p2
}),
t.push({
norm: this.length_p2p0,
diffThick: this.diffThick_p2p0,
dir: this.unit_p2p0,
v: [this.v[2], this.v[0]],
ortho_vec_x: this.v[2].getThickness() - this.v[0].getThickness(),
ortho_vec_y: this.length_p2p0
}),
[
{
aabb: this.aabb,
bv: new gt(
this.v,
this.unit_normal,
this.main_dir,
t,
this.min_thick,
this.max_thick
),
obj: this
}
]
);
}
return console.log("ERROR : Cannot get area of invalid primitive"), [];
}),
(vt.prototype.computeHelpVariables = function() {
nt.computeVectorsDirs(this), this.computeAABB();
}),
(vt.prototype.mutableVolType = function() {
return !0;
}),
(vt.prototype.setVolType = function(t) {
if (t != O.CONVOL && t != O.DIST)
throw "ERROR : volType must be set to ScalisPrimitive.CONVOL or ScalisPrimitive.DIST";
this.volType != t && ((this.volType = t), this.invalidAABB());
}),
(vt.prototype.getVolType = function() {
return this.volType;
}),
(vt.prototype.clamp = function(t, e, i) {
return Math.max(e, Math.min(i, t));
}),
(vt.prototype.distanceTo = (function() {
var e = new t.Vector3(),
i = new t.Vector3(),
r = new t.Vector3(),
s = new t.Vector3();
return function(t) {
if (
(e.subVectors(t, this.v[0].getPos()),
i.subVectors(t, this.v[1].getPos()),
r.subVectors(t, this.v[2].getPos()),
s.crossVectors(this.p0p1, e).dot(this.unit_normal) > 0 &&
s.crossVectors(this.p1p2, i).dot(this.unit_normal) > 0 &&
s.crossVectors(this.p2p0, r).dot(this.unit_normal) > 0)
)
return Math.abs(e.dot(this.unit_normal));
var o = e.dot(this.p0p1) / this.length_p0p1;
(o = this.clamp(o, 0, 1)),
s
.copy(this.p0p1)
.multiplyScalar(o)
.add(this.v[0].getPos()),
(o = t.distanceToSquared(s));
var n = i.dot(this.p1p2) / this.length_p1p2;
(n = this.clamp(n, 0, 1)),
s
.copy(this.p1p2)
.multiplyScalar(n)
.add(this.v[1].getPos()),
(n = t.distanceToSquared(s));
var h = r.dot(this.p2p0) / this.length_p2p0;
return (
(h = this.clamp(h, 0, 1)),
s
.copy(this.p2p0)
.multiplyScalar(h)
.add(this.v[2].getPos()),
(h = t.distanceToSquared(s)),
Math.sqrt(Math.min(Math.min(o, n), h))
);
};
})()),
(vt.prototype.heuristicStepWithin = function() {
return this.weight_min / 3;
}),
(vt.prototype.value = function(t, e) {
switch (this.volType) {
case O.DIST:
return this.evalDist(t, e);
case O.CONVOL:
return this.evalConvol(t, e);
default:
throw "Unknown volType, use Orga";
}
}),
(vt.prototype.evalDist = (function() {
var e = {v: 0},
i = new t.Vector3();
return function(r, s) {
var o = new t.Vector3();
o.subVectors(r, this.v[0].getPos());
var n = this.unit_normal.clone().multiplyScalar(-1);
if (!this.equal_weights) {
var h = n,
a = this.unsigned_ortho_dir,
c = this.main_dir.clone().multiplyScalar(-1),
p = -this.v[0].getPos().dot(h),
l = -r.dot(a),
u = -this.point_iso_zero.dot(c),
m = new t.Vector3();
m.crossVectors(a, c), m.multiplyScalar(-p);
var g = new t.Vector3();
g.crossVectors(c, h), g.multiplyScalar(-l);
var v = new t.Vector3();
v.crossVectors(h, a), v.multiplyScalar(-u);
var _ = new t.Vector3();
_.crossVectors(a, c);
var y = new t.Vector3(m.x + g.x + v.x, m.y + g.y + v.y, m.z + g.z + v.z);
y.divideScalar(h.dot(_));
var f = new t.Vector3(y.x - r.x, y.y - r.y, y.z - r.z);
(this.proj_dir = new t.Vector3()),
this.proj_dir.crossVectors(f, this.unsigned_ortho_dir),
this.proj_dir.normalize();
}
var d = new t.Vector3();
d.copy(this.proj_dir),
d.multiplyScalar(-o.dot(n) / this.proj_dir.dot(n)),
d.add(r);
var b = new t.Vector3(),
w = new t.Vector3(),
x = new t.Vector3(),
V = new t.Vector3();
if (
(w.subVectors(d, this.v[0].getPos()),
x.subVectors(d, this.v[1].getPos()),
V.subVectors(d, this.v[2].getPos()),
b.crossVectors(this.unit_p0p1, w).dot(n) > 0 &&
b.crossVectors(this.unit_p1p2, x).dot(n) > 0 &&
b.crossVectors(this.unit_p2p0, V).dot(n) > 0)
) {
b.subVectors(r, d), (s.v = b.lengthSq());
var A = this.v[0].getPos(),
S = this.v[1].getPos(),
T = this.v[2].getPos(),
B = new t.Vector3();
b.subVectors(S, A), B.subVectors(T, A);
var M = new t.Vector3();
M.crossVectors(b, B),
b.subVectors(T, S),
(h = new t.Vector3()).crossVectors(b, x),
b.subVectors(A, T),
(a = new t.Vector3()).crossVectors(b, V),
b.subVectors(S, A),
(c = new t.Vector3()).crossVectors(b, w);
var E = M.lengthSq(),
P = M.dot(h),
k = M.dot(a),
N = M.dot(c),
F =
(P * this.v[0].getThickness() +
k * this.v[1].getThickness() +
N * this.v[2].getThickness()) /
E;
(s.v = D.Poly6Eval(Math.sqrt(s.v) / F) * D.Poly6NF0D),
s.m &&
s.m.triMean(
this.materials[0],
this.materials[1],
this.materials[2],
P,
k,
N,
E
);
} else {
var z = 0;
if (
(this.GenericSegmentComputation(
r,
this.v[0].getPos(),
this.p0p1,
this.length_p0p1,
this.length_p0p1 * this.length_p0p1,
this.v[0].getThickness(),
this.v[1].getThickness() - this.v[0].getThickness(),
this.res_gseg
),
(this.res_gseg.sqrdist = this.res_gseg.proj_to_p.lengthSq()),
(this.res_gseg.ratio =
this.res_gseg.sqrdist /
(this.res_gseg.weight_proj * this.res_gseg.weight_proj)),
this.GenericSegmentComputation(
r,
this.v[1].getPos(),
this.p1p2,
this.length_p1p2,
this.length_p1p2 * this.length_p1p2,
this.v[1].getThickness(),
this.v[2].getThickness() - this.v[1].getThickness(),
this.tmp_res_gseg
),
(this.tmp_res_gseg.sqrdist = this.tmp_res_gseg.proj_to_p.lengthSq()),
(this.tmp_res_gseg.ratio =
this.tmp_res_gseg.sqrdist /
(this.tmp_res_gseg.weight_proj * this.tmp_res_gseg.weight_proj)),
this.res_gseg.ratio > this.tmp_res_gseg.ratio &&
((this.res_gseg.sqrdist = this.tmp_res_gseg.sqrdist),
(this.res_gseg.proj_to_p = this.tmp_res_gseg.proj_to_p),
(this.res_gseg.weight_proj = this.tmp_res_gseg.weight_proj),
(this.res_gseg.ratio = this.tmp_res_gseg.ratio),
(this.res_gseg.t = this.tmp_res_gseg.t),
(z = 1)),
this.GenericSegmentComputation(
r,
this.v[2].getPos(),
this.p2p0,
this.length_p2p0,
this.length_p2p0 * this.length_p2p0,
this.v[2].getThickness(),
this.v[0].getThickness() - this.v[2].getThickness(),
this.tmp_res_gseg
),
(this.tmp_res_gseg.sqrdist = this.tmp_res_gseg.proj_to_p.lengthSq()),
(this.tmp_res_gseg.ratio =
this.tmp_res_gseg.sqrdist /
(this.tmp_res_gseg.weight_proj * this.tmp_res_gseg.weight_proj)),
this.res_gseg.ratio > this.tmp_res_gseg.ratio &&
((this.res_gseg.sqrdist = this.tmp_res_gseg.sqrdist),
(this.res_gseg.proj_to_p = this.tmp_res_gseg.proj_to_p),
(this.res_gseg.weight_proj = this.tmp_res_gseg.weight_proj),
(this.res_gseg.ratio = this.tmp_res_gseg.ratio),
(this.res_gseg.t = this.tmp_res_gseg.t),
(z = 2)),
(s.v =
D.Poly6Eval(Math.sqrt(this.res_gseg.sqrdist) / this.res_gseg.weight_proj) *
D.Poly6NF0D),
s.m)
)
switch (z) {
case 0:
s.m.copy(this.materials[0]), s.m.lerp(this.materials[1], this.res_gseg.t);
break;
case 1:
s.m.copy(this.materials[1]), s.m.lerp(this.materials[2], this.res_gseg.t);
break;
case 2:
s.m.copy(this.materials[2]), s.m.lerp(this.materials[0], this.res_gseg.t);
break;
default:
throw "Error : seg_case unknown";
}
}
if (s.g) {
i.copy(r),
(i.x += 1e-5),
this.evalDist(i, e),
(s.g.x = (e.v - s.v) / 1e-5),
(i.x -= 1e-5),
(i.y += 1e-5),
this.evalDist(i, e),
(s.g.y = (e.v - s.v) / 1e-5),
(i.y -= 1e-5),
(i.z += 1e-5),
this.evalDist(i, e),
(s.g.z = (e.v - s.v) / 1e-5);
}
};
})()),
(vt.prototype.GenericSegmentComputation = function(e, i, r, s, o, n, h, a) {
var c = new t.Vector3();
c.subVectors(e, i);
var p = c.dot(r),
l = c.lengthSq(),
u = o * n + p * h,
m = h < 0 ? 0 : 1;
return (
u > 0 && (m = (m = (p * n + l * h) / u) < 0 ? 0 : m > 1 ? 1 : m),
(a.proj_to_p = new t.Vector3(m * r.x - c.x, m * r.y - c.y, m * r.z - c.z)),
(a.weight_proj = n + m * h),
(a.t = m),
a
);
}),
(vt.prototype.evalConvol =
((at = new t.Vector3()),
(ct = new v()),
(pt = {v: 0, g: null, m: null}),
(lt = new t.Vector3()),
(ut = new v()),
(mt = {v: 0, g: null, m: null}),
function(e, i) {
(pt.g = i.g ? at : null), (pt.m = i.m ? ct : null);
var r = {l1: 0, l2: 0};
if (this.ComputeTParam(e, r)) {
var s = r.l1,
o = r.l2,
n = this.weight_min + s * this.unit_delta_weight,
h = this.warpAbscissa((o - s) / n),
a = 2 * (5 * h + 1),
c = h / a,
p = c;
c *= 2;
for (var l = 0, u = new t.Vector3(), m = 1; m < a; m += 2)
this.computeLineIntegral(this.unwarpAbscissa(p) * n + s, e, pt),
(l += pt.v),
i.g && u.addVectors(u, pt.g),
(p += c);
var g = 0,
v = new t.Vector3();
for (p = 0, m = 2; m < a; m += 2)
(p += c),
this.computeLineIntegral(this.unwarpAbscissa(p) * n + s, e, pt),
i.g && v.addVectors(v, pt.g),
(g += pt.v);
(mt.g = i.g ? lt : null), (mt.m = i.m ? ut : null);
var _ = this.computeLineIntegral(s, e, pt),
y = this.computeLineIntegral(o, e, mt);
i.v = _.v + 4 * l + 2 * g + _.v;
var f = (h / (3 * a)) * D.Poly6NF2D;
if (((i.v *= f), i.g)) {
var d = new t.Vector3();
d.addVectors(d, _.g),
d.addVectors(d, u.multiplyScalar(4)),
d.addVectors(d, v.multiplyScalar(2)),
d.addVectors(d, y.g),
(i.g = d.multiplyScalar(f));
}
} else (i.v = 0), (i.g = new t.Vector3());
i.m && ((pt.g = null), this.evalDist(e, pt), i.m.copy(pt.m));
})),
(vt.prototype.warpAbscissa = function(t) {
var e = t * this.unit_delta_weight,
i = 1 / (e + 2),
r = e * i;
return (
2 *
t *
i *
(1 +
(r *= r) *
(1 / 3 + r * (0.2 + r * (1 / 7 + r * (1 / 9 + r * (1 / 11 + r * (1 / 13)))))))
);
}),
(vt.prototype.unwarpAbscissa = function(t) {
var e = t * this.unit_delta_weight;
return (
t * (1 + e * (0.5 + e * (1 / 6 + e * (1 / 24 + e * (1 / 120 + (1 * e) / 720)))))
);
}),
(vt.prototype.computeLineIntegral = function(e, i, r) {
var s = this.weight_min + e * this.unit_delta_weight,
o = new t.Vector3();
o.addVectors(
this.point_min,
this.longest_dir_special.clone().multiplyScalar(e)
);
var n =
e < this.coord_middle
? (e / this.coord_middle) * this.max_seg_length
: ((this.coord_max - e) / (this.coord_max - this.coord_middle)) *
  this.max_seg_length;
return (
r.g
? this.consWeightEvalGradForSeg(o, s, this.ortho_dir, n, i, r)
: this.consWeightEvalForSeg(o, s, this.ortho_dir, n, i, r),
r
);
}),
(vt.prototype.homotheticClippingSpecial = function(t, e, i) {
var r = -t.z,
s = -t.y,
o = -t.x,
n = s * s - r * o;
if (n >= 0) {
var h = s + Math.sqrt(n);
if (h < 0 || e * h < o) return !1;
var a = o / h;
i.l1 = a < 0 ? 0 : a;
var c = r * a;
return (i.l2 = 2 * s < c + r * e ? o / c : e), !0;
}
return !1;
}),
(vt.prototype.consWeightEvalForSeg = function(e, i, r, s, o, n) {
var h = new t.Vector3();
h.subVectors(o, e);
var a = r.dot(h),
c = h.lengthSq(),
p = new t.Vector3();
p.set(i * i - D.KIS2 * c, -D.KIS2 * a, -D.KIS2);
var l = {l1: 0, l2: 0};
if (this.homotheticClippingSpecial(p, s, l)) {
var u = 1 / i;
(p.x = 1 - D.KIS2 * (l.l1 * (l.l1 - 2 * a) + c) * u * u),
(p.y = -D.KIS2 * (a - l.l1) * u),
(n.v = this.homotheticCompactPolynomial_segment_F_i6_cste(
(l.l2 - l.l1) * u,
p
));
} else n = 0;
return n;
}),
(vt.prototype.consWeightEvalGradForSeg = function(e, i, r, s, o, n) {
var h = new t.Vector3();
h.subVectors(o, e);
var a = r.dot(h),
c = h.lengthSq(),
p = new t.Vector3();
p.set(i * i - D.KIS2 * c, -D.KIS2 * a, -D.KIS2);
var l = {l1: 0, l2: 0};
if (this.homotheticClippingSpecial(p, s, l)) {
var u = 1 / i;
(p.x = 1 - D.KIS2 * (l.l1 * (l.l1 - 2 * a) + c) * u * u),
(p.y = -D.KIS2 * (a - l.l1) * u);
var m = new t.Vector3();
this.homotheticCompactPolynomial_segment_FGradF_i6_cste(
(l.l2 - l.l1) * u,
p,
m
),
(n.v = m.x),
(m.y *= u);
var g = r.clone();
g.multiplyScalar(m.z + l.l1 * m.y),
h.multiplyScalar(-m.y),
h.addVectors(h, g),
(n.g = h.multiplyScalar(6 * D.KIS2 * u));
} else (n.v = 0), n.g.set(0, 0, 0);
return n;
}),
(vt.prototype.ComputeTParam = function(e, i) {
var r = new t.Vector3();
r.subVectors(e, this.point_min);
var s = r.dot(this.main_dir),
o = r.dot(this.unit_normal),
n = s * s + o * o,
h = new t.Vector3();
return (
h.set(
this.weight_min * this.weight_min - D.KIS2 * n,
-this.unit_delta_weight * this.weight_min - D.KIS2 * s,
this.unit_delta_weight * this.unit_delta_weight - D.KIS2
),
this.homotheticClippingSpecial(h, this.coord_max, i)
);
}),
(vt.prototype.homotheticCompactPolynomial_segment_F_i6_cste = function(t, e) {
var i = e.z,
r = i * t,
s = e.y,
o = e.x,
n = i * o - s * s,
h = 1 / i,
a = n * h,
c = o + (-2 * s + r) * t,
p = r - s,
l = p * (c * c),
u = s * (o * o);
return (
((1.2 * ((4 / 3) * (2 * n * t + p * c + s * o) * a + l + u) * a +
c * l +
o * u) *
h) /
7
);
}),
(vt.prototype.homotheticCompactPolynomial_segment_FGradF_i6_cste = function(
t,
e,
i
) {
var r = e.z,
s = r * t,
o = e.y,
n = e.x,
h = r * n - o * o,
a = 1 / r,
c = h * a,
p = n + (-2 * o + s) * t,
l = s - o,
u = p * p,
m = n * n,
g = (4 / 3) * (2 * h * t + l * p + o * n) * c + l * u + o * m,
v = (g * a) / 5,
_ = n * m,
y = p * u;
(i.x = ((1.2 * g * c + l * y + o * _) * a) / 7),
(i.y = v),
(i.z = (o * v + y / 6 - _ / 6) * a);
});
var _t = vt,
yt = function() {};
(yt.prototype.constructor = yt),
(yt.type = "DistanceFunctor"),
o.register(yt.type, yt),
(yt.prototype.getType = function() {
return yt.type;
}),
(yt.prototype.toJSON = function() {
return {type: this.getType()};
}),
(yt.prototype.fromJSON = function(t) {
return o.fromJSON(t);
}),
(yt.prototype.value = function(t) {
throw "Error : not implemented. Must be reimplemented in children classes.";
}),
(yt.prototype.value = function(t) {
throw "Error : not implemented. Must be reimplemented in children classes.";
}),
(yt.prototype.numericalGradient = function(t, e) {
var i = e || 1e-5;
return (this.value(t + i) - this.value(t - i)) / (2 * i);
}),
(yt.prototype.gradient = function(t) {
return this.numericalGradient(t, 1e-5);
}),
(yt.prototype.getSupport = function(t) {
return 1 / 0;
});
var ft = yt,
dt = function(t) {
this.scale = t || 1;
};
((dt.prototype = Object.create(ft.prototype)).constructor = dt),
(dt.type = "Poly6DistanceFunctor"),
o.register(dt.type, dt),
(dt.prototype.getType = function() {
return dt.type;
}),
(dt.prototype.toJSON = function() {
var t = Blobtree.DistanceFunctor.prototype.toJSON.call(this, c);
return (t.scale = this.scale), t;
}),
(dt.evalStandard = function(t) {
if (t < 0) return 1;
var e = 1 - t * t;
return e > 0 ? e * e * e : 0;
}),
(dt.prototype.value = function(t) {
var e = t / (2 * this.scale);
return dt.evalStandard((e += 0.5)) / dt.evalStandard(0.5);
}),
(dt.prototype.gradient = function(t) {
var e = t / (2 * this.scale) + 0.5,
i = 1 - e * e;
return (i = ((-6 / (2 * this.scale)) * e * i * i) / dt.evalStandard(0.5));
}),
(dt.prototype.getSupport = function(t) {
return this.scale;
});
var bt = dt,
wt = function() {
l.call(this),
this.aabb.set(
new THREE.Vector3(-1 / 0, -1 / 0, -1 / 0),
new THREE.Vector3(1 / 0, 1 / 0, 1 / 0)
);
};
((wt.prototype = Object.create(l.prototype)).constructor = wt),
(wt.type = "SDFNode"),
o.register(wt.type, wt),
(wt.prototype.getType = function() {
return wt.type;
}),
(wt.prototype.computeAABB = function() {}),
(wt.prototype.computeDistanceAABB = function(t) {
throw "computeDistanceAABB is an abstract function of SDFNode. Please reimplement it in children classes.";
}),
(wt.prototype.getAreas = function() {
throw "No Areas for SDFNode, except for the SDFRootNode.";
}),
(wt.prototype.distanceTo = function(t) {
throw "distanceTo should be reimplemented in every children classes of SDFNode.";
}),
(wt.prototype.heuristicStepWithin = function() {
throw "heuristicStepWithin may not make sens for all SDFNode, except for the SDFRootNode.";
});
var xt = wt,
Vt = function(e, i, r) {
xt.call(this),
(this.f = e),
(this.material = i ? i.clone() : new v()),
this.addChild(r),
(this.tmp_res = {v: 0, g: null}),
(this.tmp_g = new t.Vector3(0, 0, 0));
};
((Vt.prototype = Object.create(xt.prototype)).constructor = Vt),
(Vt.type = "SDFRootNode"),
o.register(Vt.type, Vt),
(Vt.prototype.getType = function() {
return Vt.type;
}),
(Vt.prototype.addChild = function(t) {
if (0 !== this.children.length)
throw "Error : SDFRootNode can have only one child.";
xt.prototype.addChild.call(this, t);
}),
(Vt.prototype.toJSON = function() {
var t = xt.prototype.toJSON.call(this);
return (t.f = this.f.toJSON()), t;
}),
(Vt.fromJSON = function(t) {
var e = new Vt(o.fromJSON(e.f), o.fromJSON(t.children[0]));
return e;
}),
(Vt.prototype.prepareForEval = function() {
if (!this.valid_aabb) {
this.aabb = new t.Box3();
for (var e = 0; e < this.children.length; ++e) {
var i = this.children[e];
i.prepareForEval(), this.aabb.union(i.computeDistanceAABB(this.f.getSupport()));
}
this.valid_aabb = !0;
}
}),
(Vt.prototype.getAreas = function() {
if (this.valid_aabb) return this.children[0].getAreas(this.f.getSupport());
throw "ERROR : Cannot get area of invalid node";
}),
(Vt.prototype.value = function(t, e) {
var i = this.tmp_res;
(i.g = e.g ? this.tmp_g : null),
(e.v = 0),
e.m && e.m.copy(v.defaultMaterial),
e.g || (void 0 !== e.step && (e.step = 1e9)),
this.aabb.containsPoint(t)
? (this.children[0].value(t, i),
  (e.v = this.f.value(i.v)),
  e.g && e.g.copy(i.g).multiplyScalar(this.f.gradient(e.v)),
  e.m && e.m.copy(this.material))
: void 0 !== e.step && (e.step = this.aabb.distanceToPoint(t) + 0.3);
});
var At,
St = Vt,
Tt = function() {
a.call(this),
this.aabb.set(
new THREE.Vector3(-1 / 0, -1 / 0, -1 / 0),
new THREE.Vector3(1 / 0, 1 / 0, 1 / 0)
);
};
((Tt.prototype = Object.create(a.prototype)).constructor = Tt),
(Tt.type = "SDFPrimitive"),
o.register(Tt.type, Tt),
(Tt.prototype.SDFPrimitive = function() {
return Tt.type;
}),
(Tt.prototype.computeAABB = function() {}),
(Tt.prototype.computeDistanceAABB = function(t) {
throw "computeDistanceAABB is an abstract function of SDFPrimitive. Please reimplement it in children classes.";
}),
(Tt.prototype.getAreas = function() {
throw "No Areas for SDFPrimitive.";
}),
(Tt.prototype.distanceTo =
((At = {v: 0}),
function(t) {
return this.value(t, At), At.v;
})),
(Tt.prototype.heuristicStepWithin = function() {
throw "Not implemented";
});
var Bt = Tt,
Mt = function(t, e) {
Bt.call(this), (this.p = t.clone()), (this.acc = e || 1);
};
((Mt.prototype = Object.create(Bt.prototype)).constructor = Mt),
(Mt.type = "SDFPoint"),
o.register(Mt.type, Mt),
(Mt.prototype.getType = function() {
return Mt.type;
}),
(Mt.prototype.toJSON = function() {
var t = Bt.prototype.toJSON.call(this);
return (t.p = {x: this.p.x, y: this.p.y, z: this.p.z}), (t.acc = this.acc), t;
}),
(Mt.fromJSON = function(e) {
return new Mt(new t.Vector3(e.p.x, e.p.y, e.p.z), e.acc);
}),
(Mt.prototype.setAccuracy = function(t) {
(this.acc = t), this.invalidAABB();
}),
(Mt.prototype.getAccuracy = function() {
return this.acc;
}),
(Mt.prototype.setPosition = function(t) {
this.p.copy(t), this.invalidAABB();
}),
(Mt.prototype.getPosition = function() {
return this.p;
}),
(Mt.prototype.computeDistanceAABB = function(e) {
return new t.Box3(
this.p.clone().add(new t.Vector3(-e, -e, -e)),
this.p.clone().add(new t.Vector3(e, e, e))
);
}),
(Mt.prototype.prepareForEval = function() {
this.valid_aabb || (this.valid_aabb = !0);
}),
(Mt.prototype.getAreas = function(t) {
if (this.valid_aabb)
return [
{aabb: this.computeDistanceAABB(t), bv: new X(this.p, t, this.acc), obj: this}
];
throw "ERROR : Cannot get area of invalid primitive";
}),
(Mt.prototype.value = (function() {
var e = new t.Vector3();
return function(t, i) {
if (!this.valid_aabb) throw "Error : PrepareForEval should have been called";
e.subVectors(t, this.p);
var r = e.length();
(i.v = r), i.g && i.g.copy(e).multiplyScalar(1 / r);
};
})());
var Et = Mt,
Pt = function(e, i, r, s, o, n) {
G.call(this),
(this.p1 = e.clone()),
(this.p2 = i.clone()),
(this.r1 = r),
(this.r2 = s),
(this.accFactor1 = o || 1),
(this.accFactor2 = n || 1),
(this.unit_dir = new t.Vector3().subVectors(i, e)),
(this.length = this.unit_dir.length()),
this.unit_dir.normalize(),
(this.vector = new t.Vector3()),
(this.p1_to_p = this.vector),
(this.p1_to_p_sqrnorm = 0),
(this.x_p_2D = 0),
(this.y_p_2D = 0),
(this.y_p_2DSq = 0),
(this.ortho_vec_x = this.r1 - this.r2),
(this.ortho_vec_y = this.length),
(this.p_proj_x = 0),
(this.p_proj_y = 0),
(this.abs_diff_thick = Math.abs(this.ortho_vec_x));
};
((Pt.prototype = Object.create(G.prototype)).constructor = Pt),
(Pt.prototype.proj_computation = function(t) {
(this.p1_to_p = this.vector),
this.p1_to_p.subVectors(t, this.p1),
(this.p1_to_p_sqrnorm = this.p1_to_p.lengthSq()),
(this.x_p_2D = this.p1_to_p.dot(this.unit_dir)),
(this.y_p_2DSq = this.p1_to_p_sqrnorm - this.x_p_2D * this.x_p_2D),
(this.y_p_2D = this.y_p_2DSq > 0 ? Math.sqrt(this.y_p_2DSq) : 0);
var e = -this.y_p_2D / this.ortho_vec_y;
(this.p_proj_x = this.x_p_2D + e * this.ortho_vec_x), (this.p_proj_y = 0);
}),
(Pt.prototype.sphereIntersect = function(t) {
if ((this.proj_computation(t.center), this.p_proj_x < 0))
return Math.sqrt(this.p1_to_p_sqrnorm) - t.radius < this.r1;
if (this.p_proj_x > this.length)
return (
this.vector.subVectors(t.center, this.p2),
Math.sqrt(this.vector.lengthSq()) - t.radius < this.r2
);
var e = this.x_p_2D - this.p_proj_x,
i = e * e + this.y_p_2DSq,
r = this.p_proj_x / this.length,
s = this.r1 * (1 - r) + r * this.r2,
o = t.radius + s;
return i < o * o;
}),
(Pt.prototype.contains = function(t) {
if ((this.proj_computation(t), this.p_proj_x < 0))
return this.p1_to_p_sqrnorm < this.r1 * this.r1;
if (this.p_proj_x > this.length)
return (
this.vector.subVectors(t, this.p2), this.vector.lengthSq() < this.r2 * this.r2
);
var e = this.x_p_2D - this.p_proj_x,
i = this.y_p_2D - this.p_proj_y,
r = e * e + i * i,
s = this.p_proj_x / this.length,
o = this.r1 * (1 - s) + s * this.r2;
return r < o * o;
}),
(Pt.prototype.getAcc = function(t, e) {
this.proj_computation(t.center);
var i = this.abs_diff_thick / this.length,
r = t.radius * Math.sqrt(1 + i * i) * 0.5,
s = this.p_proj_x;
if ((s += this.r1 > this.r2 ? r : -r) < 0) return this.r1 * this.accFactor1 * e;
if (s > this.length) return this.r2 * this.accFactor2 * e;
var o = s / this.length;
return (
(this.r1 * this.accFactor1 * (1 - o) + o * this.r2 * this.accFactor2) * e
);
}),
(Pt.prototype.getNiceAcc = function(t) {
return this.getAcc(t, K.nice);
}),
(Pt.prototype.getCurrAcc = function(t) {
return this.getAcc(t, K.curr);
}),
(Pt.prototype.getRawAcc = function(t) {
return this.getAcc(t, K.raw);
}),
(Pt.prototype.getMinAcc = function() {
return K.curr * Math.min(this.r1 * this.accFactor1, this.r2 * this.accFactor2);
}),
(Pt.prototype.getMinRawAcc = function() {
return K.raw * Math.min(this.r1 * this.accFactor1, this.r2 * this.accFactor2);
}),
(Pt.prototype.getAxisProjectionMinStep = function(t, e) {
var i,
r,
s,
o = Number.MAX_VALUE,
n = this.p1[t] < this.p2[t] ? this.p1 : this.p2;
n === this.p1
? ((i = this.p2),
  (r = this.r1 * this.accFactor1),
  (s = this.r2 * this.accFactor2))
: ((i = this.p1), (r = this.r2), (s = this.r1 * this.accFactor1));
var h = e - n[t];
h < -2 * r
? (o = Math.min(o, Math.max(Math.abs(h + 2 * r), K.curr * r)))
: h < 2 * r && (o = Math.min(o, K.curr * r)),
(h = e - i[t]) < -2 * s
? (o = Math.min(o, Math.max(Math.abs(h + 2 * s), K.curr * s)))
: h < 2 * s && (o = Math.min(o, K.curr * s));
var a = e - n[t],
c = i[t] - n[t];
return (
a > 0 &&
a < c &&
0 !== c &&
(o = Math.min(o, K.curr * (r + (a / c) * (s - r)))),
o
);
});
var kt = Pt,
Nt = function(e, i, r) {
Bt.call(this),
(this.p1 = e.clone()),
(this.p2 = i.clone()),
(this.acc = r || 1),
(this.l = new t.Line3(this.p1, this.p2));
};
((Nt.prototype = Object.create(Bt.prototype)).constructor = Nt),
(Nt.type = "SDFSegment"),
o.register(Nt.type, Nt),
(Nt.prototype.getType = function() {
return Nt.type;
}),
(Nt.prototype.toJSON = function() {
var t = Bt.prototype.toJSON.call(this);
return (
(t.p1 = {x: this.p1.x, y: this.p1.y, z: this.p1.z}),
(t.p2 = {x: this.p2.x, y: this.p2.y, z: this.p2.z}),
(t.acc = this.acc),
t
);
}),
(Nt.fromJSON = function(e) {
ScalisVertex.fromJSON(e.v[0]);
return new Nt(
new t.Vector3(e.p1.x, e.p1.y, e.p1.z),
new t.Vector3(e.p2.x, e.p2.y, e.p2.z),
e.acc
);
}),
(Nt.prototype.setAccuracy = function(t) {
(this.acc = t), this.invalidAABB();
}),
(Nt.prototype.getAccuracy = function() {
return this.acc;
}),
(Nt.prototype.setPosition1 = function(t) {
this.p1.copy(t), this.invalidAABB();
}),
(Nt.prototype.setPosition2 = function(t) {
this.p2.copy(t), this.invalidAABB();
}),
(Nt.prototype.getPosition1 = function() {
return this.p1;
}),
(Nt.prototype.getPosition2 = function() {
return this.p2;
}),
(Nt.prototype.computeDistanceAABB = function(e) {
var i = new t.Box3(
this.p1.clone().add(new t.Vector3(-e, -e, -e)),
this.p1.clone().add(new t.Vector3(e, e, e))
),
r = new t.Box3(
this.p2.clone().add(new t.Vector3(-e, -e, -e)),
this.p2.clone().add(new t.Vector3(e, e, e))
);
return i.union(r);
}),
(Nt.prototype.prepareForEval = function() {
this.valid_aabb || (this.l.set(this.p1, this.p2), (this.valid_aabb = !0));
}),
(Nt.prototype.getAreas = function(t) {
if (this.valid_aabb)
return [
{
aabb: this.computeDistanceAABB(t),
bv: new kt(this.p1, this.p2, t, t, this.acc, this.acc),
obj: this
}
];
throw "ERROR : Cannot get area of invalid primitive";
}),
(Nt.prototype.value = (function() {
var e = new t.Vector3(),
i = new t.Vector3();
return function(t, r) {
this.l.closestPointToPoint(t, !0, e),
(r.v = i.subVectors(t, e).length()),
r.g && r.g.copy(i).divideScalar(r.v);
};
})());
var Ft = Nt,
zt = function(t, e) {
Bt.call(this), (this.p = t.clone()), (this.r = e);
};
((zt.prototype = Object.create(Bt.prototype)).constructor = zt),
(zt.type = "SDFSphere"),
o.register(zt.type, zt),
(zt.prototype.getType = function() {
return zt.type;
}),
(zt.prototype.toJSON = function() {
var t = Bt.prototype.toJSON.call(this);
return (t.p = {x: this.p.x, y: this.p.y, z: this.p.z}), (t.r = this.r), t;
}),
(zt.fromJSON = function(e) {
return new zt(new t.Vector3(e.p.x, e.p.y, e.p.z), e.r);
}),
(zt.prototype.setRadius = function(t) {
(this.r = t), this.invalidAABB();
}),
(zt.prototype.getRadius = function() {
return this.r;
}),
(zt.prototype.setPosition = function(t) {
this.p.copy(t), this.invalidAABB();
}),
(zt.prototype.getPosition = function() {
return this.p;
}),
(zt.prototype.computeDistanceAABB = function(e) {
return new t.Box3(
this.p.clone().add(new t.Vector3(-this.r - e, -this.r - e, -this.r - e)),
this.p.clone().add(new t.Vector3(this.r + e, this.r + e, this.r + e))
);
}),
(zt.prototype.prepareForEval = function() {
this.valid_aabb || (this.valid_aabb = !0);
}),
(zt.prototype.getAreas = function(t) {
if (this.valid_aabb)
return [
{
aabb: this.computeDistanceAABB(t),
bv: new X(this.p, this.r + t, this.r / (this.r + t)),
obj: this
}
];
throw "ERROR : Cannot get area of invalid primitive";
}),
(zt.prototype.value = (function() {
var e = new t.Vector3();
return function(t, i) {
if (!this.valid_aabb) throw "Error : PrepareForEval should have been called";
e.subVectors(t, this.p);
var r = e.length();
(i.v = r - this.r), i.g && i.g.copy(e).multiplyScalar(1 / r);
};
})());
var Dt = zt,
Rt = function(e, i, r, s) {
Bt.call(this),
(this.p1 = e.clone()),
(this.p2 = i.clone()),
(this.r1 = r),
(this.r2 = s),
(this.r1 = this.r1),
(this.rdiff = this.r2 - this.r1),
(this.unit_dir = new t.Vector3().subVectors(this.p2, this.p1)),
(this.lengthSq = this.unit_dir.lengthSq()),
(this.length = this.unit_dir.length()),
this.unit_dir.normalize();
};
((Rt.prototype = Object.create(Bt.prototype)).constructor = Rt),
(Rt.type = "SDFCapsule"),
o.register(Rt.type, Rt),
(Rt.prototype.getType = function() {
return Rt.type;
}),
(Rt.prototype.toJSON = function() {
var t = Bt.prototype.toJSON.call(this);
return (
(t.p1 = {x: this.p1.x, y: this.p1.y, z: this.p1.z}),
(t.r1 = this.r1),
(t.p2 = {x: this.p2.x, y: this.p2.y, z: this.p2.z}),
(t.r2 = this.r2),
t
);
}),
(Rt.fromJSON = function(e) {
ScalisVertex.fromJSON(e.v[0]);
return new Rt(
new t.Vector3(e.p1.x, e.p1.y, e.p1.z),
new t.Vector3(e.p2.x, e.p2.y, e.p2.z),
e.r1,
e.r2
);
}),
(Rt.prototype.setRadius1 = function(t) {
(this.r1 = t), this.invalidAABB();
}),
(Rt.prototype.setRadius2 = function(t) {
(this.r1 = t), this.invalidAABB();
}),
(Rt.prototype.getRadius1 = function() {
return this.r1;
}),
(Rt.prototype.getRadius2 = function() {
return this.r2;
}),
(Rt.prototype.setPosition1 = function(t) {
this.p1.copy(t), this.invalidAABB();
}),
(Rt.prototype.setPosition2 = function(t) {
this.p2.copy(t), this.invalidAABB();
}),
(Rt.prototype.getPosition1 = function() {
return this.p1;
}),
(Rt.prototype.getPosition2 = function() {
return this.p2;
}),
(Rt.prototype.computeDistanceAABB = function(e) {
var i = new t.Box3(
this.p1.clone().add(new t.Vector3(-this.r1 - e, -this.r1 - e, -this.r1 - e)),
this.p1.clone().add(new t.Vector3(this.r1 + e, this.r1 + e, this.r1 + e))
),
r = new t.Box3(
this.p2.clone().add(new t.Vector3(-this.r2 - e, -this.r2 - e, -this.r2 - e)),
this.p2.clone().add(new t.Vector3(this.r2 + e, this.r2 + e, this.r2 + e))
);
return i.union(r);
}),
(Rt.prototype.prepareForEval = function() {
this.valid_aabb || (this.valid_aabb = !0);
}),
(Rt.prototype.getAreas = function(t) {
if (this.valid_aabb)
return [
{
aabb: this.computeDistanceAABB(t),
bv: new kt(
this.p1,
this.p2,
this.r1 + t,
this.r2 + t,
this.r1 / (this.r1 + t),
this.r2 / (this.r2 + t)
),
obj: this
}
];
throw "ERROR : Cannot get area of invalid primitive";
}),
(Rt.prototype.value = (function() {
var e = new t.Vector3(),
i = new t.Vector3();
return function(r, s) {
e.subVectors(r, this.p1);
var o = e.lengthSq(),
n = e.dot(this.unit_dir),
h =
n + (-Math.sqrt(Math.max(0, o - n * n)) / this.length) * (this.r1 - this.r2),
a = t.Math.clamp(h / this.length, 0, 1);
i.copy(this.p1).lerp(this.p2, a);
var c = e.subVectors(r, i).length();
(s.v = c - (a * this.r2 + (1 - a) * this.r1)),
s.g && s.g.copy(e).divideScalar(c);
};
})());
var Ot = Rt,
qt = {
EdgeVMap: [
[0, 4],
[1, 5],
[2, 6],
[3, 7],
[0, 2],
[1, 3],
[4, 6],
[5, 7],
[0, 1],
[2, 3],
[4, 5],
[6, 7]
],
VertexTopo: [
[0, 0, 0],
[0, 0, 1],
[0, 1, 0],
[0, 1, 1],
[1, 0, 0],
[1, 0, 1],
[1, 1, 0],
[1, 1, 1]
]
},
jt = qt;
const {Box2: Ct} = t,
It = t;
class Jt extends Ct {
constructor(t, e, i, r) {
if ((super(t, e), null == i)) {
var s = Math.max(this.max.x - this.min.x, this.max.y - this.min.y);
this.nice_acc = s <= 0 ? 1e7 : s;
} else this.nice_acc = i;
this.raw_acc = null == r ? this.nice_acc : r;
}
union(t) {
super.union(t),
(this.raw_acc = Math.min(t.raw_acc, this.raw_acc)),
(this.nice_acc = Math.min(t.nice_acc, this.nice_acc));
}
getRawAcc() {
return this.raw_acc;
}
getNiceAcc() {
return this.nice_acc;
}
setRawAcc(t) {
this.raw_acc = Math.max(0, t);
}
setNiceAcc(t) {
this.nice_acc = Math.max(0, t);
}
toString() {
return (
"(" +
this.min.x.toFixed(2) +
", " +
this.min.y.toFixed(2) +
") -> (" +
this.max.x.toFixed(2) +
", " +
this.max.y.toFixed(2) +
") "
);
}
set(t, e, i, r, s, o) {
this.min.set(t, e),
this.max.set(i, r),
void 0 !== s && (this.nice_acc = s),
void 0 !== o && (this.raw_acc = o);
}
getMinCorner() {
return this.min;
}
}
var Gt,
Ht,
Kt = function(t, e) {
e = e || {};
(this.blobtree = t),
(this.uniformZ = "uniform" === e.zResolution),
(this.detail_ratio = e.detailRatio ? Math.max(0.01, e.detailRatio) : 1),
e.convergence
? ((this.convergence = e.convergence),
  (this.convergence.ratio = this.convergence.ratio || 0.01),
  (this.convergence.step = this.convergence.step || 10))
: (this.convergence = null),
(this.progress = e.progress ? e.progress : function(t) {}),
(this.reso = new Int32Array(3)),
(this.steps = {x: null, y: null, z: null}),
(this.curr_steps = {x: 0, y: 0, z: 0}),
(this.curr_step_vol = 0),
(this.values_xy = [null, null]),
(this.vertices_xy = [null, null]),
(this.areas = []),
(this.min_acc = 1),
(this.values = new Array(8)),
(this.x = 0),
(this.y = 0),
(this.z = 0),
(this.mask = 0),
(this.edge_cross = [!1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1]),
(this.vertex = new It.Vector3(0, 0, 0)),
(this.vertex_n = new It.Vector3(0, 0, 0)),
(this.vertex_m = new v()),
(this.extended = !1),
(this.dis_o_aabb = new It.Box3()),
(this.ext_p = new It.Vector3()),
(this.geometry = null);
};
(Kt.prototype.initGeometry = function() {
this.geometry = {
position: [],
normal: [],
color: [],
metalness: [],
roughness: [],
nVertices: 0,
faces: [],
nFaces: 0,
addVertex: function(t) {
this.position.push(t.p.x, t.p.y, t.p.z),
this.normal.push(t.n.x, t.n.y, t.n.z),
this.color.push(t.c.r, t.c.g, t.c.b),
this.roughness.push(t.r),
this.metalness.push(t.m),
this.nVertices++;
},
addFace: function(t, e, i) {
this.faces.push(t, e, i), this.nFaces++;
}
};
}),
(Kt.prototype.buildResultingBufferGeometry = function() {
var t = new It.BufferGeometry();
return (
t.setAttribute(
"position",
new It.BufferAttribute(new Float32Array(this.geometry.position), 3)
),
t.setAttribute(
"normal",
new It.BufferAttribute(new Float32Array(this.geometry.normal), 3)
),
t.setAttribute(
"color",
new It.BufferAttribute(new Float32Array(this.geometry.color), 3)
),
t.setAttribute(
"roughness",
new It.BufferAttribute(new Float32Array(this.geometry.roughness), 1)
),
t.setAttribute(
"metalness",
new It.BufferAttribute(new Float32Array(this.geometry.metalness), 1)
),
t.setIndex(
new It.BufferAttribute(
this.geometry.nVertices > 65535
? new Uint32Array(this.geometry.faces)
: new Uint16Array(this.geometry.faces),
1
)
),
t
);
}),
(Kt.prototype.setFrontToZero = function() {
for (var t = 0; t < this.values_xy[1].length; ++t) this.values_xy[1][t] = 0;
}),
(Kt.prototype.setFrontToMinus = function() {
for (var t = 0; t < this.values_xy[1].length; ++t) this.values_xy[1][t] = -1;
}),
(Kt.prototype.setFrontToZeroIfMinus = function() {
for (var t = 0; t < this.values_xy[1].length; ++t)
-1 === this.values_xy[1][t] && (this.values_xy[1][t] = 0);
}),
(Kt.prototype.interpolateInBox = function(t, e, i, r, s, o, n) {
var h = this.values_xy[1],
a = s - r,
c = n - o;
if (a > 1)
for (
var p = h[(m = o * this.reso[0]) + r], l = (h[m + s] - p) / a, u = 1;
u < a;
++u
)
-1 === h[m + r + u] && (h[m + r + u] = p + u * l);
if (c > 1) {
var m;
for (
p = h[(m = n * this.reso[0]) + r], l = (h[m + s] - p) / a, u = 1;
u < a;
++u
)
-1 === h[m + r + u] && (h[m + r + u] = p + u * l);
for (u = 0; u <= a; ++u) {
(p = h[o * this.reso[0] + r + u]), (l = (h[n * this.reso[0] + r + u] - p) / c);
for (var g = 1; g < c; ++g)
-1 === h[(o + g) * this.reso[0] + r + u] &&
(h[(o + g) * this.reso[0] + r + u] = p + g * l);
}
}
}),
(Kt.prototype.computeFrontValAt = function(t, e, i, r, s) {
this.computeFrontValAtClosure(t, e, i, r, s);
}),
(Kt.prototype.computeFrontValAtClosure =
((Gt = {v: 0}),
(Ht = new It.Vector3()),
function(t, e, i, r, s) {
var o = s * this.reso[0] + r;
(Gt.v = this.blobtree.getNeutralValue()),
-1 === this.values_xy[1][o] &&
(Ht.set(t + r * this.min_acc, e + s * this.min_acc, i),
this.blobtree.value(Ht, Gt),
(this.values_xy[1][o] = Gt.v));
})),
(Kt.prototype.computeFrontValAtBoxCorners = function(t, e, i, r, s) {
this.computeFrontValAt(t, e, i, r.x, r.y),
this.computeFrontValAt(t, e, i, r.x, s.y),
this.computeFrontValAt(t, e, i, s.x, r.y),
this.computeFrontValAt(t, e, i, s.x, s.y);
}),
(Kt.prototype.computeFrontValInBox = function(t, e, i, r, s) {
for (var o = r.x; o <= s.x; ++o)
for (var n = r.y; n <= s.y; ++n) this.computeFrontValAt(t, e, i, o, n);
}),
(Kt.prototype.setFrontValZeroInBox = function(t, e) {
for (var i = t.x; i <= e.x; ++i)
for (var r = t.y; r <= e.y; ++r) this.values_xy[1][r * this.reso[0] + i] = 0;
}),
(Kt.prototype.computeBoxMask = function(t, e) {
var i = 0;
return (
(i |=
this.values_xy[1][t.y * this.reso[0] + t.x] > this.blobtree.getIsoValue()
? 1
: 0),
(i |=
this.values_xy[1][t.y * this.reso[0] + e.x] > this.blobtree.getIsoValue()
? 2
: 0),
(i |=
this.values_xy[1][e.y * this.reso[0] + e.x] > this.blobtree.getIsoValue()
? 4
: 0),
(i |=
this.values_xy[1][e.y * this.reso[0] + t.x] > this.blobtree.getIsoValue()
? 8
: 0)
);
}),
(Kt.prototype.checkZeroBox = function(t, e) {
return (
this.values_xy[1][t.y * this.reso[0] + t.x] +
this.values_xy[1][t.y * this.reso[0] + e.x] +
this.values_xy[1][e.y * this.reso[0] + e.x] +
this.values_xy[1][e.y * this.reso[0] + t.x]
);
}),
(Kt.prototype.recursiveBoxComputation = function(t, e, i, r, s) {
var o = null,
n = new It.Vector2(
Math.round(r.max.x - r.min.x),
Math.round(r.max.y - r.min.y)
);
if (n.x > 1 && n.x >= n.y) {
var h = r.min.x + Math.floor(n.x / 2);
(o = [
new Jt(r.min, new It.Vector2(h, r.max.y), 1e4, 1e4),
new Jt(new It.Vector2(h, r.min.y), r.max, 1e4, 1e4)
]),
this.computeFrontValAt(t, e, i, h, r.min.y),
this.computeFrontValAt(t, e, i, h, r.max.y);
} else {
if (!(n.y > 1)) return;
var a = r.min.y + Math.floor(n.y / 2);
(o = [
new Jt(r.min, new It.Vector2(r.max.x, a), 1e4, 1e4),
new Jt(new It.Vector2(r.min.x, a), r.max, 1e4, 1e4)
]),
this.computeFrontValAt(t, e, i, r.min.x, a),
this.computeFrontValAt(t, e, i, r.max.x, a);
}
for (var c = [[], []], p = 0; p < s.length; ++p)
for (var l = 0; l < o.length; ++l)
o[l].intersectsBox(s[p]) &&
(o[l].setRawAcc(Math.min(o[l].getRawAcc(), s[p].getRawAcc())),
o[l].setNiceAcc(Math.min(o[l].getNiceAcc(), s[p].getNiceAcc())),
c[l].push(s[p]));
for (l = 0; l < o.length; ++l) {
var u = o[l],
m = u.getSize(new It.Vector3());
if (0 === c[l].length) this.setFrontValZeroInBox(u.min, u.max);
else if (m.x <= u.getRawAcc() && m.y <= u.getRawAcc()) {
var g = this.computeBoxMask(u.min, u.max);
15 === g || 0 === g
? this.interpolateInBox(t, e, i, u.min.x, u.max.x, u.min.y, u.max.y)
: m.x <= u.getNiceAcc() && m.y <= u.getNiceAcc()
? this.interpolateInBox(t, e, i, u.min.x, u.max.x, u.min.y, u.max.y)
: this.recursiveBoxComputation(t, e, i, u, c[l]);
} else this.recursiveBoxComputation(t, e, i, u, c[l]);
}
}),
(Kt.prototype.computeFrontValues = function(t, e, i) {
this.setFrontToMinus();
var r = this.blobtree.getAreas(),
s = new Jt();
s.makeEmpty();
for (var o = [], n = 0; n < r.length; ++n) {
var h = Math.round((r[n].bv.getMinRawAcc() * this.detail_ratio) / this.min_acc),
a = Math.round((r[n].bv.getMinAcc() * this.detail_ratio) / this.min_acc),
c = Math.max(0, Math.floor((r[n].aabb.min.x - t) / this.min_acc)),
p = Math.max(0, Math.floor((r[n].aabb.min.y - e) / this.min_acc)),
l = Math.min(this.reso[0] - 1, Math.ceil((r[n].aabb.max.x - t) / this.min_acc)),
u = Math.min(this.reso[1] - 1, Math.ceil((r[n].aabb.max.y - e) / this.min_acc));
o.push(new Jt(new It.Vector2(c, p), new It.Vector2(l, u), a, h)),
s.union(o[o.length - 1]);
}
s.intersect(
new Jt(
new It.Vector2(0, 0),
new It.Vector2(this.reso[0], this.reso[1]),
s.getNiceAcc(),
s.getRawAcc()
)
),
this.computeFrontValAtBoxCorners(t, e, i, s.min, s.max),
this.recursiveBoxComputation(t, e, i, s, o),
this.setFrontToZeroIfMinus();
}),
(Kt.prototype.getMinAcc = function(t) {
for (
var e = this.blobtree.getAreas(), i = Number.MAX_VALUE, r = 0;
r < e.length;
r++
) {
var s = e[r];
if (s.aabb.intersectsBox(t) && s.bv) {
var o = s.bv.getMinAcc();
o < i && (i = o);
}
}
return i * this.detail_ratio;
}),
(Kt.prototype.getMaxAcc = function(t) {
for (var e = this.blobtree.getAreas(), i = 0, r = 0; r < e.length; r++) {
var s = e[r];
if (s.aabb.intersectsBox(t) && s.bv) {
var o = s.bv.getMinAcc();
o > i && (i = o);
}
}
return i * this.detail_ratio;
}),
(Kt.prototype.compute = function(t, e) {
this.initGeometry();
var i = new Date();
this.blobtree.prepareForEval();
var r = null;
if (
((r = t ? t.clone() : this.blobtree.getAABB()),
(this.extended = void 0 !== e && e),
this.extended)
) {
for (
var s = r.getSize(new It.Vector3()),
o = Math.min(Math.min(this.getMinAcc(r), s[0]), Math.min(s[1], s[2])),
n = r.clone(),
h = r.clone(),
a = ["x", "y", "z"],
c = 0;
c < a.length;
++c
) {
n.max[a[c]] = r.min[a[c]] + o;
var p = this.getMaxAcc(n);
0 !== p && (h.min[a[c]] = h.min[a[c]] - p),
(n.max[a[c]] = r.max[a[c]] - o),
0 !== (p = this.getMaxAcc(n)) && (h.max[a[c]] = h.max[a[c]] + p);
}
r.copy(h);
}
var l = [],
u = [];
if (
(t && (this.blobtree.externalTrim(r, l, u), this.blobtree.prepareForEval()),
(this.areas = this.blobtree.getAreas()),
0 === this.areas.length)
)
return this.progress(100), new It.BufferGeometry();
this.min_acc = 0 !== this.areas.length ? this.areas[0].bv.getMinAcc() : 1;
for (var m = 0; m < this.areas.length; ++m)
this.areas[m].bv.getMinAcc() < this.min_acc &&
(this.min_acc = this.areas[m].bv.getMinAcc());
this.min_acc = this.min_acc * this.detail_ratio;
var g = r.min,
v = r.getSize(new It.Vector3());
this.steps.z = new Float32Array(Math.ceil(v.z / this.min_acc) + 2);
g.z;
this.steps.z[0] = g.z;
for (
var _ = 1, y = this.blobtree.getAreas();
this.steps.z[_ - 1] < g.z + v.z;

) {
var f = v.z;
if (this.uniformZ) f = this.min_acc;
else
for (m = 0; m < y.length; ++m)
f = Math.min(
f,
y[m].bv.getAxisProjectionMinStep("z", this.steps.z[_ - 1]) * this.detail_ratio
);
(this.steps.z[_] = this.steps.z[_ - 1] + f), _++;
}
if (
((this.reso[2] = _),
(this.reso[0] = Math.ceil(v.x / this.min_acc) + 2),
(this.reso[1] = Math.ceil(v.y / this.min_acc) + 2),
this.extended)
) {
m = 0;
for (
this.dis_o_aabb.set(new It.Vector3(-1, -1, -1), new It.Vector3(-1, -1, -1));
m < this.reso[2] && -1 === this.dis_o_aabb.min.z;

)
this.steps.z[m] >= t.min.z && (this.dis_o_aabb.min.z = m), m++;
for (
m > this.reso[2] - 1 && (this.dis_o_aabb.min.z = this.reso[2] - 1),
m = this.reso[2] - 1;
m >= 0 && -1 === this.dis_o_aabb.max.z;

)
this.steps.z[m] < t.max.z && (this.dis_o_aabb.max.z = m), m--;
m < 0 && (this.dis_o_aabb.max.z = 0),
(this.dis_o_aabb.min.x = Math.round((t.min.x - r.min.x) / this.min_acc)),
(this.dis_o_aabb.min.y = Math.round((t.min.y - r.min.y) / this.min_acc)),
(this.dis_o_aabb.max.x =
this.reso[0] - 2 - Math.round((r.max.x - t.max.x) / this.min_acc)),
(this.dis_o_aabb.max.y =
this.reso[1] - 2 - Math.round((r.max.y - t.max.y) / this.min_acc));
}
(this.values_xy[0] = new Float32Array(this.reso[0] * this.reso[1])),
(this.values_xy[1] = new Float32Array(this.reso[0] * this.reso[1])),
(this.vertices_xy[0] = new Int32Array(this.reso[0] * this.reso[1])),
(this.vertices_xy[1] = new Int32Array(this.reso[0] * this.reso[1]));
var d = new It.Box3();
this.computeFrontValues(g.x, g.y, g.z);
for (var b = 0, w = 0; w < this.reso[2] - 1; ++w) {
var x = this.values_xy[0];
(this.values_xy[0] = this.values_xy[1]),
(this.values_xy[1] = x),
(x = this.vertices_xy[0]),
(this.vertices_xy[0] = this.vertices_xy[1]),
(this.vertices_xy[1] = x);
var V = this.steps.z[w + 1];
d.set(
new It.Vector3(g.x, g.y, V - this.min_acc / 64),
new It.Vector3(
g.x + this.reso[0] * this.min_acc,
g.y + this.reso[1] * this.min_acc,
V + this.min_acc / 64
)
),
this.blobtree.internalTrim(d),
this.blobtree.prepareForEval(),
this.computeFrontValues(g.x, g.y, V),
this.blobtree.internalUntrim(d),
this.blobtree.prepareForEval(),
(this.z = this.steps.z[w]),
(this.curr_steps.z = this.steps.z[w + 1] - this.steps.z[w]),
(this.curr_steps.x = this.min_acc),
(this.curr_steps.y = this.min_acc),
(this.curr_step_vol =
this.curr_steps.x * this.curr_steps.y * this.curr_steps.z);
for (var A = 0; A < this.reso[1] - 1; ++A)
for (var S = 0; S < this.reso[0] - 1; ++S)
(this.y = g.y + A * this.min_acc), this.fetchAndTriangulate(S, A, w, g);
Math.round((100 * w) / this.reso[2]) > b &&
((b = Math.round((100 * w) / this.reso[2])), this.progress(b));
}
t && (this.blobtree.untrim(l, u), this.blobtree.prepareForEval());
var T = new Date();
return (
console.log("Sliding Marching Cubes computed in " + (T - i) + "ms"),
(this.values_xy[0] = null),
(this.values_xy[1] = null),
(this.vertices_xy[0] = null),
(this.vertices_xy[1] = null),
this.progress(100),
this.buildResultingBufferGeometry()
);
}),
(Kt.prototype.fetchAndTriangulate = function(t, e, i, r) {
var s = e * this.reso[0] + t,
o = (e + 1) * this.reso[0] + t;
(this.values[0] = this.values_xy[0][s]),
(this.values[1] = this.values_xy[1][s]),
(this.values[2] = this.values_xy[0][o]),
(this.values[3] = this.values_xy[1][o]),
(this.values[4] = this.values_xy[0][s + 1]),
(this.values[5] = this.values_xy[1][s + 1]),
(this.values[6] = this.values_xy[0][o + 1]),
(this.values[7] = this.values_xy[1][o + 1]),
this.computeMask(),
0 !== this.mask &&
255 !== this.mask &&
((this.x = r.x + t * this.min_acc),
this.computeVertex(),
this.geometry.addVertex({
p: this.vertex,
n: this.vertex_n,
c: this.vertex_m.getColor(),
r: this.vertex_m.getRoughness(),
m: this.vertex_m.getMetalness()
}),
(this.vertices_xy[1][s] = this.geometry.nVertices - 1),
this.triangulate(t, e, i));
}),
(Kt.prototype.pushDirectFaces = function(t, e, i, r) {
this.geometry.addFace(t, e, i), this.geometry.addFace(i, r, t);
}),
(Kt.prototype.pushUndirectFaces = function(t, e, i, r) {
this.geometry.addFace(i, e, t), this.geometry.addFace(t, r, i);
}),
(Kt.prototype.triangulate = function(t, e, i) {
var r = e * this.reso[0] + t;
if (this.edge_cross[0] && 0 !== e && 0 !== i) {
var s = this.vertices_xy[1][r],
o = this.vertices_xy[1][(e - 1) * this.reso[0] + t],
n = this.vertices_xy[0][(e - 1) * this.reso[0] + t],
h = this.vertices_xy[0][r];
1 & this.mask
? this.pushDirectFaces(s, o, n, h)
: this.pushUndirectFaces(s, o, n, h);
}
if (this.edge_cross[4] && 0 !== t && 0 !== i) {
(s = this.vertices_xy[1][r]),
(o = this.vertices_xy[0][r]),
(n = this.vertices_xy[0][r - 1]),
(h = this.vertices_xy[1][r - 1]);
1 & this.mask
? this.pushDirectFaces(s, o, n, h)
: this.pushUndirectFaces(s, o, n, h);
}
if (this.edge_cross[8] && 0 !== t && 0 !== e) {
(s = this.vertices_xy[1][r]),
(o = this.vertices_xy[1][r - 1]),
(n = this.vertices_xy[1][(e - 1) * this.reso[0] + t - 1]),
(h = this.vertices_xy[1][(e - 1) * this.reso[0] + t]);
1 & this.mask
? this.pushDirectFaces(s, o, n, h)
: this.pushUndirectFaces(s, o, n, h);
}
}),
(Kt.prototype.computeVertex = (function() {
var t = {v: null, g: new It.Vector3(0, 0, 0), m: new v()},
e = new It.Vector3();
return function() {
t.v = this.blobtree.getNeutralValue();
var i = 0;
this.vertex.set(0, 0, 0);
for (var r = 0; r < 12; ++r) {
var s = jt.EdgeVMap[r][0],
o = jt.EdgeVMap[r][1],
n = jt.VertexTopo[s],
h = jt.VertexTopo[o],
a = this.values[s],
c = this.values[o];
if (
((this.edge_cross[r] =
a > this.blobtree.getIsoValue() != c > this.blobtree.getIsoValue()),
this.edge_cross[r])
) {
++i;
var p = c - a,
l = 0;
Math.abs(p) > 1e-6 &&
((l = (this.blobtree.getIsoValue() - a) / p),
(this.vertex.x += (1 - l) * n[0] + l * h[0]),
(this.vertex.y += (1 - l) * n[1] + l * h[1]),
(this.vertex.z += (1 - l) * n[2] + l * h[2]));
}
}
(this.vertex.x = this.x + (this.curr_steps.x * this.vertex.x) / i),
(this.vertex.y = this.y + (this.curr_steps.y * this.vertex.y) / i),
(this.vertex.z = this.z + (this.curr_steps.z * this.vertex.z) / i),
this.convergence &&
(m.safeNewton3D(
this.blobtree,
this.vertex,
this.blobtree.getIsoValue(),
this.min_acc * this.convergence.ratio,
this.convergence.step,
this.min_acc,
e
),
this.vertex.copy(e)),
this.blobtree.value(this.vertex, t),
t.g.normalize(),
this.vertex_n.copy(t.g).multiplyScalar(-1),
this.vertex_m.copy(t.m);
};
})()),
(Kt.prototype.computeMask = function() {
this.mask = 0;
for (var t = 0; t < 8; ++t) {
var e = this.values[t];
this.mask |= e > this.blobtree.getIsoValue() ? 1 << t : 0;
}
});
var Ut = Kt,
Xt = function(e) {
if ((l.call(this), e)) {
var i = this;
e.forEach(function(t) {
i.addChild(t);
});
}
(this.tmp_res = {v: 0, g: null, m: null}),
(this.tmp_g = new t.Vector3()),
(this.tmp_m = new v());
};
((Xt.prototype = Object.create(l.prototype)).constructor = Xt),
(Xt.type = "MaxNode"),
o.register(Xt.type, Xt),
(Xt.prototype.getType = function() {
return Xt.type;
}),
(Xt.fromJSON = function(t) {
for (var e = new Xt(), i = 0; i < t.children.length; ++i)
e.addChild(o.fromJSON(t.children[i]));
return e;
}),
(Xt.prototype.prepareForEval = function() {
if (!this.valid_aabb) {
this.aabb = new t.Box3();
for (var e = 0; e < this.children.length; ++e) {
var i = this.children[e];
i.prepareForEval(), this.aabb.union(i.getAABB());
}
this.valid_aabb = !0;
}
}),
(Xt.prototype.value = function(t, e) {
var i = this.children.length,
r = this.tmp_res;
if (
((r.g = e.g ? this.tmp_g : null),
(r.m = e.m ? this.tmp_m : null),
(e.v = 0),
e.m && e.m.copy(v.defaultMaterial),
e.g ? e.g.set(0, 0, 0) : void 0 !== e.step && (e.step = 1e9),
this.aabb.containsPoint(t) && 0 !== i)
) {
e.v = Number.MAX_VALUE;
for (var s = 0; s < i; ++s) {
if (
(this.children[s].value(t, r),
r.v > e.v &&
((e.v = r.v),
e.g && e.g.copy(r.g),
e.m && e.m.copy(r.m),
e.step || e.stepOrtho))
)
throw "Not implemented";
e.v = Math.max(e.v, r.v);
}
} else if (e.steo || e.stepOrtho) throw "Not implemented";
});
var Lt = Xt,
Wt = function(t, e) {
e = e || {};
(this.blobtree = t),
(this.uniformRes = e.uniformRes || !1),
(this.min_acc = null),
(this.minAccs = []),
(this.subPolygonizer = e.subPolygonizer
? e.subPolygonizer
: {class: Ut, detailRatio: 1}),
(this.ricciThreshold = e.ricciThreshold || 64),
(this.progress = e.progress ? e.progress : function(t) {}),
(this.subtrees = []),
(this.progCoeff = []),
(this.totalCoeff = 0),
this.setBlobtree(t);
};
(Wt.prototype.constructor = Wt),
(Wt.prototype.setBlobtree = function(t) {
(this.blobtree = t), this.blobtree.prepareForEval();
var e = function(t) {
for (
var e = t.getAreas(), i = 0 !== e.length ? e[0].bv.getMinAcc() : null, r = 0;
r < e.length;
++r
)
e[r].bv.getMinAcc() < i && (i = e[r].bv.getMinAcc());
return i;
};
(this.min_acc = e(this.blobtree)),
(this.subtrees = []),
(this.progCoeff = []),
(this.totalCoeff = 0);
var i = this,
r = function(t) {
var r = null;
t instanceof B ? (r = t.clone()) : (r = new B()).addChild(t.clone()),
i.subtrees.push(r),
r.prepareForEval(),
i.minAccs.push(e(r)),
i.progCoeff.push(r.count(W) + r.count(rt) + r.count(_t)),
(i.totalCoeff += i.progCoeff[i.progCoeff.length - 1]);
},
s = function(t) {
if (t instanceof S)
if (t.getRicciN() < i.ricciThreshold) 0 !== t.children.length && r(t);
else for (var e = 0; e < t.children.length; ++e) s(t.children[e]);
else if (t instanceof Lt)
for (e = 0; e < t.children.length; ++e) s(t.children[e]);
else r(t);
};
s(this.blobtree);
}),
(Wt.prototype.compute = function() {
this.blobtree.isValidAABB() || this.setBlobtree(this.blobtree);
var e = this;
this.progress(0);
for (var i = 0, r = [], s = 0; s < this.subtrees.length; ++s) {
var o = this.subPolygonizer.detailRatio || 1;
this.uniformRes &&
this.min_acc &&
(this.subPolygonizer.detailRatio = (o * this.min_acc) / this.minAccs[s]),
(this.subPolygonizer.progress = function(t) {
e.progress((100 * (i + (t / 100) * e.progCoeff[s])) / e.totalCoeff);
});
var n = new this.subPolygonizer.class(this.subtrees[s], this.subPolygonizer);
r.push(n.compute()),
(this.subPolygonizer.detailRatio = o),
(i += this.progCoeff[s]);
}
var h = t.BufferGeometryUtils.mergeBufferGeometries(r);
return this.progress(100), h;
});
var Zt = Wt,
Yt = function(t, e) {
if ((Ut.call(this, t, e), !e.metaBlobtree))
throw "Error : SplitSMC needs a meta blobtree in params (from which normals will be computed).";
(this.metaBlobtree = e.metaBlobtree), this.metaBlobtree.prepareForEval();
};
((Yt.prototype = Object.create(Ut.prototype)).constructor = Yt),
(Yt.prototype.computeVertex = (function() {
var e = {v: null, g: new t.Vector3(0, 0, 0), m: new v()},
i = new t.Vector3();
return function() {
e.v = this.blobtree.getNeutralValue();
var t = 0;
this.vertex.set(0, 0, 0);
for (var r = 0; r < 12; ++r) {
var s = jt.EdgeVMap[r][0],
o = jt.EdgeVMap[r][1],
n = jt.VertexTopo[s],
h = jt.VertexTopo[o],
a = this.values[s],
c = this.values[o];
if (
((this.edge_cross[r] =
a > this.blobtree.getIsoValue() != c > this.blobtree.getIsoValue()),
this.edge_cross[r])
) {
++t;
var p = c - a,
l = 0;
Math.abs(p) > 1e-6 &&
((l = (this.blobtree.getIsoValue() - a) / p),
(this.vertex.x += (1 - l) * n[0] + l * h[0]),
(this.vertex.y += (1 - l) * n[1] + l * h[1]),
(this.vertex.z += (1 - l) * n[2] + l * h[2]));
}
}
(this.vertex.x = this.x + (this.curr_steps.x * this.vertex.x) / t),
(this.vertex.y = this.y + (this.curr_steps.y * this.vertex.y) / t),
(this.vertex.z = this.z + (this.curr_steps.z * this.vertex.z) / t),
this.convergence &&
(m.safeNewton3D(
this.blobtree,
this.vertex,
this.blobtree.getIsoValue(),
this.min_acc * this.convergence.ratio,
this.convergence.step,
this.min_acc,
i
),
this.vertex.copy(i)),
this.metaBlobtree.value(this.vertex, e),
e.g.normalize(),
this.vertex_n.copy(e.g).multiplyScalar(-1),
this.vertex_m.copy(e.m);
};
})());
var $t,
Qt = Yt;
($t = r) && $t.default,
"122" !== t.REVISION &&
console.warn(
"Blobtree library is currently made for THREE revision 122. Using any other revision may lead to unexpected behavior."
);
var te = {version: "1.0.0"};
return (
(te.Types = o),
(te.Element = a),
(te.Node = l),
(te.RootNode = B),
(te.RicciNode = S),
(te.DifferenceNode = E),
(te.MinNode = k),
(te.MaxNode = k),
(te.Primitive = F),
(te.ScalisMath = D),
(te.ScalisPrimitive = O),
(te.ScalisPoint = W),
(te.ScalisSegment = rt),
(te.ScalisTriangle = _t),
(te.ScalisVertex = C),
(te.DistanceFunctor = ft),
(te.Poly6DistanceFunctor = bt),
(te.SDFRootNode = St),
(te.SDFPrimitive = Bt),
(te.SDFPoint = Et),
(te.SDFSegment = Ft),
(te.SDFSphere = Dt),
(te.SDFCapsule = Ot),
(te.Material = v),
(te.Accuracies = K),
(te.Area = G),
(te.AreaScalisSeg = et),
(te.AreaScalisTri = gt),
(te.AreaSphere = X),
(te.AreaCapsule = kt),
(te.SlidingMarchingCubes = Ut),
(te.SplitMaxPolygonizer = Zt),
(te.SplitSMC = Qt),
(t.Blobtree = te),
te
);
});
