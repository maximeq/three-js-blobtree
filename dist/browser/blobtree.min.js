!(function(t, e) {
"object" == typeof exports && "undefined" != typeof module
? (module.exports = e(require("three")))
: "function" == typeof define && define.amd
? define(["three"], e)
: (t.Blobtree = e(t.THREE));
})(this, function(t) {
"use strict";
(t = t && t.hasOwnProperty("default") ? t.default : t),
(function(e, i, s) {
if (void 0 === t[e])
throw `THREE is missing example '${e}' and, as such, webgl-modelers-plugin-blobtree can't work properly. You can find it` +
` in 'three/examples/js/${void 0 !== i ? i + "/" : ""}${s || e}.js'`;
})("BufferGeometryUtils", "utils");
var e,
i,
s = {
types: {},
register: function(t, e) {
if (this.types[t])
throw "Error : cannot register type " +
t +
", this name is already registered.";
this.types[t] = e;
},
fromJSON: function(t) {
var e = this.types[t.type];
if (!e)
throw "Error : type found in JSON (" +
t.type +
" is not registered in the Blobtree library.";
return e.fromJSON(t);
}
},
r = s,
o = 0,
n = function() {
(this.id = o++),
(this.aabb = new t.Box3()),
(this.valid_aabb = !1),
(this.parentNode = null);
};
(n.prototype.constructor = n),
(n.type = "Element"),
r.register(n.type, n),
(n.prototype.toJSON = function() {
return {type: this.getType()};
}),
(n.prototype.clone = function() {
return r.fromJSON(this.toJSON());
}),
(n.prototype.getParentNode = function() {
return this.parentNode;
}),
(n.prototype.getType = function() {
return n.type;
}),
(n.prototype.computeHelpVariables = function() {
this.computeAABB();
}),
(n.prototype.computeAABB = function() {
throw "Error : computeAABB is abstract, should have been overwritten";
}),
(n.prototype.getAABB = function() {
return this.aabb;
}),
(n.prototype.isValidAABB = function() {
return this.valid_aabb;
}),
(n.prototype.invalidAABB = function() {
(this.valid_aabb = !1),
null !== this.parentNode &&
this.parentNode.isValidAABB() &&
this.parentNode.invalidAABB();
}),
(n.prototype.invalidAll = function() {
this.invalidAABB();
}),
(n.prototype.prepareForEval = function() {
throw "ERROR : prepareForEval is a virtual function, should be re-implemented in all element(error occured in Element.js";
}),
(n.prototype.value = function(t, e) {
throw "ERROR : value is an abstract function, should be re-implemented in all primitives(error occured in " +
this.getType() +
" primitive)";
}),
(n.prototype.numericalGradient =
((e = {v: 0}),
(i = ["x", "y", "z"]),
function(t, s, r) {
for (var o = r || 1e-5, n = 0; n < 3; ++n)
(t[i[n]] = t[i[n]] + o),
this.value(t, e),
(s[i[n]] = e.v),
(t[i[n]] = t[i[n]] - 2 * o),
this.value(t, e),
(s[i[n]] = (s[i[n]] - e.v) / (2 * o)),
(t[i[n]] = t[i[n]] + o);
})),
(n.prototype.getAreas = function() {
return [];
}),
(n.prototype.distanceTo = function(t) {
throw "ERROR : distanceTo is a virtual function, should be re-implemented in all primitives(error occured in " +
this.getType() +
" primitive)";
}),
(n.prototype.heuristicStepWithin = function() {
throw "ERROR : heuristicStepWithin is a virtual function, should be re-implemented in all primitives(error occured in " +
this.getType() +
" primitive)";
}),
(n.prototype.trim = function(t, e, i) {}),
(n.prototype.count = function(t) {
return 0;
});
var h = n,
a = function() {
h.call(this), (this.children = []);
};
((a.prototype = Object.create(h.prototype)).constructor = a),
(a.type = "Node"),
r.register(a.type, a),
(a.prototype.getType = function() {
return a.type;
}),
(a.prototype.toJSON = function() {
var t = h.prototype.toJSON.call(this);
t.children = [];
for (var e = 0; e < this.children.length; ++e)
t.children.push(this.children[e].toJSON());
return t;
}),
(a.prototype.clone = function() {
return r.fromJSON(this.toJSON());
}),
(a.prototype.prepareForEval = function() {
console.error(
"prepareForEval is a pure virtual function, should be reimplemented in every node class"
);
}),
(a.prototype.invalidAll = function() {
if ((this.invalidAABB(), this.children))
for (var t = 0; t < this.children.length; t++) this.children[t].invalidAll();
}),
(a.prototype.destroy = function() {
for (
var t = this.children.slice(0, this.children.length), e = 0;
e < t.length;
e++
)
t[e].destroy();
if (0 !== this.children.length) throw "Error : children length should be 0";
if (
(null !== this.parentNode && this.parentNode.removeChild(this),
null !== this.parentNode)
)
throw "Error : parent node should be null at this point";
this.children.length = 0;
}),
(a.prototype.addChild = function(t) {
null !== t.parentNode && t.parentNode.removeChild(t),
this.children.push(t),
(t.parentNode = this),
this.invalidAABB();
}),
(a.prototype.removeChild = function(t) {
for (var e = 0, i = this.children; i[e] !== t && e < i.length; ) ++e;
if (e == i.length) throw "c does not belong to the children of this node";
(i[e] = i[i.length - 1]), i.pop(), this.invalidAABB(), (t.parentNode = null);
}),
(a.prototype.computeAABB = function() {
this.aabb.makeEmpty();
for (var t = 0; t < this.children.length; t++)
this.children[t].computeAABB(), this.aabb.union(this.children[t].getAABB());
}),
(a.prototype.getAreas = function() {
if (!this.valid_aabb)
throw "Error : cannot call getAreas on a not prepared for eval nod, please call PrepareForEval first. Node concerned is a " +
this.getType();
for (var t = [], e = 0; e < this.children.length; e++)
t.push.apply(t, this.children[e].getAreas());
return t;
}),
(a.prototype.distanceTo = function(t) {
for (var e = 1e7, i = 0; i < this.children.length; i++)
e = Math.min(e, this.children[i].distanceTo(t));
return e;
}),
(a.prototype.heuristicStepWithin = function() {
for (var t = 1e7, e = 0; e < this.children.length; e++)
t = Math.min(t, this.children[e].heuristicStepWithin());
return t;
}),
(a.prototype.trim = function(t, e, i) {
for (var s = e.length, r = 0; r < this.children.length; r++)
this.children[r].getAABB().intersectsBox(t) ||
(e.push(this.children[r]), i.push(this));
for (r = s; r < e.length; ++r) this.removeChild(e[r]);
for (r = 0; r < this.children.length; r++) this.children[r].trim(t, e, i);
}),
(a.prototype.count = function(t) {
var e = 0;
this instanceof t && e++;
for (var i = 0; i < this.children.length; i++) e += this.children[i].count(t);
return e;
});
var p = a,
l = {};
(l.last_mov_pt = new t.Vector3()),
(l.grad = new t.Vector3()),
(l.eval_res_g = new t.Vector3(0, 0, 0)),
(l.eval_res = {v: 0, g: null}),
(l.vec = new t.Vector3()),
(l.safeNewton3D = function(t, e, i, s, r, o, n) {
n.copy(e);
for (var h = 1, a = 0, c = !1; 2 != a && h <= r && !c; ) {
if (
(this.last_mov_pt.copy(n),
(this.eval_res.g = this.eval_res_g),
t.value(n, this.eval_res),
this.grad.copy(this.eval_res.g),
0 !== this.grad.x || 0 !== this.grad.y || 0 !== this.grad.z)
) {
var p = this.grad.length(),
l = (i - this.eval_res.v) / p;
if (
(l < s && l > -s ? ((l = l > 0 ? s / p : -s / p), a++) : (a = 0),
this.grad.normalize().multiplyScalar(l),
n.add(this.grad),
this.vec.subVectors(n, e).lengthSq() > o * o)
)
return void n.copy(e);
} else c = !0;
++h;
}
c && n.copy(e);
}),
(l.safeNewton1D = function(e, i, s, r, o, n, h, a, c, p) {
if (((this.eval_res.g = this.eval_res_g), 0 === s.x && 0 === s.y && 0 === s.z))
throw "Error : search direction is null";
if (a <= 0)
throw "Error: epsilon <= 0, convergence will nuke your face or loop";
if (n < r || n > o) throw "Error : starting absc is not in boundaries";
for (var l = n, u = new t.Vector3(), v = 0, m = 0; o - r > a && m < c; )
e.value(
u
.copy(s)
.multiplyScalar(l)
.add(i),
this.eval_res
),
this.eval_res.v > h ? (r = l) : (o = l),
0 !== (v = this.eval_res.g.dot(s))
? ((l += (h - this.eval_res.v) / v) >= o || l <= r) && (l = 0.5 * (o + r))
: (l = 0.5 * (o + r)),
++m;
(p.p_absc = 0.5 * (o + r)),
p.p
.copy(s)
.multiplyScalar(l)
.add(i),
void 0 !== p.g &&
(0 === m && e.value(p.p, this.eval_res), p.g.copy(this.eval_res.g));
}),
(l.dichotomy1D = function(e, i, s, r, o, n, h, a) {
this.eval_res.g = null;
var c = new t.Vector3().copy(i),
p = new t.Vector3(),
l = -(r /= 2),
u = l;
i.sub(p.copy(s).multiplyScalar(r));
for (var v = 0; r > n && v < h; )
v++,
c.copy(i),
(u = l),
(r /= 2),
e.value(i, this.eval_res),
this.eval_res.v < o
? (i.add(p.copy(s).multiplyScalar(r)), (l += r))
: (i.sub(p.copy(s).multiplyScalar(r)), (l -= r));
a.p.copy(i.add(c).divideScalar(2)),
(a.p_absc = (u + l) / 2),
a.p.copy(i),
(a.p_absc = l),
a.g &&
((this.eval_res.g = this.eval_res_g),
e.value(a.p, this.eval_res),
a.g.copy(this.eval_res.g));
});
var u = l,
v = function(e) {
if (((e = e || {}), void 0 !== arguments[1]))
throw "Error : Blobtree Material now takes only 1 argument.";
(this.color = new t.Color(void 0 !== e.color ? e.color : 11184810)),
(this.roughness = void 0 !== e.roughness ? e.roughness : 0),
(this.metalness = void 0 !== e.metalness ? e.metalness : 0),
(this.emissive = new t.Color(void 0 !== e.emissive ? e.emissive : 0));
};
(v.prototype.toJSON = function() {
return {
color: "#" + this.color.getHexString(),
roughness: this.roughness,
metalness: this.metalness,
emissive: `#${this.emissive.getHexString()}`
};
}),
(v.fromJSON = function(e) {
return new v({
color: new t.Color(e.color),
roughness: e.roughness,
metalness: e.metalness,
emissive: e.emissive
});
}),
(v.prototype.clone = function() {
return new v({
color: this.color,
roughness: this.roughness,
metalness: this.metalness,
emissive: this.emissive
});
}),
(v.prototype.copy = function(t) {
this.color.copy(t.color),
(this.roughness = t.roughness),
(this.metalness = t.metalness),
this.emissive.copy(t.emissive);
}),
(v.prototype.set = function(t, e, i) {
this.color.copy(t), (this.roughness = e), (this.metalness = i);
}),
(v.prototype.setParams = function(t) {
this.color.copy(t.color ? t.color : this.color),
(this.roughness = void 0 !== t.roughness ? t.roughness : this.roughness),
(this.metalness = void 0 !== t.metalness ? t.metalness : this.metalness),
this.emissive.copy(void 0 !== t.emissive ? t.emissive : this.emissive);
}),
(v.prototype.getColor = function() {
return this.color;
}),
(v.prototype.getRoughness = function() {
return this.roughness;
}),
(v.prototype.getMetalness = function() {
return this.metalness;
}),
(v.prototype.getEmissive = function() {
return this.emissive;
}),
(v.prototype.equals = function(t) {
return (
this.color.equals(t.color) &&
this.metalness === t.metalness &&
this.roughness === t.roughness &&
this.emissive.equals(t.emissive)
);
}),
(v.prototype.lerp = function(t, e) {
this.color.lerp(t.color, e),
(this.roughness = (1 - e) * this.roughness + e * t.roughness),
(this.metalness = (1 - e) * this.metalness + e * t.metalness),
this.emissive.lerp(t.emissive, e);
}),
(v.prototype.triMean = function(t, e, i, s, r, o, n) {
return (
(this.color.r = (s * t.color.r + r * e.color.r + o * i.color.r) / n),
(this.color.g = (s * t.color.g + r * e.color.g + o * i.color.g) / n),
(this.color.b = (s * t.color.b + r * e.color.b + o * i.color.b) / n),
(this.roughness = (s * t.roughness + r * e.roughness + o * i.roughness) / n),
(this.metalness = (s * t.metalness + r * e.metalness + o * i.metalness) / n),
(this.emissive.r =
(s * t.emissive.r + r * e.emissive.r + o * i.emissive.r) / n),
(this.emissive.g =
(s * t.emissive.g + r * e.emissive.g + o * i.emissive.g) / n),
(this.emissive.b =
(s * t.emissive.b + r * e.emissive.b + o * i.emissive.b) / n),
this
);
}),
(v.prototype.weightedMean = function(t, e, i) {
this.color.setRGB(0, 0, 0),
(this.roughness = 0),
(this.metalness = 0),
this.emissive.setScalar(0);
const s = void 0 === i ? t.length : i;
let r = 0;
for (let i = 0; i < s; ++i)
(this.color.r += e[i] * t[i].color.r),
(this.color.g += e[i] * t[i].color.g),
(this.color.b += e[i] * t[i].color.b),
(this.roughness += e[i] * t[i].roughness),
(this.metalness += e[i] * t[i].metalness),
(this.emissive.r += e[i] * t[i].emissive.r),
(this.emissive.g += e[i] * t[i].emissive.g),
(this.emissive.b += e[i] * t[i].emissive.b),
(r += e[i]);
return (
0 !== r
? ((this.color.r /= r),
  (this.color.g /= r),
  (this.color.b /= r),
  (this.roughness /= r),
  (this.metalness /= r),
  (this.emissive.r /= r),
  (this.emissive.g /= r),
  (this.emissive.b /= r))
: (this.color.setScalar(0),
  (this.roughness = 0),
  (this.metalness = 0),
  this.emissive.setScalar(0)),
this
);
}),
(v.areEqualsArrays = function(t, e, i, s, r) {
console.warn(
"Material.areEqualsArrays is deprecated, please use your own comparison function using Material.equals."
);
for (var o = !0, n = 1; n < arguments.length; n++)
o =
o &&
((null === t && null === arguments[n]) ||
(null !== t && null !== arguments[n]));
if (!o) return o;
if (null === t) return !0;
for (n = 1; n < arguments.length; n++) {
var h = !0;
if (arguments[n].length !== t.length) return !1;
for (var a = 0; a < t.length; ++a) h = h && t[a].equals(arguments[n][a]);
o = o && h;
}
return o;
}),
(v.defaultMaterial = new v());
var m = v,
g = function(e, i) {
if ((p.call(this), (this.ricci_n = e), i)) {
var s = this;
i.forEach(function(t) {
s.addChild(t);
});
}
(this.tmp_v_arr = new Float32Array(0)),
(this.tmp_m_arr = new Array(0)),
(this.tmp_res = {v: 0, g: null, m: null}),
(this.tmp_g = new t.Vector3()),
(this.tmp_m = new m());
};
((g.prototype = Object.create(p.prototype)).constructor = g),
(g.type = "RicciNode"),
r.register(g.type, g),
(g.prototype.getType = function() {
return g.type;
}),
(g.prototype.toJSON = function() {
var t = p.prototype.toJSON.call(this);
return (t.ricci = this.ricci_n), t;
}),
(g.fromJSON = function(t) {
for (var e = new g(t.ricci), i = 0; i < t.children.length; ++i)
e.addChild(r.fromJSON(t.children[i]));
return e;
}),
(g.prototype.prepareForEval = function() {
if (!this.valid_aabb) {
this.aabb = new t.Box3();
for (var e = 0; e < this.children.length; ++e) {
var i = this.children[e];
i.prepareForEval(), this.aabb.union(i.getAABB());
}
if (((this.valid_aabb = !0), this.tmp_v_arr.length < this.children.length)) {
(this.tmp_v_arr = new Float32Array(2 * this.children.length)),
(this.tmp_m_arr.length = 2 * this.children.length);
for (e = 0; e < this.tmp_m_arr.length; ++e)
this.tmp_m_arr[e] = new m({roughness: 0, metalness: 0});
}
}
}),
(g.prototype.value = function(t, e) {
var i = this.children.length,
s = this.tmp_res;
if (
((s.g = e.g ? this.tmp_g : null),
(s.m = e.m ? this.tmp_m : null),
(e.v = 0),
e.m && e.m.copy(m.defaultMaterial),
e.g ? e.g.set(0, 0, 0) : void 0 !== e.step && (e.step = 1e9),
this.aabb.containsPoint(t) && 0 !== i)
) {
for (
var r = this.tmp_v_arr, o = this.tmp_m_arr, n = 0, h = 0, a = 0;
a < i;
++a
)
if (this.children[a].aabb.containsPoint(t))
if ((this.children[a].value(t, s), s.v > 0)) {
var c = Math.pow(s.v, this.ricci_n - 1);
(h += s.v * c),
e.g && (s.g.multiplyScalar(c), e.g.add(s.g)),
e.m && ((r[n] = s.v * c), o[n].copy(s.m), n++),
(e.step || e.stepOrtho) &&
(e.step = Math.min(e.step, this.children[a].heuristicStepWithin()));
} else
void 0 !== e.step &&
(e.step = Math.min(e.step, this.children[a].distanceTo(t)));
else
(e.step || e.stepOrtho) &&
(e.step = Math.min(e.step, this.children[a].distanceTo(t)));
(e.v = Math.pow(h, 1 / this.ricci_n)),
0 !== e.v &&
(e.g && e.g.multiplyScalar(e.v / h), e.m && e.m.weightedMean(o, r, n));
} else if (void 0 !== e.step && 0 !== this.children.length) {
var p = this.children[0].heuristicStepWithin();
for (a = 1; a < this.children.length; ++a)
p = Math.min(p, this.children[a].heuristicStepWithin());
e.step = this.aabb.distanceToPoint(t) + p;
}
void 0 !== e.stepOrtho && (e.stepOrtho = e.step);
}),
(g.prototype.setRicciN = function(t) {
this.ricci_n != t && ((this.ricci_n = t), this.invalidAABB());
}),
(g.prototype.getRicciN = function() {
return this.ricci_n;
});
var _,
y,
d,
f,
b,
w,
x,
V,
A = g,
S = function() {
A.call(this, 64),
(this.valid_aabb = !0),
(this.iso_value = 1),
(this.trimmed = []),
(this.trim_parents = []);
};
((S.prototype = Object.create(A.prototype)).constructor = S),
(S.type = "RootNode"),
r.register(S.type, S),
(S.prototype.getType = function() {
return S.type;
}),
(S.prototype.toJSON = function() {
var t = A.prototype.toJSON.call(this);
return (t.iso = this.iso_value), t;
}),
(S.fromJSON = function(t) {
for (var e = new S(t.ricci), i = 0; i < t.children.length; ++i)
e.addChild(r.fromJSON(t.children[i]));
return e;
}),
(S.prototype.getIsoValue = function() {
return this.iso_value;
}),
(S.prototype.setIsoValue = function(t) {
this.iso_value = t;
}),
(S.prototype.getNeutralValue = function() {
return 0;
}),
(S.prototype.invalidAABB = function() {
this.valid_aabb = !1;
}),
(S.prototype.internalTrim = function(t) {
if (0 !== this.trimmed.length || 0 !== this.trim_parents.length)
throw "Error : you should not call internal trim if you have not untrimmed before. Call untrim or use externalTrim";
this.trim(t, this.trimmed, this.trim_parents);
}),
(S.prototype.externalTrim = function(t, e, i) {
this.trim(t, e, i);
}),
(S.prototype.internalUntrim = function() {
this.untrim(this.trimmed, this.trim_parents),
(this.trimmed.length = 0),
(this.trim_parents.length = 0);
}),
(S.prototype.untrim = function(t, e) {
if (t.length !== e.length)
throw "Error : trimmed and parents arrays should have the same length";
for (var i = 0; i < t.length; ++i) e[i].addChild(t[i]);
}),
(S.prototype.isEmpty = function() {
return 0 == this.children.length;
}),
(S.prototype.intersectRayBlob =
((_ = new t.Vector3()),
(y = new t.Vector3()),
(d = new t.Vector3()),
(f = {v: 0, g: new t.Vector3(), step: 0}),
(b = {p: new t.Vector3(), g: new t.Vector3(), p_absc: 0}),
(w = 0),
(x = 0),
(V = 0),
function(t, e, i, s) {
for (
_.copy(t.origin),
y.copy(t.direction),
y.normalize(),
V = 0,
f.g = null,
this.value(_, f);
f.v < this.iso_value && V < i;

)
_.add(d.copy(y).multiplyScalar(f.step)),
(V += f.step),
(w = f.step),
(x = f.v),
this.value(_, f);
return (
f.v >= this.iso_value &&
(u.safeNewton1D(
this,
_,
y.multiplyScalar(-1),
0,
w,
(w * (this.iso_value - f.v)) / (x - f.v),
this.iso_value,
w / 512,
10,
b
),
(e.distance = V - b.p_absc),
(e.point = b.p.clone()),
e.g && e.g.copy(b.g),
!0)
);
})),
(S.prototype.intersectOrthoRayBlob = (function() {
var e = new t.Vector3(),
i = new t.Vector3(),
s = {step: 0},
r = new t.Vector3(),
o = {},
n = 0,
h = 0,
a = -1;
return function(t, c, p, l) {
for (
l.axis.z
? e.set(this.aabb.min.x + t, this.aabb.min.y + c, this.aabb.min.z + 1e-7)
: l.axis.y
? e.set(this.aabb.min.x + t, this.aabb.min.y + 1e-7, this.aabb.min.z + c)
: l.axis.z &&
  e.set(this.aabb.min.x + 1e-7, this.aabb.min.y + t, this.aabb.min.z + c),
s.step = l.get(this.aabb.max) - l.get(this.aabb.min),
this.value(e, s),
n = 1e-7,
a = -1;
l.get(e) < l.get(this.aabb.max);

) {
for (; (s.v - 1) * a >= 0 && l.get(e) < l.get(this.aabb.max); )
l.add(e, s.step),
(n = s.step),
(s.step = l.get(this.aabb.max) - l.get(e)),
this.value(e, s);
if (l.get(e) < l.get(this.aabb.max)) {
for (
a *= -1, i.copy(e), h = l.get(e), n /= 2, l.add(e, -n), o.g = null;
n > 0.1;

)
(h = l.get(e)),
(n /= 2),
this.value(e, o),
(o.v - 1) * a < 0 ? l.add(e, n) : l.add(e, -n);
l.add(e, h),
l.divide(e, 2),
(o.g = r),
this.value(e, o),
p.push({point: e.clone(), gradient: o.g.clone()}),
e.copy(i);
}
}
};
})());
var M = S,
T = function(e, i, s) {
p.call(this),
this.addChild(e),
this.addChild(i),
(this.alpha = s || 1),
(this.clamped = 0),
(this.tmp_res0 = {v: 0, g: new t.Vector3(0, 0, 0), m: new m()}),
(this.tmp_res1 = {v: 0, g: new t.Vector3(0, 0, 0), m: new m()}),
(this.g0 = new t.Vector3()),
(this.m0 = new m()),
(this.g1 = new t.Vector3()),
(this.m1 = new m()),
(this.tmp_v_arr = new Float32Array(2)),
(this.tmp_m_arr = [null, null]);
};
((T.prototype = Object.create(p.prototype)).constructor = T),
(T.type = "DifferenceNode"),
r.register(T.type, T),
(T.prototype.getAlpha = function() {
return this.alpha;
}),
(T.prototype.setAlpha = function(t) {
this.alpha != t && ((this.alpha = t), this.invalidAABB());
}),
(T.prototype.toJSON = function() {
var t = p.prototype.toJSON.call(this);
return (t.alpha = this.alpha), t;
}),
(T.fromJSON = function(t) {
var e = new T();
return (
(this.children[0] = r.fromJSON(t.children[0])),
(this.children[1] = r.fromJSON(t.children[1])),
e
);
}),
(T.prototype.prepareForEval = function() {
this.valid_aabb ||
(this.children[0].prepareForEval(),
this.children[1].prepareForEval(),
this.aabb.copy(this.children[0].getAABB()),
(this.valid_aabb = !0));
}),
(T.prototype.value = function(t, e) {
this.children.length;
var i = this.tmp_v_arr,
s = this.tmp_m_arr,
r = this.tmp_res0,
o = this.tmp_res1;
if (
((r.g = e.g ? this.g0 : null),
(r.m = e.m ? this.m0 : null),
(o.g = e.g ? this.g1 : null),
(o.m = e.m ? this.m1 : null),
(e.v = 0),
(o.v = 0),
(r.v = 0),
e.m &&
(e.m.copy(m.defaultMaterial),
o.m.copy(m.defaultMaterial),
r.m.copy(m.defaultMaterial)),
e.g
? (e.g.set(0, 0, 0), o.g.set(0, 0, 0), r.g.set(0, 0, 0))
: void 0 !== e.step && (e.step = 1e9),
this.aabb.containsPoint(t))
) {
if (this.children[0].aabb.containsPoint(t))
if (
(this.children[0].value(t, r),
this.children[1].aabb.containsPoint(t) && this.children[1].value(t, o),
0 === o.v)
)
(e.v = r.v), e.g && e.g.copy(r.g), e.m && e.m.copy(r.m);
else {
var n = Math.pow(o.v, this.alpha);
(e.v = Math.max(this.clamped, r.v - o.v * Math.pow(o.v, this.alpha - 1))),
e.g &&
(e.v === this.clamped
? e.g.set(0, 0, 0)
: (o.g.multiplyScalar(n), e.g.subVectors(r.g, o.g))),
e.m &&
((i[0] = r.v),
(i[1] = o.v),
(s[0] = r.m),
(s[1] = o.m),
e.m.weightedMean(s, i, 2));
}
} else void 0 !== e.step && (e.step = this.aabb.distanceToPoint(t) + 0.3);
}),
(T.prototype.trim = function(t, e, i) {
for (var s = 0; s < this.children.length; s++) this.children[s].trim(t, e, i);
});
var B = T,
P = function(e) {
if ((p.call(this), e)) {
var i = this;
e.forEach(function(t) {
i.addChild(t);
});
}
(this.tmp_res = {v: 0, g: null, m: null}),
(this.tmp_g = new t.Vector3()),
(this.tmp_m = new m());
};
((P.prototype = Object.create(p.prototype)).constructor = P),
(P.type = "MinNode"),
r.register(P.type, P),
(P.prototype.getType = function() {
return P.type;
}),
(P.fromJSON = function(t) {
for (var e = new P(), i = 0; i < t.children.length; ++i)
e.addChild(r.fromJSON(t.children[i]));
return e;
}),
(P.prototype.prepareForEval = function() {
if (!this.valid_aabb) {
this.aabb = new t.Box3();
for (var e = 0; e < this.children.length; ++e) {
var i = this.children[e];
i.prepareForEval(), this.aabb.union(i.getAABB());
}
this.valid_aabb = !0;
}
}),
(P.prototype.value = function(t, e) {
var i = this.children.length,
s = this.tmp_res;
if (
((s.g = e.g ? this.tmp_g : null),
(s.m = e.m ? this.tmp_m : null),
(e.v = 0),
e.m && e.m.copy(m.defaultMaterial),
e.g ? e.g.set(0, 0, 0) : void 0 !== e.step && (e.step = 1e9),
this.aabb.containsPoint(t) && 0 !== i)
) {
e.v = Number.MAX_VALUE;
for (var r = 0; r < i; ++r) {
if (
(this.children[r].value(t, s),
s.v < e.v &&
((e.v = s.v),
e.g && e.g.copy(s.g),
e.m && e.m.copy(s.m),
e.step || e.stepOrtho))
)
throw "Not implemented";
e.v = Math.min(e.v, s.v);
}
} else if (e.steo || e.stepOrtho) throw "Not implemented";
}),
(P.prototype.trim = function(t, e, i) {
for (var s = 0; s < this.children.length; s++) this.children[s].trim(t, e, i);
});
var N = P,
k = function() {
h.call(this), (this.materials = []);
};
((k.prototype = Object.create(h.prototype)).constructor = k),
(k.type = "Primitive"),
r.register(k.type, k),
(k.prototype.toJSON = function(t) {
var e = h.prototype.toJSON.call(this);
e.materials = [];
for (var i = 0; i < this.materials.length; ++i)
e.materials.push(this.materials[i].toJSON());
return e;
}),
(k.prototype.setMaterials = function(t) {
if (t.length !== this.materials.length)
throw "Error : trying to set " +
t.length +
" materials on a primitive with only " +
this.materials.length;
for (var e = 0; e < t.length; ++e)
t[e].equals(this.materials[e]) ||
(this.materials[e].copy(t[e]), this.invalidAABB());
}),
(k.prototype.getMaterials = function() {
return this.materials;
}),
(k.prototype.computeAABB = function() {
throw "Primitive.prototype.computeAABB  Must be reimplemented in all inherited class.";
}),
(k.prototype.destroy = function() {
null !== this.parentNode && this.parentNode.removeChild(this);
}),
(k.prototype.getAreas = function() {
throw "ERROR : getAreas is an abstract function, should be re-implemented in all primitives(error occured in " +
this.getType() +
" primitive)";
}),
(k.prototype.computeHelpVariables = function() {
throw "ERROR : computeHelpVariables is a virtual function, should be re-implemented in all primitives(error occured in " +
this.getType() +
" primitive)";
}),
(k.prototype.count = function(t) {
return this instanceof t ? 1 : 0;
});
var F = k,
D = {KS: 2};
(D.KIS = 1 / D.KS),
(D.KS2 = 4),
(D.KIS2 = 1 / (D.KS * D.KS)),
(D.Poly6Eval = function(t) {
var e = 1 - D.KIS2 * t * t;
return e > 0 ? e * e * e : 0;
}),
(D.Poly6EvalSq = function(t) {
var e = 1 - D.KIS2 * t;
return e > 0 ? e * e * e : 0;
}),
(D.GetIsoValueAtDistanceGeom0D = function(t, e, i) {
if (t % 2 != 0) throw "degree should be even";
if (i < e) {
var s = 1 - (i * i) / (e * e);
return Math.pow(s, t / 2);
}
return 0;
}),
(D.Poly4NF0D = 1 / D.GetIsoValueAtDistanceGeom0D(4, D.KS, 1)),
(D.Poly6NF0D = 1 / D.GetIsoValueAtDistanceGeom0D(6, D.KS, 1)),
(D.GetIsoValueAtDistanceGeom1D = function(t, e, i) {
if (t % 2 != 0) throw "degree should be even";
if (i < e) {
for (var s = 1 - (i * i) / (e * e), r = 2 * e * Math.sqrt(s), o = 0; o != t; )
r *= ((o += 2) / (1 + o)) * s;
return r;
}
return 0;
}),
(D.Poly4NF1D = 1 / D.GetIsoValueAtDistanceGeom1D(4, D.KS, 1)),
(D.Poly6NF1D = 1 / D.GetIsoValueAtDistanceGeom1D(6, D.KS, 1)),
(D.GetIsoValueAtDistanceGeom2D = function(t, e, i) {
if (i < e) {
var s = t + 2,
r = 1 - (i * i) / (e * e);
return ((2 * Math.PI) / s) * e * e * Math.pow(r, 0.5 * s);
}
return 0;
}),
(D.Poly4NF2D = 1 / D.GetIsoValueAtDistanceGeom2D(4, D.KS, 1)),
(D.Poly6NF2D = 1 / D.GetIsoValueAtDistanceGeom2D(6, D.KS, 1));
var z = D,
O = function() {
F.call(this), (this.volType = O.DIST), (this.v = []);
};
(O.DIST = "dist"),
(O.CONVOL = "convol"),
(O.prototype = Object.create(F.prototype)),
(O.prototype.constructor = O),
(O.type = "ScalisPrimitive"),
r.register(O.type, O),
(O.prototype.getType = function() {
return O.type;
}),
(O.prototype.toJSON = function() {
var t = F.prototype.toJSON.call(this);
(t.v = []), (t.volType = this.volType);
for (var e = 0; e < this.v.length; ++e) t.v.push(this.v[e].toJSON());
return t;
}),
(O.prototype.mutableVolType = function() {
return !1;
}),
(O.prototype.setVolType = function(t) {
t !== this.volType && ((this.volType = t), this.invalidAABB());
}),
(O.prototype.getVolType = function() {
return this.volType;
}),
(O.prototype.computeAABB = function() {
this.aabb.makeEmpty();
for (var t = 0; t < this.v.length; t++) this.aabb.union(this.v[t].getAABB());
});
var E = O,
q = 0,
j = function(e, i) {
(this.pos = e.clone()),
(this.thickness = i),
(this.id = q++),
(this.prim = null),
(this.aabb = new t.Box3()),
(this.valid_aabb = !1);
};
(j.prototype.setPrimitive = function(t) {
null === this.prim && (this.prim = t);
}),
(j.prototype.toJSON = function() {
return {
position: {x: this.pos.x, y: this.pos.y, z: this.pos.z},
thickness: this.thickness
};
}),
(j.fromJSON = function(e) {
return new j(
new t.Vector3(e.position.x, e.position.y, e.position.z),
e.thickness
);
}),
(j.prototype.setPos = function(t) {
(this.valid_aabb = !1), this.pos.copy(t), this.prim.invalidAABB();
}),
(j.prototype.setThickness = function(t) {
(this.valid_aabb = !1), (this.thickness = t), this.prim.invalidAABB();
}),
(j.prototype.setAll = function(t, e) {
(this.valid_aabb = !1),
(this.pos = t),
(this.thickness = e),
this.prim.invalidAABB();
}),
(j.prototype.getPos = function() {
return this.pos;
}),
(j.prototype.getThickness = function() {
return this.thickness;
}),
(j.prototype.getAABB = function() {
return (
this.valid_aabb || (this.computeAABB(), (this.valid_aabb = !0)), this.aabb
);
}),
(j.prototype.computeAABB = function() {
var e = this.getPos(),
i = this.getThickness() * z.KS;
this.aabb.set(
new t.Vector3(e.x - i, e.y - i, e.z - i),
new t.Vector3(e.x + i, e.y + i, e.z + i)
);
}),
(j.prototype.equals = function(t) {
return this.pos.equals(t.pos) && this.thickness === t.thickness;
});
var R = j,
C = function() {};
(C.prototype.sphereIntersect = function(t) {
throw "Error : sphereIntersect is abstract, should have been overwritten";
}),
(C.prototype.contains = function(t) {
throw "Error : contains is abstract, should have been overwritten";
}),
(C.prototype.getAcc = function(t, e) {
throw "Error : getAcc is abstract, should have been overwritten";
}),
(C.prototype.getNiceAcc = function(t) {
throw "Error : getNiceAcc is abstract, should have been overwritten";
}),
(C.prototype.getCurrAcc = function(t) {
throw "Error : getCurrAcc is abstract, should have been overwritten";
}),
(C.prototype.getRawAcc = function(t) {
throw "Error : getRawAcc is abstract, should have been overwritten";
}),
(C.prototype.getMinAcc = function() {
throw "Error : getRawAcc is abstract, should have been overwritten";
}),
(C.prototype.getMinRawAcc = function() {
throw "Error : getRawAcc is abstract, should have been overwritten";
});
var I,
J = C,
K = {nice: 0.3, raw: 1, curr: 0.3},
G = K,
H = function(e, i, s) {
J.call(this),
(this.p = new t.Vector3(e.x, e.y, e.z)),
(this.r = i),
(this.accFactor = s || 1);
};
((H.prototype = Object.create(J.prototype)).constructor = H),
(H.prototype.sphereIntersect =
((I = new t.Vector3()),
function(t) {
I.subVectors(t.center, this.p);
var e = t.radius + this.radius;
return I.lengthSq() < e * e;
})),
(H.prototype.contains = (function() {
var e = new t.Vector3();
return function(t) {
return e.subVectors(t, this.p), e.lengthSq() < this.r * this.r;
};
})()),
(H.prototype.getAcc = function(t, e) {
return this.radius * e;
}),
(H.prototype.getNiceAcc = function(t) {
return this.getAcc(t, G.nice * this.accFactor);
}),
(H.prototype.getCurrAcc = function(t) {
return this.getAcc(t, G.curr * this.accFactor);
}),
(H.prototype.getRawAcc = function(t) {
return this.getAcc(t, G.raw * this.accFactor);
}),
(H.prototype.getMinAcc = function() {
return G.curr * this.r * this.accFactor;
}),
(H.prototype.getMinRawAcc = function() {
return G.raw * this.r * this.accFactor;
}),
(H.prototype.getAxisProjectionMinStep = function(t, e) {
var i = 1e8,
s = e - this.p[t];
return (
s < -2 * this.r
? (i = Math.min(
  i,
  Math.max(Math.abs(s + this.r), G.curr * this.r * this.accFactor)
  ))
: s < 2 * this.r && (i = Math.min(i, G.curr * this.r * this.accFactor)),
i
);
});
var L = H,
U = function(e, i, s, r) {
E.call(this),
this.v.push(e),
this.v[0].setPrimitive(this),
(this.volType = i),
(this.density = s),
this.materials.push(r),
(this.v_to_p = new t.Vector3());
};
((U.prototype = Object.create(E.prototype)).constructor = U),
(U.type = "ScalisPoint"),
r.register(U.type, U),
(U.prototype.getType = function() {
return U.type;
}),
(U.prototype.toJSON = function() {
var t = E.prototype.toJSON.call(this);
return (t.density = this.density), t;
}),
(U.fromJSON = function(t) {
var e = R.fromJSON(t.v[0]),
i = m.fromJSON(t.materials[0]);
return new U(e, t.volType, t.density, i);
}),
(U.prototype.setDensity = function(t) {
(this.density = t), this.invalidAABB();
}),
(U.prototype.getDensity = function() {
return this.density;
}),
(U.prototype.setMaterial = function(t) {
this.materials[0].copy(t), this.invalidAABB();
}),
(U.prototype.computeHelpVariables = function() {
this.computeAABB();
}),
(U.prototype.prepareForEval = function() {
this.valid_aabb || (this.computeHelpVariables(), (this.valid_aabb = !0));
}),
(U.prototype.getAreas = function() {
if (this.valid_aabb)
return [
{
aabb: this.aabb,
bv: new L(this.v[0].getPos(), z.KS * this.v[0].getThickness(), z.KIS),
obj: this
}
];
throw "ERROR : Cannot get area of invalid primitive";
}),
(U.prototype.heuristicStepWithin = function() {
return this.v[0].getThickness() / 3;
}),
(U.prototype.value = function(t, e) {
if (!this.valid_aabb) throw "Error : PrepareForEval should have been called";
var i = this.v[0].getThickness();
this.v_to_p.subVectors(t, this.v[0].getPos());
var s = this.v_to_p.lengthSq() / (i * i),
r = 1 - z.KIS2 * s;
if (r > 0) {
if (((e.v = this.density * r * r * r * z.Poly6NF0D), e.g)) {
var o =
(-this.density * z.KIS2 * 6 * this.v_to_p.length() * r * r * z.Poly6NF0D) /
(i * i);
e.g
.copy(this.v_to_p)
.normalize()
.multiplyScalar(o);
}
e.m && e.m.copy(this.materials[0]);
} else (e.v = 0), e.g && e.g.set(0, 0, 0), e.m && e.m.copy(m.defaultMaterial);
}),
(U.prototype.distanceTo = function(t) {
return t.distanceTo(this.v[0].getPos());
});
var W = U,
Z = function(e, i, s, r) {
J.call(this),
(this.p0 = new t.Vector3(e.x, e.y, e.z)),
(this.p1 = new t.Vector3(i.x, i.y, i.z)),
(this.thick0 = s),
(this.thick1 = r),
(this.unit_dir = new t.Vector3().subVectors(i, e)),
(this.length = this.unit_dir.length()),
this.unit_dir.normalize(),
(this.vector = new t.Vector3()),
(this.p0_to_p = this.vector),
(this.p0_to_p_sqrnorm = 0),
(this.x_p_2D = 0),
(this.y_p_2D = 0),
(this.y_p_2DSq = 0),
(this.ortho_vec_x = this.thick0 - this.thick1),
(this.ortho_vec_y = this.length),
(this.p_proj_x = 0),
(this.p_proj_y = 0),
(this.abs_diff_thick = Math.abs(this.ortho_vec_x));
};
((Z.prototype = Object.create(J.prototype)).constructor = Z),
(Z.prototype.proj_computation = function(t) {
(this.p0_to_p = this.vector),
this.p0_to_p.subVectors(t, this.p0),
(this.p0_to_p_sqrnorm = this.p0_to_p.lengthSq()),
(this.x_p_2D = this.p0_to_p.dot(this.unit_dir)),
(this.y_p_2DSq = this.p0_to_p_sqrnorm - this.x_p_2D * this.x_p_2D),
(this.y_p_2D = this.y_p_2DSq > 0 ? Math.sqrt(this.y_p_2DSq) : 0);
var e = -this.y_p_2D / this.ortho_vec_y;
(this.p_proj_x = this.x_p_2D + e * this.ortho_vec_x), (this.p_proj_y = 0);
}),
(Z.prototype.sphereIntersect = function(t) {
if ((this.proj_computation(t.center), this.p_proj_x < 0))
return Math.sqrt(this.p0_to_p_sqrnorm) - t.radius < this.thick0 * z.KS;
if (this.p_proj_x > this.length)
return (
this.vector.subVectors(t.center, this.p1),
Math.sqrt(this.vector.lengthSq()) - t.radius < this.thick1 * z.KS
);
var e = this.x_p_2D - this.p_proj_x,
i = e * e + this.y_p_2DSq,
s = this.p_proj_x / this.length,
r = this.thick0 * (1 - s) + s * this.thick1,
o = t.radius + r * z.KS;
return i < o * o;
}),
(Z.prototype.contains = function(t) {
if ((this.proj_computation(t), this.p_proj_x < 0))
return this.p0_to_p_sqrnorm < this.thick0 * this.thick0 * z.KS2;
if (this.p_proj_x > this.length)
return (
this.vector.subVectors(t, this.p1),
this.vector.lengthSq() < this.thick1 * this.thick1 * z.KS2
);
var e = this.x_p_2D - this.p_proj_x,
i = this.y_p_2D - this.p_proj_y,
s = e * e + i * i,
r = this.p_proj_x / this.length,
o = this.thick0 * (1 - r) + r * this.thick1;
return s < o * o * z.KS2;
}),
(Z.prototype.getAcc = function(t, e) {
this.proj_computation(t.center);
var i = this.abs_diff_thick / this.length,
s = t.radius * Math.sqrt(1 + i * i) * 0.5,
r = this.p_proj_x;
if ((r += this.thick0 > this.thick1 ? s : -s) < 0) return this.thick0 * e;
if (r > this.length) return this.thick1 * e;
var o = r / this.length;
return (this.thick0 * (1 - o) + o * this.thick1) * e;
}),
(Z.prototype.getNiceAcc = function(t) {
return this.getAcc(t, G.nice);
}),
(Z.prototype.getCurrAcc = function(t) {
return this.getAcc(t, G.curr);
}),
(Z.prototype.getRawAcc = function(t) {
return this.getAcc(t, G.raw);
}),
(Z.prototype.getMinAcc = function() {
return G.curr * Math.min(this.thick0, this.thick1);
}),
(Z.prototype.getMinRawAcc = function() {
return G.raw * Math.min(this.thick0, this.thick1);
}),
(Z.prototype.getAxisProjectionMinStep = function(t, e) {
var i,
s,
r,
o = Number.MAX_VALUE,
n = this.p0[t] < this.p1[t] ? this.p0 : this.p1;
n === this.p0
? ((i = this.p1), (s = this.thick0), (r = this.thick1))
: ((i = this.p0), (s = this.thick1), (r = this.thick0));
var h = e - n[t];
h < -2 * s
? (o = Math.min(o, Math.max(Math.abs(h + 2 * s), G.curr * s)))
: h < 2 * s && (o = Math.min(o, G.curr * s)),
(h = e - i[t]) < -2 * r
? (o = Math.min(o, Math.max(Math.abs(h + 2 * r), G.curr * r)))
: h < 2 * r && (o = Math.min(o, G.curr * r));
var a = e - n[t],
c = i[t] - n[t];
return (
a > 0 &&
a < c &&
0 !== c &&
(o = Math.min(o, G.curr * (s + (a / c) * (r - s)))),
o
);
});
var X,
$,
Y,
Q,
tt = Z,
et = function(e, i, s, r, o) {
E.call(this),
(this.v.length = 2),
(this.v[0] = e),
(this.v[1] = i),
e.setPrimitive(this),
i.setPrimitive(this),
(this.volType = s),
(this.density = r),
(this.materials = o),
(this.clipped_l1 = 1),
(this.clipped_l2 = 0),
(this.vector = new t.Vector3()),
(this.cycle = new t.Vector3()),
(this.proj = new t.Vector3()),
(this.v0_p = this.v[0].getPos()),
(this.v1_p = this.v[1].getPos()),
(this.dir = new t.Vector3()),
(this.lengthSq = 0),
(this.length = 0),
(this.unit_dir = new t.Vector3()),
(this.weight_p1 = 0),
(this.c0 = 0),
(this.c1 = 0),
(this.increase_unit_dir = new t.Vector3()),
(this.p_min = new t.Vector3()),
(this.weight_min = 0),
(this.inv_weight_min = 0),
(this.unit_delta_weight = 0),
(this.maxbound = 0),
(this.maxboundSq = 0),
(this.cyl_bd0 = 0),
(this.cyl_bd1 = 0),
(this.f0f1f2 = new t.Vector3()),
(this.tmpVec1 = new t.Vector3()),
(this.tmpVec2 = new t.Vector3()),
this.computeHelpVariables();
};
(et.prototype = Object.create(E.prototype)),
(et.constructor = et),
(et.type = "ScalisSegment"),
r.register(et.type, et),
(et.prototype.getType = function() {
return et.type;
}),
(et.prototype.toJSON = function() {
var t = E.prototype.toJSON.call(this);
return (t.density = this.density), t;
}),
(et.fromJSON = function(t) {
var e = R.fromJSON(t.v[0]),
i = R.fromJSON(t.v[1]),
s = [m.fromJSON(t.materials[0]), m.fromJSON(t.materials[1])];
return new et(e, i, t.volType, t.density, s);
}),
(et.prototype.mutableVolType = function() {
return !0;
}),
(et.prototype.setDensity = function(t) {
(this.density = t), this.invalidAABB();
}),
(et.prototype.getDensity = function() {
return this.density;
}),
(et.prototype.setVolType = function(t) {
if (t != E.CONVOL && t != E.DIST)
throw "ERROR : volType must be set to ScalisPrimitive.CONVOL or ScalisPrimitive.DIST";
this.volType != t && ((this.volType = t), this.invalidAABB());
}),
(et.prototype.getVolType = function() {
return this.volType;
}),
(et.prototype.prepareForEval = function() {
this.valid_aabb || (this.computeHelpVariables(), (this.valid_aabb = !0));
}),
(et.prototype.getAreas = function() {
if (this.valid_aabb)
return [
{
aabb: this.aabb,
bv: new tt(
this.v[0].getPos(),
this.v[1].getPos(),
this.v[0].getThickness(),
this.v[1].getThickness(),
this.length,
this.unit_dir
),
obj: this
}
];
throw "ERROR : Cannot get area of invalid primitive";
}),
(et.prototype.computeHelpVariables = function() {
(this.v0_p = this.v[0].getPos()),
(this.v1_p = this.v[1].getPos()),
this.dir.subVectors(this.v1_p, this.v0_p),
(this.lengthSq = this.dir.lengthSq()),
(this.length = Math.sqrt(this.lengthSq)),
this.unit_dir.copy(this.dir).normalize(),
(this.weight_p1 = this.v[1].getThickness()),
(this.c0 = this.v[0].getThickness()),
(this.c1 = this.v[1].getThickness() - this.v[0].getThickness());
var t = this.v[0].getThickness() * z.KS,
e = this.v[1].getThickness() * z.KS;
(this.maxbound = Math.max(t, e)),
(this.maxboundSq = this.maxbound * this.maxbound),
(this.cyl_bd0 = Math.min(-t, this.length - e)),
(this.cyl_bd1 = Math.max(this.length + e, t)),
this.increase_unit_dir.copy(this.unit_dir),
this.c1 < 0
? (this.p_min.copy(this.v1_p),
  (this.weight_min = this.weight_p1),
  (this.inv_weight_min = 1 / this.weight_p1),
  this.increase_unit_dir.negate(),
  (this.unit_delta_weight = -this.c1 / this.length))
: (this.p_min.copy(this.v0_p),
  (this.weight_min = this.c0),
  (this.inv_weight_min = 1 / this.c0),
  (this.unit_delta_weight = this.c1 / this.length)),
this.computeAABB();
}),
(et.prototype.value = function(t, e) {
switch (this.volType) {
case E.DIST:
this.evalDist(t, e);
break;
case E.CONVOL:
this.evalConvol(t, e);
break;
default:
throw "Unknown volType, cannot evaluate.";
}
}),
(et.prototype.evalDist =
((X = {v: 0}),
($ = new t.Vector3()),
function(t, e) {
var i = this.vector;
i.subVectors(t, this.v[0].getPos());
var s = i.dot(this.dir),
r = i.lengthSq(),
o = this.lengthSq * this.c0 + s * this.c1,
n = this.c1 < 0 ? 0 : 1;
o > 0 && (n = (n = s * this.c0 + r * this.c1) < 0 ? 0 : n > o ? 1 : n / o);
var h = Math.sqrt(n * (n * this.lengthSq - 2 * s) + r),
a = this.c0 + n * this.c1;
if (
((e.v = this.density * z.Poly6Eval(h / a) * z.Poly6NF0D),
e.m && this.evalMat(t, e),
e.g)
) {
var c = this.density / 1e-5;
$.copy(t),
($.x += 1e-5),
this.evalDist($, X),
(e.g.x = c * (X.v - e.v)),
($.x -= 1e-5),
($.y += 1e-5),
this.evalDist($, X),
(e.g.y = c * (X.v - e.v)),
($.y -= 1e-5),
($.z += 1e-5),
this.evalDist($, X),
(e.g.z = c * (X.v - e.v));
}
})),
(et.prototype.evalMat = function(t, e) {
var i = this.vector;
i.subVectors(t, this.v[0].getPos());
var s = this.unit_dir.dot(i) / this.length;
s > 1
? e.m.copy(this.materials[1])
: s <= 0
? e.m.copy(this.materials[0])
: (e.m.copy(this.materials[0]), e.m.lerp(this.materials[1], s));
}),
(et.prototype.HomotheticClippingSpecial = function(t) {
var e = -t.z,
i = -t.y,
s = -t.x,
r = i * i - e * s;
if (r >= 0) {
var o = i + Math.sqrt(r);
if (o < 0 || this.length * o < s) return !1;
var n = s / o;
this.clipped_l1 = n < 0 ? 0 : n;
var h = e * n;
return (
(this.clipped_l2 = 2 * i < h + e * this.length ? s / h : this.length), !0
);
}
return !1;
}),
(et.prototype.heuristicStepWithin = function() {
return this.weight_min / 3;
}),
(et.prototype.evalConvol = function(t, e) {
if (!this.valid_aabb) throw "Error : prepareForEval should have been called";
e.g && e.g.set(0, 0, 0), (e.v = 0);
var i = this.tmpVec1;
i.subVectors(t, this.p_min);
var s = this.increase_unit_dir.dot(i),
r = i.lengthSq(),
o = this.tmpVec2;
if (
(o.set(
this.weight_min * this.weight_min - z.KIS2 * r,
-this.unit_delta_weight * this.weight_min - z.KIS2 * s,
this.unit_delta_weight * this.unit_delta_weight - z.KIS2
),
this.HomotheticClippingSpecial(o))
) {
var n = 1 / (this.weight_min + this.clipped_l1 * this.unit_delta_weight);
(o.x = 1 - z.KIS2 * (this.clipped_l1 * (this.clipped_l1 - 2 * s) + r) * n * n),
(o.y = -this.unit_delta_weight - z.KIS2 * (s - this.clipped_l1) * n),
e.g
? (this.unit_delta_weight >= 0.06
  ? this.HomotheticCompactPolynomial_segment_FGradF_i6(
    (this.clipped_l2 - this.clipped_l1) * n,
    this.unit_delta_weight,
    o
    )
  : this.HomotheticCompactPolynomial_approx_segment_FGradF_i6(
    (this.clipped_l2 - this.clipped_l1) * n,
    this.unit_delta_weight,
    this.inv_weight_min,
    o
    ),
  (e.v = z.Poly6NF1D * this.f0f1f2.x),
  (this.f0f1f2.y *= n),
  e.g
  .copy(this.increase_unit_dir)
  .multiplyScalar(this.f0f1f2.z + this.clipped_l1 * this.f0f1f2.y)
  .sub(i.multiplyScalar(this.f0f1f2.y))
  .multiplyScalar(6 * z.Poly6NF1D * z.KIS2 * n))
: this.unit_delta_weight >= 0.06
? (e.v =
  z.Poly6NF1D *
  this.HomotheticCompactPolynomial_segment_F_i6(
  (this.clipped_l2 - this.clipped_l1) * n,
  this.unit_delta_weight,
  o
  ))
: (e.v =
  z.Poly6NF1D *
  this.HomotheticCompactPolynomial_approx_segment_F_i6(
  (this.clipped_l2 - this.clipped_l1) * n,
  this.unit_delta_weight,
  n,
  o
  )),
e.m && this.evalMat(t, e);
}
}),
(et.prototype.clamp = function(t, e, i) {
return Math.max(e, Math.min(i, t));
}),
(et.prototype.distanceTo =
((Y = new t.Vector3()),
(Q = new t.Vector3()),
function(t) {
var e = Y.subVectors(t, this.v[0].getPos()).dot(this.dir) / this.lengthSq;
return (
(e = this.clamp(e, 0, 1)),
Q.copy(this.dir)
.multiplyScalar(e)
.add(this.v[0].getPos()),
t.distanceTo(Q)
);
})),
(et.prototype.HomotheticCompactPolynomial_segment_F_i6 = function(t, e, i) {
var s = e * t + 1,
r = 1 / s,
o = s * s,
n = 1 / (o * o),
h = i.y,
a = h * h,
c = 12 * a,
p = 1 / e,
l = h * p,
u = s * o,
v = t * t,
m = v * v,
g = t * v,
_ = t * m,
y = i.x,
d = i.z,
f = y * y,
b = d * d,
w = 1 / (u * u),
x = r * n,
V = 1 / u,
A = 1 / o;
return (
-b *
(((((-(r - 1) * p - t * A) * p - v * V) * p - g * n) * p - m * x) * p - _ * w) *
l +
((-y * (w - 1) * p) / 6 - ((-(x - 1) * p) / 5 - t * w) * l) * f +
(((y * c + 3 * d * f) * (0.4 * ((-(n - 1) * p) / 4 - t * x) * p - v * w) +
(3 * b * y + d * c) *
(0.8 *
(0.75 * ((2 / 3) * ((-(A - 1) * p) / 2 - t * V) * p - v * n) * p - g * x) *
p -
m * w) +
d *
b *
(1.2 *
((5 / 4) *
((4 / 3) * (1.5 * (2 * (Math.log(s) * p - t * r) * p - v * A) * p - g * V) * p -
m * n) *
p -
_ * x) *
p -
g * g * w) +
(-12 * d * y - 8 * a) *
(0.6 * ((((-(V - 1) * p) / 3 - t * n) * p) / 2 - v * x) * p - g * w) *
h) *
p) /
6
);
}),
(et.prototype.HomotheticCompactPolynomial_approx_segment_F_i6 = function(
t,
e,
i,
s
) {
var r = i * e,
o = r + 1,
n = 1 / o,
h = o * o,
a = n / (h * h) / h,
c = s.z,
p = s.y,
l = s.x,
u = t * t,
v = c * u - 2 * p * t + l,
m = c * l - p * p,
g = c * t - p,
_ = l * l,
y = p * _,
d = v * v,
f = g * d,
b = 1 / c,
w = m * b,
x =
(6 / 35) * ((4 / 3) * (2 * m * t + g * v + p * l) * w + f + y) * w +
(v * f) / 7 +
(l * y) / 7,
V = b * x,
A = n * a,
S = d * d,
M = p * V + S / 8 - (_ * _) / 8,
T = -t * S + (-10 * p * M + l * x) * b;
return (
V -
7 * e * M * b +
((-0.1111111111 * (3 * a - 3 + 7 * (2 + A) * r) * T -
((0.1 * (2 - 2 * a - 7 * (1 + A) * r)) / i) *
(-1 * u * S + (1.333333333 * p * T + 2 * l * M) * b)) *
b) /
(i * i)
);
}),
(et.prototype.HomotheticCompactPolynomial_segment_FGradF_i6 = function(
t,
e,
i
) {
var s = e * t + 1,
r = 1 / s,
o = s * s,
n = 1 / (o * o),
h = i.y,
a = h * h,
c = 2 * a,
p = i.z,
l = i.x,
u = (p * l) / 3 + (2 / 3) * a,
v = p * p,
m = v / 6,
g = (-2 / 3) * p,
_ = s * o,
y = 1 / _,
d = r * n,
f = 1 / (_ * _),
b = t * t,
w = 1 / e,
x = t * b,
V = 0.6 * ((((-(y - 1) * w) / 3 - t * n) * w) / 2 - b * d) * w - x * f,
A = V * h,
S = (-(d - 1) * w) / 5 - t * f,
M = l * l,
T = M * S,
B = 0.4 * ((-(n - 1) * w) / 4 - t * d) * w - b * f,
P = l * B,
N = (-M * (f - 1)) / 6,
k = b * b,
F = t * k,
D = 1 / o,
z =
0.8 *
(0.75 * ((2 / 3) * ((-(D - 1) * w) / 2 - t * y) * w - b * n) * w - x * d) *
w -
k * f,
O =
((((-(r - 1) * w - t * D) * w - b * y) * w - x * n) * w - k * d) * w - F * f,
E = x * x,
q = Math.log(s);
(this.f0f1f2.x =
(l * N -
h * T +
P * c -
(4 / 3) * a * A +
((M * B) / 2 + z * c - 2 * l * A) * p +
((l * z) / 2 -
h * O +
((-E * f) / 6 +
((-F * d) / 5 +
((-k * n) / 4 + ((-x * y) / 3 + ((-b * D) / 2 + (q * w - t * r) * w) * w) * w) *
w) *
w) *
p) *
v) *
w),
(this.f0f1f2.y = (N + B * u + z * m + ((-2 / 3) * l * S + V * g) * h) * w),
(this.f0f1f2.z = (T / 6 + V * u + O * m + ((-2 / 3) * P + z * g) * h) * w);
}),
(et.prototype.HomotheticCompactPolynomial_approx_segment_FGradF_i6 = function(
t,
e,
i,
s
) {
var r = i * e,
o = r + 1,
n = 1 / o,
h = 1 / (i * i),
a = o * o,
c = n / (a * a) / a,
p = s.x,
l = 2 * p,
u = s.z,
v = 1 / u,
m = e * v,
g = s.y,
_ = t * t,
y = u * _ - 2 * g * t + p,
d = y * y,
f = y * d,
b = p * p,
w = p * b,
x = u * p - g * g,
V = u * t - g,
A = x * v,
S = (4 / 3) * (2 * x * t + V * y + g * p) * A + V * d + g * b,
M = S / 5,
T = g * v * M + f / 6 - w / 6,
B = -t * f + (-8 * g * T + p * M) * v,
P = _ * f,
N = ((10 / 7) * g * B + T * l) * v - P,
k = -N / 8,
F = (6 / 35) * S * A + (V * f) / 7 + (g * w) / 7,
D = n * c,
z = (3 * c - 3 + 7 * (2 + D) * r) * h,
O = ((2 - 2 * c - 7 * (1 + D) * r) / i) * h,
E = v * z,
q = v * O,
j = v * F,
R = d * d,
C = g * j + R / 8 - (b * b) / 8,
I = -t * R + (-10 * g * C + p * F) * v;
(this.f0f1f2.x =
j -
7 * C * m -
(I * E) / 9 -
((-_ * R + ((4 / 3) * g * I + C * l) * v) * q) / 10),
(this.f0f1f2.y = (M - 7 * e * T - (B * z) / 7 + O * k) * v),
(this.f0f1f2.z =
T * v +
B * m +
E * k -
((-t * P + (1.5 * g * N - (3 / 7) * p * B) * v) * q) / 9);
});
var it = et,
st = {},
rt = function(t, e) {
var i = t;
if (0 === e) throw "Lenght of the array should not be null";
return 1 === e ? 0 : (t < 0 && (i = (e + t) % e), t >= e && (i = t % e), i);
};
(st.computeVectorsDirs = function(e) {
var i = e.v[0].getPos(),
s = e.v[1].getPos(),
r = e.v[2].getPos();
e.p0p1.subVectors(s, i),
e.p1p2.subVectors(r, s),
e.p2p0.subVectors(i, r),
e.unit_normal.crossVectors(e.p0p1, e.p2p0),
e.unit_normal.normalize(),
(e.length_p0p1 = e.p0p1.length()),
e.unit_p0p1.copy(e.p0p1),
e.unit_p0p1.divideScalar(e.length_p0p1),
(e.diffThick_p0p1 = e.v[0].getThickness() - e.v[1].getThickness()),
(e.length_p1p2 = e.p1p2.length()),
e.unit_p1p2.copy(e.p1p2),
e.unit_p1p2.divideScalar(e.length_p1p2),
(e.diffThick_p1p2 = e.v[1].getThickness() - e.v[2].getThickness()),
(e.length_p2p0 = e.p2p0.length()),
e.unit_p2p0.copy(e.p2p0),
e.unit_p2p0.divideScalar(e.length_p2p0),
(e.diffThick_p2p0 = e.v[2].getThickness() - e.v[0].getThickness());
var o = [];
o.push({vert: e.v[0].getPos(), thick: e.v[0].getThickness(), idx: 0}),
o.push({vert: e.v[1].getPos(), thick: e.v[1].getThickness(), idx: 1}),
o.push({vert: e.v[2].getPos(), thick: e.v[2].getThickness(), idx: 2}),
o.sort(function(t, e) {
return t.thick - e.thick;
}),
(e.point_min = o[0].vert),
(e.weight_min = o[0].thick);
var n = rt(o[0].idx + 1, 3),
h = e.v[n].getPos(),
a = e.v[n].getThickness();
n = rt(o[0].idx + 2, 3);
var c = e.v[n].getPos(),
p = e.v[n].getThickness(),
l = new t.Vector3();
l = l.subVectors(h, e.point_min);
var u = new t.Vector3();
u = u.subVectors(c, e.point_min);
var v = a - e.weight_min,
m = p - e.weight_min;
if (v < 1e-6 || m < 1e-6) {
if (v < m) {
(e.ortho_dir = l.clone()),
e.ortho_dir.normalize(),
e.main_dir.crossVectors(e.ortho_dir, e.unit_normal),
e.main_dir.normalize(),
e.main_dir.dot(u) < 0 && e.main_dir.multiplyScalar(-1);
var g = -e.weight_min / m;
e.point_iso_zero = new t.Vector3(
e.point_min.x + g * u.x,
e.point_min.y + g * u.y,
e.point_min.z + g * u.z
);
} else {
(e.ortho_dir = u.clone()),
e.ortho_dir.normalize(),
e.main_dir.crossVectors(e.ortho_dir, e.unit_normal),
e.main_dir.normalize(),
e.main_dir.dot(l) < 0 && e.main_dir.multiplyScalar(-1);
g = -e.weight_min / v;
e.point_iso_zero = new t.Vector3(
e.point_min.x + g * l.x,
e.point_min.y + g * l.y,
e.point_min.z + g * l.z
);
}
Math.abs(v - m) < 1e-6 &&
((e.proj_dir = e.unit_normal.clone().multiplyScalar(-1)),
(e.equal_weights = !0));
} else {
var _ = -e.weight_min / v,
y = new t.Vector3(
e.point_min.x + _ * l.x,
e.point_min.y + _ * l.y,
e.point_min.z + _ * l.z
);
e.point_iso_zero = y;
var d = -e.weight_min / m,
f = new t.Vector3(
e.point_min.x + d * u.x,
e.point_min.y + d * u.y,
e.point_min.z + d * u.z
);
e.ortho_dir.subVectors(f, y),
e.ortho_dir.normalize(),
e.main_dir.crossVectors(e.ortho_dir, e.unit_normal),
e.main_dir.normalize(),
(e.main_dir.dot(l) < 0 || e.main_dir.dot(u) < 0) &&
e.main_dir.multiplyScalar(-1);
}
var b = l.dot(e.main_dir),
w = u.dot(e.main_dir),
x = null;
(b = b < 0 ? 0 : b) > (w = w < 0 ? 0 : w)
? ((x = l),
  (e.half_dir_1 = u),
  (e.point_half = c),
  (e.half_dir_2 = h.clone().subVectors(h, c)),
  (e.coord_max = b),
  (e.coord_middle = (w / b) * e.coord_max),
  (e.unit_delta_weight = v / e.coord_max))
: ((x = u),
  (e.half_dir_1 = l),
  (e.point_half = h),
  (e.half_dir_2 = c.clone().subVectors(c, h)),
  (e.coord_max = w),
  (e.coord_middle = (b / w) * e.coord_max),
  (e.unit_delta_weight = m / e.coord_max)),
(e.longest_dir_special = x.divideScalar(e.coord_max));
var V = new t.Vector3();
V.subVectors(
e.half_dir_1,
e.longest_dir_special.clone().multiplyScalar(e.coord_middle)
),
(e.max_seg_length = V.length()),
(e.unsigned_ortho_dir = e.ortho_dir.clone()),
e.ortho_dir.dot(V) < 0 && e.ortho_dir.multiplyScalar(-1);
}),
(st.getParametrisedVertexAttr = function(e, i, s) {
var r = st.getMeanThick(e, i, s),
o = new t.Vector3(),
n = o.subVectors(e.v[1].getPos(), e.v[0].getPos()).multiplyScalar(i),
h = o
.clone()
.subVectors(e.v[2].getPos(), e.v[0].getPos())
.multiplyScalar(s);
return o.addVectors(e.v[0].getPos(), n), o.addVectors(o, h), {pos: o, thick: r};
}),
(st.getMeanThick = function(t, e, i) {
return (
t.v[0].getThickness() * (1 - e - i) +
t.v[1].getThickness() * e +
t.v[2].getThickness() * i
);
}),
(st.getMeanMat = function(t, e, i) {
var s = new Material(),
r =
null === t.materials
? [t.v[0].getMaterial(), t.v[0].getMaterial(), t.v[0].getMaterial()]
: [t.materials[0], t.materials[1], t.materials[2]];
return s.weightedMean(r, [1 - e - i, e, i]), s;
}),
(st.getTriBaryCoord = function(e, i, s, r) {
var o = e,
n = i.clone().multiplyScalar(-1),
h = new t.Vector3().subVectors(r, s),
a = o.lengthSq(),
c = o.dot(n),
p = h.dot(o),
l = n.lengthSq(),
u = (a * h.dot(n) - c * p) / (a * l - c * c);
return {u: (p - u * c) / a, v: u};
}),
(st.getUVCoord = function(e, i, s, r) {
var o = new t.Vector3();
o.crossVectors(e, i);
var n = new t.Matrix4();
n.set(e.x, i.x, o.x, 0, e.y, i.y, o.y, 0, e.z, i.z, o.z, 0, 0, 0, 0, 1);
var h = new t.Matrix4();
h.getInverse(n);
var a = new t.Vector3().subVectors(r, s);
return a.applyMatrix4(h), {u: a.x, v: a.y};
});
var ot = st,
nt = function(e, i, s, r, o, n) {
J.call(this),
(this.tmpVect = new t.Vector3()),
(this.min_thick = o),
(this.max_thick = n),
(this.v = e),
(this.p0p1 = this.tmpVect
.clone()
.subVectors(this.v[1].getPos(), this.v[0].getPos())),
(this.p2p0 = this.tmpVect
.clone()
.subVectors(this.v[0].getPos(), this.v[2].getPos())),
(this.unit_normal = i),
(this.main_dir = s);
var h = Math.abs(this.v[0].getThickness() - this.v[1].getThickness()),
a = Math.abs(this.v[1].getThickness() - this.v[2].getThickness());
(this.equal_weights =
h / Math.abs(this.v[0].getThickness() + this.v[1].getThickness()) < 0.001 &&
a / Math.abs(this.v[1].getThickness() + this.v[2].getThickness()) < 0.001),
(this.segParams = r),
(this.segAttr = {
p0_to_p: 0,
p0_to_p_sqrnorm: 0,
x_p_2D: 0,
y_p_2D: 0,
y_p_2DSq: 0,
p_proj_x: 0
});
var c = this.tmpVect
.clone()
.crossVectors(this.segParams[0].dir, this.unit_normal)
.normalize(),
p = this.tmpVect
.clone()
.crossVectors(this.segParams[1].dir, this.unit_normal)
.normalize(),
l = this.tmpVect
.clone()
.crossVectors(this.segParams[2].dir, this.unit_normal)
.normalize();
this.tmpVect.copy(this.unit_normal);
var u = [];
u.push(
this.tmpVect
.clone()
.addVectors(
this.v[0].getPos(),
this.tmpVect.multiplyScalar(this.v[0].getThickness() * z.KS)
)
),
this.tmpVect.copy(this.unit_normal),
u.push(
this.tmpVect
.clone()
.addVectors(
this.v[1].getPos(),
this.tmpVect.multiplyScalar(this.v[1].getThickness() * z.KS)
)
),
this.tmpVect.copy(this.unit_normal),
u.push(
this.tmpVect
.clone()
.addVectors(
this.v[2].getPos(),
this.tmpVect.multiplyScalar(this.v[2].getThickness() * z.KS)
)
),
this.tmpVect.copy(this.unit_normal),
u.push(
this.tmpVect
.clone()
.addVectors(
this.v[0].getPos(),
this.tmpVect.multiplyScalar(-this.v[0].getThickness() * z.KS)
)
),
this.tmpVect.copy(this.unit_normal),
u.push(
this.tmpVect
.clone()
.addVectors(
this.v[1].getPos(),
this.tmpVect.multiplyScalar(-this.v[1].getThickness() * z.KS)
)
),
this.tmpVect.copy(this.unit_normal),
u.push(
this.tmpVect
.clone()
.addVectors(
this.v[2].getPos(),
this.tmpVect.multiplyScalar(-this.v[2].getThickness() * z.KS)
)
);
var v = new t.Vector3();
this.tmpVect.subVectors(u[1], u[0]), v.subVectors(u[2], u[0]);
var m = this.tmpVect
.clone()
.crossVectors(this.tmpVect, v)
.normalize();
this.tmpVect.subVectors(u[5], u[3]), v.subVectors(u[4], u[3]);
var g = this.tmpVect
.clone()
.crossVectors(this.tmpVect, v)
.normalize();
(this.planeParams = []),
this.planeParams.push({orig: this.v[0].getPos(), n: c}),
this.planeParams.push({orig: this.v[1].getPos(), n: p}),
this.planeParams.push({orig: this.v[2].getPos(), n: l}),
this.planeParams.push({orig: u[0], n: m}),
this.planeParams.push({orig: u[3], n: g}),
(this.segAreas = []);
for (var _ = 0; _ < 3; ++_)
this.segAreas.push(
new tt(
this.segParams[_].v[0].getPos(),
this.segParams[_].v[1].getPos(),
this.segParams[_].v[0].getThickness(),
this.segParams[_].v[1].getThickness(),
this.segParams[_].norm,
this.segParams[_].dir
)
);
};
((nt.prototype = Object.create(J.prototype)).constructor = nt),
(nt.prototype.proj_computation = function(t, e) {
(this.segAttr.p0_to_p = this.tmpVect),
this.segAttr.p0_to_p.subVectors(t, e.v[0].getPos()),
(this.segAttr.p0_to_p_sqrnorm = this.segAttr.p0_to_p.lengthSq()),
(this.segAttr.x_p_2D = this.segAttr.p0_to_p.dot(e.dir)),
(this.segAttr.y_p_2DSq =
this.segAttr.p0_to_p_sqrnorm - this.segAttr.x_p_2D * this.segAttr.x_p_2D),
(this.segAttr.y_p_2D =
this.segAttr.y_p_2DSq > 0 ? Math.sqrt(this.segAttr.y_p_2DSq) : 0);
var i = -this.segAttr.y_p_2D / e.ortho_vec_y;
this.segAttr.p_proj_x = this.segAttr.x_p_2D + i * e.ortho_vec_x;
}),
(nt.prototype.sphereIntersect = function(t) {
for (var e = 0; e < 3; e++) {
if (this.sphereIntersectSegment(t, this.segParams[e], z.KS)) return !0;
}
e = 0;
for (var i = !0; e < 5; e++) {
this.tmpVect.subVectors(t.center, this.planeParams[e].orig);
var s = this.tmpVect.dot(this.planeParams[e].n);
i = i && s + t.r > 0;
}
return i;
}),
(nt.prototype.sphereIntersectSegment = function(t, e, i) {
this.proj_computation(t.center, e);
var s = e.v[0].getThickness(),
r = e.v[1].getThickness();
if (this.segAttr.p_proj_x < 0)
return Math.sqrt(this.segAttr.p0_to_p_sqrnorm) - t.r < s * i;
if (this.segAttr.p_proj_x > e.norm)
return (
this.segAttr.p0_to_p.subVectors(t.center, e.v[1].getPos()),
this.segAttr.p0_to_p.length() - t.r < r * i
);
var o = this.segAttr.x_p_2D - this.segAttr.p_proj_x,
n = o * o + this.segAttr.y_p_2DSq,
h = this.segAttr.p_proj_x / e.norm,
a = s * (1 - h) + h * r,
c = t.r + a * i;
return n < c * c;
}),
(nt.prototype.contains = function(t) {
var e = {r: 0, c: t};
return this.sphereIntersect(e);
}),
(nt.prototype.getAccSegment = function(t, e) {
var i = {intersect: !1, currAcc: G.nice * this.min_thick};
if (this.sphereIntersectSegment(t, e, 1)) {
var s = Math.abs(e.diffThick) / e.norm,
r = t.r * Math.sqrt(1 + s * s) * 0.5,
o = e.v[0].getThickness(),
n = e.v[1].getThickness(),
h = this.segAttr.p_proj_x;
if ((h += o > n ? r : -r) <= 0) i.currAcc = o;
else if (h >= e.norm) i.currAcc = n;
else {
var a = h / e.norm;
i.currAcc = o * (1 - a) + a * n;
}
i.intersect = !0;
}
return i;
}),
(nt.prototype.getAccTri = function(t) {
if (this.equal_weights) return this.min_thick;
var e = this.v[0].getPos(),
i = this.tmpVect.addVectors(
t.center,
this.main_dir.clone().multiplyScalar(t.r)
);
this.tmpVect.subVectors(i, e);
var s = this.tmpVect.lengthSq(),
r = this.tmpVect.dot(this.unit_normal),
o = Math.sqrt(s - r * r),
n = this.tmpVect
.clone()
.addVectors(t.center, this.unit_normal.clone().multiplyScalar(-r)),
h = ot.getTriBaryCoord(this.p0p1, this.p2p0, this.v[0].getPos(), n),
a = ot.getMeanThick(this, h.u, h.v);
a = r >= 0 ? a : -a;
var c = o + (-r / o) * (this.v[0].getThickness() - a),
p = this.tmpVect.subVectors(e, n).normalize(),
l = this.tmpVect.addVectors(n, p.multiplyScalar(o - c));
return (h = ot.getTriBaryCoord(this.p0p1, this.p2p0, this.v[0].getPos(), l))
.u <= 1 &&
h.v <= 1 &&
h.u + h.v <= 1 &&
h.u >= 0 &&
h.v >= 0
? ot.getMeanThick(this, h.u, h.v)
: 1e4 * this.max_thick;
}),
(nt.prototype.getAcc = function(t, e) {
for (var i = 0, s = 1e5 * this.max_thick; i < 3; i++) {
var r = this.getAccSegment(t, this.segParams[i]);
r.intersect && (s = s > r.currAcc ? r.currAcc : s);
}
var o = 1e5 * this.max_thick;
s !== this.min_thick && (o = this.getAccTri(t));
var n = Math.min(s, o);
return n !== 1e5 * this.max_thick ? n * e : this.max_thick * e;
}),
(nt.prototype.getNiceAcc = function(t) {
return this.getAcc(t, G.nice);
}),
(nt.prototype.getCurrAcc = function(t) {
return this.getAcc(t, G.curr);
}),
(nt.prototype.getRawAcc = function(t) {
return this.getAcc(t, G.raw);
}),
(nt.prototype.getMinAcc = function() {
return G.curr * this.min_thick;
}),
(nt.prototype.getMinRawAcc = function() {
return G.raw * this.min_thick;
}),
(nt.prototype.getAxisProjectionMinStep = function(t, e) {
for (var i = Number.MAX_VALUE, s = 0; s < 3; ++s)
i = Math.min(i, this.segAreas[s].getAxisProjectionMinStep(t, e));
return i;
});
var ht,
at,
ct,
pt,
lt,
ut,
vt = nt,
mt = function(e, i, s, r) {
if ((E.call(this), 1 !== s))
throw "Error in ScalisTriangle : cannot use a density different from 1.0, not implemented.";
(this.volType = i),
(this.materials =
null !== r
? r
: [
  m.defaultMaterial.clone(),
  m.defaultMaterial.clone(),
  m.defaultMaterial.clone()
  ]),
(this.v = e),
this.v[0].setPrimitive(this),
this.v[1].setPrimitive(this),
this.v[2].setPrimitive(this),
(this.min_thick = Math.min(
this.v[0].getThickness(),
this.v[1].getThickness(),
this.v[2].getThickness()
)),
(this.max_thick = Math.max(
this.v[0].getThickness(),
this.v[1].getThickness(),
this.v[2].getThickness()
)),
(this.res_gseg = {}),
(this.tmp_res_gseg = {}),
(this.p0p1 = new t.Vector3()),
(this.p1p2 = new t.Vector3()),
(this.p2p0 = new t.Vector3()),
(this.unit_normal = new t.Vector3()),
(this.unit_p0p1 = new t.Vector3()),
(this.unit_p1p2 = new t.Vector3()),
(this.unit_p2p0 = new t.Vector3()),
(this.length_p0p1 = 0),
(this.length_p1p2 = 0),
(this.length_p2p0 = 0),
(this.diffThick_p0p1 = 0),
(this.diffThick_p0p1 = 0),
(this.diffThick_p0p1 = 0),
(this.main_dir = new t.Vector3()),
(this.point_iso_zero = new t.Vector3()),
(this.ortho_dir = new t.Vector3()),
(this.unsigned_ortho_dir = new t.Vector3()),
(this.proj_dir = new t.Vector3()),
(this.equal_weights = !1),
(this.coord_max = 0),
(this.coord_middle = 0),
(this.unit_delta_weight = 0),
(this.longest_dir_special = 0),
(this.max_seg_length = 0),
(this.half_dir_1 = new t.Vector3()),
(this.point_half = new t.Vector3()),
(this.half_dir_2 = new t.Vector3()),
(this.point_min = new t.Vector3()),
(this.weight_min = 0),
(this.valid_aabb = !1);
};
((mt.prototype = Object.create(E.prototype)).constructor = mt),
(mt.type = "ScalisTriangle"),
r.register(mt.type, mt),
(mt.prototype.getType = function() {
return mt.type;
}),
(mt.prototype.toJSON = function() {
return E.prototype.toJSON.call(this);
}),
(mt.fromJSON = function(t) {
var e = [R.fromJSON(t.v[0]), R.fromJSON(t.v[1]), R.fromJSON(t.v[2])],
i = [
m.fromJSON(t.materials[0]),
m.fromJSON(t.materials[1]),
m.fromJSON(t.materials[2])
];
return new mt(e, t.volType, 1, i);
}),
(mt.prototype.prepareForEval = function() {
this.valid_aabb || (this.computeHelpVariables(), (this.valid_aabb = !0));
}),
(mt.prototype.getAreas = function() {
if (this.valid_aabb) {
var t = [];
return (
t.push({
norm: this.length_p0p1,
diffThick: this.diffThick_p0p1,
dir: this.unit_p0p1,
v: [this.v[0], this.v[1]],
ortho_vec_x: this.v[0].getThickness() - this.v[1].getThickness(),
ortho_vec_y: this.length_p0p1
}),
t.push({
norm: this.length_p1p2,
diffThick: this.diffThick_p1p2,
dir: this.unit_p1p2,
v: [this.v[1], this.v[2]],
ortho_vec_x: this.v[1].getThickness() - this.v[2].getThickness(),
ortho_vec_y: this.length_p1p2
}),
t.push({
norm: this.length_p2p0,
diffThick: this.diffThick_p2p0,
dir: this.unit_p2p0,
v: [this.v[2], this.v[0]],
ortho_vec_x: this.v[2].getThickness() - this.v[0].getThickness(),
ortho_vec_y: this.length_p2p0
}),
[
{
aabb: this.aabb,
bv: new vt(
this.v,
this.unit_normal,
this.main_dir,
t,
this.min_thick,
this.max_thick
),
obj: this
}
]
);
}
return console.log("ERROR : Cannot get area of invalid primitive"), [];
}),
(mt.prototype.computeHelpVariables = function() {
ot.computeVectorsDirs(this), this.computeAABB();
}),
(mt.prototype.mutableVolType = function() {
return !0;
}),
(mt.prototype.setVolType = function(t) {
if (t != E.CONVOL && t != E.DIST)
throw "ERROR : volType must be set to ScalisPrimitive.CONVOL or ScalisPrimitive.DIST";
this.volType != t && ((this.volType = t), this.invalidAABB());
}),
(mt.prototype.getVolType = function() {
return this.volType;
}),
(mt.prototype.clamp = function(t, e, i) {
return Math.max(e, Math.min(i, t));
}),
(mt.prototype.distanceTo = (function() {
var e = new t.Vector3(),
i = new t.Vector3(),
s = new t.Vector3(),
r = new t.Vector3();
return function(t) {
if (
(e.subVectors(t, this.v[0].getPos()),
i.subVectors(t, this.v[1].getPos()),
s.subVectors(t, this.v[2].getPos()),
r.crossVectors(this.p0p1, e).dot(this.unit_normal) > 0 &&
r.crossVectors(this.p1p2, i).dot(this.unit_normal) > 0 &&
r.crossVectors(this.p2p0, s).dot(this.unit_normal) > 0)
)
return Math.abs(e.dot(this.unit_normal));
var o = e.dot(this.p0p1) / this.length_p0p1;
(o = this.clamp(o, 0, 1)),
r
.copy(this.p0p1)
.multiplyScalar(o)
.add(this.v[0].getPos()),
(o = t.distanceToSquared(r));
var n = i.dot(this.p1p2) / this.length_p1p2;
(n = this.clamp(n, 0, 1)),
r
.copy(this.p1p2)
.multiplyScalar(n)
.add(this.v[1].getPos()),
(n = t.distanceToSquared(r));
var h = s.dot(this.p2p0) / this.length_p2p0;
return (
(h = this.clamp(h, 0, 1)),
r
.copy(this.p2p0)
.multiplyScalar(h)
.add(this.v[2].getPos()),
(h = t.distanceToSquared(r)),
Math.sqrt(Math.min(Math.min(o, n), h))
);
};
})()),
(mt.prototype.heuristicStepWithin = function() {
return this.weight_min / 3;
}),
(mt.prototype.value = function(t, e) {
switch (this.volType) {
case E.DIST:
return this.evalDist(t, e);
case E.CONVOL:
return this.evalConvol(t, e);
default:
throw "Unknown volType, use Orga";
}
}),
(mt.prototype.evalDist = (function() {
var e = {v: 0},
i = new t.Vector3();
return function(s, r) {
var o = new t.Vector3();
o.subVectors(s, this.v[0].getPos());
var n = this.unit_normal.clone().multiplyScalar(-1);
if (!this.equal_weights) {
var h = n,
a = this.unsigned_ortho_dir,
c = this.main_dir.clone().multiplyScalar(-1),
p = -this.v[0].getPos().dot(h),
l = -s.dot(a),
u = -this.point_iso_zero.dot(c),
v = new t.Vector3();
v.crossVectors(a, c), v.multiplyScalar(-p);
var m = new t.Vector3();
m.crossVectors(c, h), m.multiplyScalar(-l);
var g = new t.Vector3();
g.crossVectors(h, a), g.multiplyScalar(-u);
var _ = new t.Vector3();
_.crossVectors(a, c);
var y = new t.Vector3(v.x + m.x + g.x, v.y + m.y + g.y, v.z + m.z + g.z);
y.divideScalar(h.dot(_));
var d = new t.Vector3(y.x - s.x, y.y - s.y, y.z - s.z);
(this.proj_dir = new t.Vector3()),
this.proj_dir.crossVectors(d, this.unsigned_ortho_dir),
this.proj_dir.normalize();
}
var f = new t.Vector3();
f.copy(this.proj_dir),
f.multiplyScalar(-o.dot(n) / this.proj_dir.dot(n)),
f.add(s);
var b = new t.Vector3(),
w = new t.Vector3(),
x = new t.Vector3(),
V = new t.Vector3();
if (
(w.subVectors(f, this.v[0].getPos()),
x.subVectors(f, this.v[1].getPos()),
V.subVectors(f, this.v[2].getPos()),
b.crossVectors(this.unit_p0p1, w).dot(n) > 0 &&
b.crossVectors(this.unit_p1p2, x).dot(n) > 0 &&
b.crossVectors(this.unit_p2p0, V).dot(n) > 0)
) {
b.subVectors(s, f), (r.v = b.lengthSq());
var A = this.v[0].getPos(),
S = this.v[1].getPos(),
M = this.v[2].getPos(),
T = new t.Vector3();
b.subVectors(S, A), T.subVectors(M, A);
var B = new t.Vector3();
B.crossVectors(b, T),
b.subVectors(M, S),
(h = new t.Vector3()).crossVectors(b, x),
b.subVectors(A, M),
(a = new t.Vector3()).crossVectors(b, V),
b.subVectors(S, A),
(c = new t.Vector3()).crossVectors(b, w);
var P = B.lengthSq(),
N = B.dot(h),
k = B.dot(a),
F = B.dot(c),
D =
(N * this.v[0].getThickness() +
k * this.v[1].getThickness() +
F * this.v[2].getThickness()) /
P;
(r.v = z.Poly6Eval(Math.sqrt(r.v) / D) * z.Poly6NF0D),
r.m &&
r.m.triMean(
this.materials[0],
this.materials[1],
this.materials[2],
N,
k,
F,
P
);
} else {
var O = 0;
if (
(this.GenericSegmentComputation(
s,
this.v[0].getPos(),
this.p0p1,
this.length_p0p1,
this.length_p0p1 * this.length_p0p1,
this.v[0].getThickness(),
this.v[1].getThickness() - this.v[0].getThickness(),
this.res_gseg
),
(this.res_gseg.sqrdist = this.res_gseg.proj_to_p.lengthSq()),
(this.res_gseg.ratio =
this.res_gseg.sqrdist /
(this.res_gseg.weight_proj * this.res_gseg.weight_proj)),
this.GenericSegmentComputation(
s,
this.v[1].getPos(),
this.p1p2,
this.length_p1p2,
this.length_p1p2 * this.length_p1p2,
this.v[1].getThickness(),
this.v[2].getThickness() - this.v[1].getThickness(),
this.tmp_res_gseg
),
(this.tmp_res_gseg.sqrdist = this.tmp_res_gseg.proj_to_p.lengthSq()),
(this.tmp_res_gseg.ratio =
this.tmp_res_gseg.sqrdist /
(this.tmp_res_gseg.weight_proj * this.tmp_res_gseg.weight_proj)),
this.res_gseg.ratio > this.tmp_res_gseg.ratio &&
((this.res_gseg.sqrdist = this.tmp_res_gseg.sqrdist),
(this.res_gseg.proj_to_p = this.tmp_res_gseg.proj_to_p),
(this.res_gseg.weight_proj = this.tmp_res_gseg.weight_proj),
(this.res_gseg.ratio = this.tmp_res_gseg.ratio),
(this.res_gseg.t = this.tmp_res_gseg.t),
(O = 1)),
this.GenericSegmentComputation(
s,
this.v[2].getPos(),
this.p2p0,
this.length_p2p0,
this.length_p2p0 * this.length_p2p0,
this.v[2].getThickness(),
this.v[0].getThickness() - this.v[2].getThickness(),
this.tmp_res_gseg
),
(this.tmp_res_gseg.sqrdist = this.tmp_res_gseg.proj_to_p.lengthSq()),
(this.tmp_res_gseg.ratio =
this.tmp_res_gseg.sqrdist /
(this.tmp_res_gseg.weight_proj * this.tmp_res_gseg.weight_proj)),
this.res_gseg.ratio > this.tmp_res_gseg.ratio &&
((this.res_gseg.sqrdist = this.tmp_res_gseg.sqrdist),
(this.res_gseg.proj_to_p = this.tmp_res_gseg.proj_to_p),
(this.res_gseg.weight_proj = this.tmp_res_gseg.weight_proj),
(this.res_gseg.ratio = this.tmp_res_gseg.ratio),
(this.res_gseg.t = this.tmp_res_gseg.t),
(O = 2)),
(r.v =
z.Poly6Eval(Math.sqrt(this.res_gseg.sqrdist) / this.res_gseg.weight_proj) *
z.Poly6NF0D),
r.m)
)
switch (O) {
case 0:
r.m.copy(this.materials[0]), r.m.lerp(this.materials[1], this.res_gseg.t);
break;
case 1:
r.m.copy(this.materials[1]), r.m.lerp(this.materials[2], this.res_gseg.t);
break;
case 2:
r.m.copy(this.materials[2]), r.m.lerp(this.materials[0], this.res_gseg.t);
break;
default:
throw "Error : seg_case unknown";
}
}
if (r.g) {
i.copy(s),
(i.x += 1e-5),
this.evalDist(i, e),
(r.g.x = (e.v - r.v) / 1e-5),
(i.x -= 1e-5),
(i.y += 1e-5),
this.evalDist(i, e),
(r.g.y = (e.v - r.v) / 1e-5),
(i.y -= 1e-5),
(i.z += 1e-5),
this.evalDist(i, e),
(r.g.z = (e.v - r.v) / 1e-5);
}
};
})()),
(mt.prototype.GenericSegmentComputation = function(e, i, s, r, o, n, h, a) {
var c = new t.Vector3();
c.subVectors(e, i);
var p = c.dot(s),
l = c.lengthSq(),
u = o * n + p * h,
v = h < 0 ? 0 : 1;
return (
u > 0 && (v = (v = (p * n + l * h) / u) < 0 ? 0 : v > 1 ? 1 : v),
(a.proj_to_p = new t.Vector3(v * s.x - c.x, v * s.y - c.y, v * s.z - c.z)),
(a.weight_proj = n + v * h),
(a.t = v),
a
);
}),
(mt.prototype.evalConvol =
((ht = new t.Vector3()),
(at = new m()),
(ct = {v: 0, g: null, m: null}),
(pt = new t.Vector3()),
(lt = new m()),
(ut = {v: 0, g: null, m: null}),
function(e, i) {
(ct.g = i.g ? ht : null), (ct.m = i.m ? at : null);
var s = {l1: 0, l2: 0};
if (this.ComputeTParam(e, s)) {
var r = s.l1,
o = s.l2,
n = this.weight_min + r * this.unit_delta_weight,
h = this.warpAbscissa((o - r) / n),
a = 2 * (5 * h + 1),
c = h / a,
p = c;
c *= 2;
for (var l = 0, u = new t.Vector3(), v = 1; v < a; v += 2)
this.computeLineIntegral(this.unwarpAbscissa(p) * n + r, e, ct),
(l += ct.v),
i.g && u.addVectors(u, ct.g),
(p += c);
var m = 0,
g = new t.Vector3();
for (p = 0, v = 2; v < a; v += 2)
(p += c),
this.computeLineIntegral(this.unwarpAbscissa(p) * n + r, e, ct),
i.g && g.addVectors(g, ct.g),
(m += ct.v);
(ut.g = i.g ? pt : null), (ut.m = i.m ? lt : null);
var _ = this.computeLineIntegral(r, e, ct),
y = this.computeLineIntegral(o, e, ut);
i.v = _.v + 4 * l + 2 * m + _.v;
var d = (h / (3 * a)) * z.Poly6NF2D;
if (((i.v *= d), i.g)) {
var f = new t.Vector3();
f.addVectors(f, _.g),
f.addVectors(f, u.multiplyScalar(4)),
f.addVectors(f, g.multiplyScalar(2)),
f.addVectors(f, y.g),
(i.g = f.multiplyScalar(d));
}
} else (i.v = 0), (i.g = new t.Vector3());
i.m && ((ct.g = null), this.evalDist(e, ct), i.m.copy(ct.m));
})),
(mt.prototype.warpAbscissa = function(t) {
var e = t * this.unit_delta_weight,
i = 1 / (e + 2),
s = e * i;
return (
2 *
t *
i *
(1 +
(s *= s) *
(1 / 3 + s * (0.2 + s * (1 / 7 + s * (1 / 9 + s * (1 / 11 + s * (1 / 13)))))))
);
}),
(mt.prototype.unwarpAbscissa = function(t) {
var e = t * this.unit_delta_weight;
return (
t * (1 + e * (0.5 + e * (1 / 6 + e * (1 / 24 + e * (1 / 120 + (1 * e) / 720)))))
);
}),
(mt.prototype.computeLineIntegral = function(e, i, s) {
var r = this.weight_min + e * this.unit_delta_weight,
o = new t.Vector3();
o.addVectors(
this.point_min,
this.longest_dir_special.clone().multiplyScalar(e)
);
var n =
e < this.coord_middle
? (e / this.coord_middle) * this.max_seg_length
: ((this.coord_max - e) / (this.coord_max - this.coord_middle)) *
  this.max_seg_length;
return (
s.g
? this.consWeightEvalGradForSeg(o, r, this.ortho_dir, n, i, s)
: this.consWeightEvalForSeg(o, r, this.ortho_dir, n, i, s),
s
);
}),
(mt.prototype.homotheticClippingSpecial = function(t, e, i) {
var s = -t.z,
r = -t.y,
o = -t.x,
n = r * r - s * o;
if (n >= 0) {
var h = r + Math.sqrt(n);
if (h < 0 || e * h < o) return !1;
var a = o / h;
i.l1 = a < 0 ? 0 : a;
var c = s * a;
return (i.l2 = 2 * r < c + s * e ? o / c : e), !0;
}
return !1;
}),
(mt.prototype.consWeightEvalForSeg = function(e, i, s, r, o, n) {
var h = new t.Vector3();
h.subVectors(o, e);
var a = s.dot(h),
c = h.lengthSq(),
p = new t.Vector3();
p.set(i * i - z.KIS2 * c, -z.KIS2 * a, -z.KIS2);
var l = {l1: 0, l2: 0};
if (this.homotheticClippingSpecial(p, r, l)) {
var u = 1 / i;
(p.x = 1 - z.KIS2 * (l.l1 * (l.l1 - 2 * a) + c) * u * u),
(p.y = -z.KIS2 * (a - l.l1) * u),
(n.v = this.homotheticCompactPolynomial_segment_F_i6_cste(
(l.l2 - l.l1) * u,
p
));
} else n = 0;
return n;
}),
(mt.prototype.consWeightEvalGradForSeg = function(e, i, s, r, o, n) {
var h = new t.Vector3();
h.subVectors(o, e);
var a = s.dot(h),
c = h.lengthSq(),
p = new t.Vector3();
p.set(i * i - z.KIS2 * c, -z.KIS2 * a, -z.KIS2);
var l = {l1: 0, l2: 0};
if (this.homotheticClippingSpecial(p, r, l)) {
var u = 1 / i;
(p.x = 1 - z.KIS2 * (l.l1 * (l.l1 - 2 * a) + c) * u * u),
(p.y = -z.KIS2 * (a - l.l1) * u);
var v = new t.Vector3();
this.homotheticCompactPolynomial_segment_FGradF_i6_cste(
(l.l2 - l.l1) * u,
p,
v
),
(n.v = v.x),
(v.y *= u);
var m = s.clone();
m.multiplyScalar(v.z + l.l1 * v.y),
h.multiplyScalar(-v.y),
h.addVectors(h, m),
(n.g = h.multiplyScalar(6 * z.KIS2 * u));
} else (n.v = 0), n.g.set(0, 0, 0);
return n;
}),
(mt.prototype.ComputeTParam = function(e, i) {
var s = new t.Vector3();
s.subVectors(e, this.point_min);
var r = s.dot(this.main_dir),
o = s.dot(this.unit_normal),
n = r * r + o * o,
h = new t.Vector3();
return (
h.set(
this.weight_min * this.weight_min - z.KIS2 * n,
-this.unit_delta_weight * this.weight_min - z.KIS2 * r,
this.unit_delta_weight * this.unit_delta_weight - z.KIS2
),
this.homotheticClippingSpecial(h, this.coord_max, i)
);
}),
(mt.prototype.homotheticCompactPolynomial_segment_F_i6_cste = function(t, e) {
var i = e.z,
s = i * t,
r = e.y,
o = e.x,
n = i * o - r * r,
h = 1 / i,
a = n * h,
c = o + (-2 * r + s) * t,
p = s - r,
l = p * (c * c),
u = r * (o * o);
return (
((1.2 * ((4 / 3) * (2 * n * t + p * c + r * o) * a + l + u) * a +
c * l +
o * u) *
h) /
7
);
}),
(mt.prototype.homotheticCompactPolynomial_segment_FGradF_i6_cste = function(
t,
e,
i
) {
var s = e.z,
r = s * t,
o = e.y,
n = e.x,
h = s * n - o * o,
a = 1 / s,
c = h * a,
p = n + (-2 * o + r) * t,
l = r - o,
u = p * p,
v = n * n,
m = (4 / 3) * (2 * h * t + l * p + o * n) * c + l * u + o * v,
g = (m * a) / 5,
_ = n * v,
y = p * u;
(i.x = ((1.2 * m * c + l * y + o * _) * a) / 7),
(i.y = g),
(i.z = (o * g + y / 6 - _ / 6) * a);
});
var gt = mt,
_t = function() {};
(_t.prototype.constructor = _t),
(_t.type = "DistanceFunctor"),
r.register(_t.type, _t),
(_t.prototype.getType = function() {
return _t.type;
}),
(_t.prototype.toJSON = function() {
return {type: this.getType()};
}),
(_t.prototype.fromJSON = function(t) {
return r.fromJSON(t);
}),
(_t.prototype.value = function(t) {
throw "Error : not implemented. Must be reimplemented in children classes.";
}),
(_t.prototype.value = function(t) {
throw "Error : not implemented. Must be reimplemented in children classes.";
}),
(_t.prototype.numericalGradient = function(t, e) {
var i = e || 1e-5;
return (this.value(t + i) - this.value(t - i)) / (2 * i);
}),
(_t.prototype.gradient = function(t) {
return this.numericalGradient(t, 1e-5);
}),
(_t.prototype.getSupport = function(t) {
return 1 / 0;
});
var yt = _t,
dt = function(t) {
this.scale = t || 1;
};
((dt.prototype = Object.create(yt.prototype)).constructor = dt),
(dt.type = "Poly6DistanceFunctor"),
r.register(dt.type, dt),
(dt.prototype.getType = function() {
return dt.type;
}),
(dt.prototype.toJSON = function() {
var t = Blobtree.DistanceFunctor.prototype.toJSON.call(this, c);
return (t.scale = this.scale), t;
}),
(dt.evalStandard = function(t) {
if (t < 0) return 1;
var e = 1 - t * t;
return e > 0 ? e * e * e : 0;
}),
(dt.prototype.value = function(t) {
var e = t / (2 * this.scale);
return dt.evalStandard((e += 0.5)) / dt.evalStandard(0.5);
}),
(dt.prototype.gradient = function(t) {
var e = t / (2 * this.scale) + 0.5,
i = 1 - e * e;
return (i = ((-6 / (2 * this.scale)) * e * i * i) / dt.evalStandard(0.5));
}),
(dt.prototype.getSupport = function(t) {
return this.scale;
});
var ft = dt,
bt = function() {
p.call(this),
this.aabb.set(
new THREE.Vector3(-1 / 0, -1 / 0, -1 / 0),
new THREE.Vector3(1 / 0, 1 / 0, 1 / 0)
);
};
((bt.prototype = Object.create(p.prototype)).constructor = bt),
(bt.type = "SDFNode"),
r.register(bt.type, bt),
(bt.prototype.getType = function() {
return bt.type;
}),
(bt.prototype.computeAABB = function() {}),
(bt.prototype.computeDistanceAABB = function(t) {
throw "computeDistanceAABB is an abstract function of SDFNode. Please reimplement it in children classes.";
}),
(bt.prototype.getAreas = function() {
throw "No Areas for SDFNode, except for the SDFRootNode.";
}),
(bt.prototype.distanceTo = function(t) {
throw "distanceTo should be reimplemented in every children classes of SDFNode.";
}),
(bt.prototype.heuristicStepWithin = function() {
throw "heuristicStepWithin may not make sens for all SDFNode, except for the SDFRootNode.";
});
var wt = bt,
xt = function(e, i, s) {
wt.call(this),
(this.f = e),
(this.material = i ? i.clone() : new m()),
this.addChild(s),
(this.tmp_res = {v: 0, g: null}),
(this.tmp_g = new t.Vector3(0, 0, 0));
};
((xt.prototype = Object.create(wt.prototype)).constructor = xt),
(xt.type = "SDFRootNode"),
r.register(xt.type, xt),
(xt.prototype.getType = function() {
return xt.type;
}),
(xt.prototype.addChild = function(t) {
if (0 !== this.children.length)
throw "Error : SDFRootNode can have only one child.";
wt.prototype.addChild.call(this, t);
}),
(xt.prototype.toJSON = function() {
var t = wt.prototype.toJSON.call(this);
return (t.f = this.f.toJSON()), t;
}),
(xt.fromJSON = function(t) {
var e = new xt(r.fromJSON(e.f), r.fromJSON(t.children[0]));
return e;
}),
(xt.prototype.prepareForEval = function() {
if (!this.valid_aabb) {
this.aabb = new t.Box3();
for (var e = 0; e < this.children.length; ++e) {
var i = this.children[e];
i.prepareForEval(), this.aabb.union(i.computeDistanceAABB(this.f.getSupport()));
}
this.valid_aabb = !0;
}
}),
(xt.prototype.getAreas = function() {
if (this.valid_aabb) return this.children[0].getAreas(this.f.getSupport());
throw "ERROR : Cannot get area of invalid node";
}),
(xt.prototype.value = function(t, e) {
var i = this.tmp_res;
(i.g = e.g ? this.tmp_g : null),
(e.v = 0),
e.m && e.m.copy(m.defaultMaterial),
e.g || (void 0 !== e.step && (e.step = 1e9)),
this.aabb.containsPoint(t)
? (this.children[0].value(t, i),
  (e.v = this.f.value(i.v)),
  e.g && e.g.copy(i.g).multiplyScalar(this.f.gradient(e.v)),
  e.m && e.m.copy(this.material))
: void 0 !== e.step && (e.step = this.aabb.distanceToPoint(t) + 0.3);
});
var Vt,
At = xt,
St = function() {
h.call(this),
this.aabb.set(
new THREE.Vector3(-1 / 0, -1 / 0, -1 / 0),
new THREE.Vector3(1 / 0, 1 / 0, 1 / 0)
);
};
((St.prototype = Object.create(h.prototype)).constructor = St),
(St.type = "SDFPrimitive"),
r.register(St.type, St),
(St.prototype.SDFPrimitive = function() {
return St.type;
}),
(St.prototype.computeAABB = function() {}),
(St.prototype.computeDistanceAABB = function(t) {
throw "computeDistanceAABB is an abstract function of SDFPrimitive. Please reimplement it in children classes.";
}),
(St.prototype.getAreas = function() {
throw "No Areas for SDFPrimitive.";
}),
(St.prototype.distanceTo =
((Vt = {v: 0}),
function(t) {
return this.value(t, Vt), Vt.v;
})),
(St.prototype.heuristicStepWithin = function() {
throw "Not implemented";
});
var Mt = St,
Tt = function(t, e) {
Mt.call(this), (this.p = t.clone()), (this.acc = e || 1);
};
((Tt.prototype = Object.create(Mt.prototype)).constructor = Tt),
(Tt.type = "SDFPoint"),
r.register(Tt.type, Tt),
(Tt.prototype.getType = function() {
return Tt.type;
}),
(Tt.prototype.toJSON = function() {
var t = Mt.prototype.toJSON.call(this);
return (t.p = {x: this.p.x, y: this.p.y, z: this.p.z}), (t.acc = this.acc), t;
}),
(Tt.fromJSON = function(e) {
return new Tt(new t.Vector3(e.p.x, e.p.y, e.p.z), e.acc);
}),
(Tt.prototype.setAccuracy = function(t) {
(this.acc = t), this.invalidAABB();
}),
(Tt.prototype.getAccuracy = function() {
return this.acc;
}),
(Tt.prototype.setPosition = function(t) {
this.p.copy(t), this.invalidAABB();
}),
(Tt.prototype.getPosition = function() {
return this.p;
}),
(Tt.prototype.computeDistanceAABB = function(e) {
return new t.Box3(
this.p.clone().add(new t.Vector3(-e, -e, -e)),
this.p.clone().add(new t.Vector3(e, e, e))
);
}),
(Tt.prototype.prepareForEval = function() {
this.valid_aabb || (this.valid_aabb = !0);
}),
(Tt.prototype.getAreas = function(t) {
if (this.valid_aabb)
return [
{aabb: this.computeDistanceAABB(t), bv: new L(this.p, t, this.acc), obj: this}
];
throw "ERROR : Cannot get area of invalid primitive";
}),
(Tt.prototype.value = (function() {
var e = new t.Vector3();
return function(t, i) {
if (!this.valid_aabb) throw "Error : PrepareForEval should have been called";
e.subVectors(t, this.p);
var s = e.length();
(i.v = s), i.g && i.g.copy(e).multiplyScalar(1 / s);
};
})());
var Bt = Tt,
Pt = function(e, i, s, r, o, n) {
J.call(this),
(this.p1 = e.clone()),
(this.p2 = i.clone()),
(this.r1 = s),
(this.r2 = r),
(this.accFactor1 = o || 1),
(this.accFactor2 = n || 1),
(this.unit_dir = new t.Vector3().subVectors(i, e)),
(this.length = this.unit_dir.length()),
this.unit_dir.normalize(),
(this.vector = new t.Vector3()),
(this.p1_to_p = this.vector),
(this.p1_to_p_sqrnorm = 0),
(this.x_p_2D = 0),
(this.y_p_2D = 0),
(this.y_p_2DSq = 0),
(this.ortho_vec_x = this.r1 - this.r2),
(this.ortho_vec_y = this.length),
(this.p_proj_x = 0),
(this.p_proj_y = 0),
(this.abs_diff_thick = Math.abs(this.ortho_vec_x));
};
((Pt.prototype = Object.create(J.prototype)).constructor = Pt),
(Pt.prototype.proj_computation = function(t) {
(this.p1_to_p = this.vector),
this.p1_to_p.subVectors(t, this.p1),
(this.p1_to_p_sqrnorm = this.p1_to_p.lengthSq()),
(this.x_p_2D = this.p1_to_p.dot(this.unit_dir)),
(this.y_p_2DSq = this.p1_to_p_sqrnorm - this.x_p_2D * this.x_p_2D),
(this.y_p_2D = this.y_p_2DSq > 0 ? Math.sqrt(this.y_p_2DSq) : 0);
var e = -this.y_p_2D / this.ortho_vec_y;
(this.p_proj_x = this.x_p_2D + e * this.ortho_vec_x), (this.p_proj_y = 0);
}),
(Pt.prototype.sphereIntersect = function(t) {
if ((this.proj_computation(t.center), this.p_proj_x < 0))
return Math.sqrt(this.p1_to_p_sqrnorm) - t.radius < this.r1;
if (this.p_proj_x > this.length)
return (
this.vector.subVectors(t.center, this.p2),
Math.sqrt(this.vector.lengthSq()) - t.radius < this.r2
);
var e = this.x_p_2D - this.p_proj_x,
i = e * e + this.y_p_2DSq,
s = this.p_proj_x / this.length,
r = this.r1 * (1 - s) + s * this.r2,
o = t.radius + r;
return i < o * o;
}),
(Pt.prototype.contains = function(t) {
if ((this.proj_computation(t), this.p_proj_x < 0))
return this.p1_to_p_sqrnorm < this.r1 * this.r1;
if (this.p_proj_x > this.length)
return (
this.vector.subVectors(t, this.p2), this.vector.lengthSq() < this.r2 * this.r2
);
var e = this.x_p_2D - this.p_proj_x,
i = this.y_p_2D - this.p_proj_y,
s = e * e + i * i,
r = this.p_proj_x / this.length,
o = this.r1 * (1 - r) + r * this.r2;
return s < o * o;
}),
(Pt.prototype.getAcc = function(t, e) {
this.proj_computation(t.center);
var i = this.abs_diff_thick / this.length,
s = t.radius * Math.sqrt(1 + i * i) * 0.5,
r = this.p_proj_x;
if ((r += this.r1 > this.r2 ? s : -s) < 0) return this.r1 * this.accFactor1 * e;
if (r > this.length) return this.r2 * this.accFactor2 * e;
var o = r / this.length;
return (
(this.r1 * this.accFactor1 * (1 - o) + o * this.r2 * this.accFactor2) * e
);
}),
(Pt.prototype.getNiceAcc = function(t) {
return this.getAcc(t, G.nice);
}),
(Pt.prototype.getCurrAcc = function(t) {
return this.getAcc(t, G.curr);
}),
(Pt.prototype.getRawAcc = function(t) {
return this.getAcc(t, G.raw);
}),
(Pt.prototype.getMinAcc = function() {
return G.curr * Math.min(this.r1 * this.accFactor1, this.r2 * this.accFactor2);
}),
(Pt.prototype.getMinRawAcc = function() {
return G.raw * Math.min(this.r1 * this.accFactor1, this.r2 * this.accFactor2);
}),
(Pt.prototype.getAxisProjectionMinStep = function(t, e) {
var i,
s,
r,
o = Number.MAX_VALUE,
n = this.p1[t] < this.p2[t] ? this.p1 : this.p2;
n === this.p1
? ((i = this.p2),
  (s = this.r1 * this.accFactor1),
  (r = this.r2 * this.accFactor2))
: ((i = this.p1), (s = this.r2), (r = this.r1 * this.accFactor1));
var h = e - n[t];
h < -2 * s
? (o = Math.min(o, Math.max(Math.abs(h + 2 * s), G.curr * s)))
: h < 2 * s && (o = Math.min(o, G.curr * s)),
(h = e - i[t]) < -2 * r
? (o = Math.min(o, Math.max(Math.abs(h + 2 * r), G.curr * r)))
: h < 2 * r && (o = Math.min(o, G.curr * r));
var a = e - n[t],
c = i[t] - n[t];
return (
a > 0 &&
a < c &&
0 !== c &&
(o = Math.min(o, G.curr * (s + (a / c) * (r - s)))),
o
);
});
var Nt = Pt,
kt = function(e, i, s) {
Mt.call(this),
(this.p1 = e.clone()),
(this.p2 = i.clone()),
(this.acc = s || 1),
(this.l = new t.Line3(this.p1, this.p2));
};
((kt.prototype = Object.create(Mt.prototype)).constructor = kt),
(kt.type = "SDFSegment"),
r.register(kt.type, kt),
(kt.prototype.getType = function() {
return kt.type;
}),
(kt.prototype.toJSON = function() {
var t = Mt.prototype.toJSON.call(this);
return (
(t.p1 = {x: this.p1.x, y: this.p1.y, z: this.p1.z}),
(t.p2 = {x: this.p2.x, y: this.p2.y, z: this.p2.z}),
(t.acc = this.acc),
t
);
}),
(kt.fromJSON = function(e) {
ScalisVertex.fromJSON(e.v[0]);
return new kt(
new t.Vector3(e.p1.x, e.p1.y, e.p1.z),
new t.Vector3(e.p2.x, e.p2.y, e.p2.z),
e.acc
);
}),
(kt.prototype.setAccuracy = function(t) {
(this.acc = t), this.invalidAABB();
}),
(kt.prototype.getAccuracy = function() {
return this.acc;
}),
(kt.prototype.setPosition1 = function(t) {
this.p1.copy(t), this.invalidAABB();
}),
(kt.prototype.setPosition2 = function(t) {
this.p2.copy(t), this.invalidAABB();
}),
(kt.prototype.getPosition1 = function() {
return this.p1;
}),
(kt.prototype.getPosition2 = function() {
return this.p2;
}),
(kt.prototype.computeDistanceAABB = function(e) {
var i = new t.Box3(
this.p1.clone().add(new t.Vector3(-e, -e, -e)),
this.p1.clone().add(new t.Vector3(e, e, e))
),
s = new t.Box3(
this.p2.clone().add(new t.Vector3(-e, -e, -e)),
this.p2.clone().add(new t.Vector3(e, e, e))
);
return i.union(s);
}),
(kt.prototype.prepareForEval = function() {
this.valid_aabb || (this.l.set(this.p1, this.p2), (this.valid_aabb = !0));
}),
(kt.prototype.getAreas = function(t) {
if (this.valid_aabb)
return [
{
aabb: this.computeDistanceAABB(t),
bv: new Nt(this.p1, this.p2, t, t, this.acc, this.acc),
obj: this
}
];
throw "ERROR : Cannot get area of invalid primitive";
}),
(kt.prototype.value = (function() {
var e = new t.Vector3(),
i = new t.Vector3();
return function(t, s) {
this.l.closestPointToPoint(t, !0, e),
(s.v = i.subVectors(t, e).length()),
s.g && s.g.copy(i).divideScalar(s.v);
};
})());
var Ft = kt,
Dt = function(t, e) {
Mt.call(this), (this.p = t.clone()), (this.r = e);
};
((Dt.prototype = Object.create(Mt.prototype)).constructor = Dt),
(Dt.type = "SDFSphere"),
r.register(Dt.type, Dt),
(Dt.prototype.getType = function() {
return Dt.type;
}),
(Dt.prototype.toJSON = function() {
var t = Mt.prototype.toJSON.call(this);
return (t.p = {x: this.p.x, y: this.p.y, z: this.p.z}), (t.r = this.r), t;
}),
(Dt.fromJSON = function(e) {
return new Dt(new t.Vector3(e.p.x, e.p.y, e.p.z), e.r);
}),
(Dt.prototype.setRadius = function(t) {
(this.r = t), this.invalidAABB();
}),
(Dt.prototype.getRadius = function() {
return this.r;
}),
(Dt.prototype.setPosition = function(t) {
this.p.copy(t), this.invalidAABB();
}),
(Dt.prototype.getPosition = function() {
return this.p;
}),
(Dt.prototype.computeDistanceAABB = function(e) {
return new t.Box3(
this.p.clone().add(new t.Vector3(-this.r - e, -this.r - e, -this.r - e)),
this.p.clone().add(new t.Vector3(this.r + e, this.r + e, this.r + e))
);
}),
(Dt.prototype.prepareForEval = function() {
this.valid_aabb || (this.valid_aabb = !0);
}),
(Dt.prototype.getAreas = function(t) {
if (this.valid_aabb)
return [
{
aabb: this.computeDistanceAABB(t),
bv: new L(this.p, this.r + t, this.r / (this.r + t)),
obj: this
}
];
throw "ERROR : Cannot get area of invalid primitive";
}),
(Dt.prototype.value = (function() {
var e = new t.Vector3();
return function(t, i) {
if (!this.valid_aabb) throw "Error : PrepareForEval should have been called";
e.subVectors(t, this.p);
var s = e.length();
(i.v = s - this.r), i.g && i.g.copy(e).multiplyScalar(1 / s);
};
})());
var zt = Dt,
Ot = function(e, i, s, r) {
Mt.call(this),
(this.p1 = e.clone()),
(this.p2 = i.clone()),
(this.r1 = s),
(this.r2 = r),
(this.r1 = this.r1),
(this.rdiff = this.r2 - this.r1),
(this.unit_dir = new t.Vector3().subVectors(this.p2, this.p1)),
(this.lengthSq = this.unit_dir.lengthSq()),
(this.length = this.unit_dir.length()),
this.unit_dir.normalize();
};
((Ot.prototype = Object.create(Mt.prototype)).constructor = Ot),
(Ot.type = "SDFCapsule"),
r.register(Ot.type, Ot),
(Ot.prototype.getType = function() {
return Ot.type;
}),
(Ot.prototype.toJSON = function() {
var t = Mt.prototype.toJSON.call(this);
return (
(t.p1 = {x: this.p1.x, y: this.p1.y, z: this.p1.z}),
(t.r1 = this.r1),
(t.p2 = {x: this.p2.x, y: this.p2.y, z: this.p2.z}),
(t.r2 = this.r2),
t
);
}),
(Ot.fromJSON = function(e) {
ScalisVertex.fromJSON(e.v[0]);
return new Ot(
new t.Vector3(e.p1.x, e.p1.y, e.p1.z),
new t.Vector3(e.p2.x, e.p2.y, e.p2.z),
e.r1,
e.r2
);
}),
(Ot.prototype.setRadius1 = function(t) {
(this.r1 = t), this.invalidAABB();
}),
(Ot.prototype.setRadius2 = function(t) {
(this.r1 = t), this.invalidAABB();
}),
(Ot.prototype.getRadius1 = function() {
return this.r1;
}),
(Ot.prototype.getRadius2 = function() {
return this.r2;
}),
(Ot.prototype.setPosition1 = function(t) {
this.p1.copy(t), this.invalidAABB();
}),
(Ot.prototype.setPosition2 = function(t) {
this.p2.copy(t), this.invalidAABB();
}),
(Ot.prototype.getPosition1 = function() {
return this.p1;
}),
(Ot.prototype.getPosition2 = function() {
return this.p2;
}),
(Ot.prototype.computeDistanceAABB = function(e) {
var i = new t.Box3(
this.p1.clone().add(new t.Vector3(-this.r1 - e, -this.r1 - e, -this.r1 - e)),
this.p1.clone().add(new t.Vector3(this.r1 + e, this.r1 + e, this.r1 + e))
),
s = new t.Box3(
this.p2.clone().add(new t.Vector3(-this.r2 - e, -this.r2 - e, -this.r2 - e)),
this.p2.clone().add(new t.Vector3(this.r2 + e, this.r2 + e, this.r2 + e))
);
return i.union(s);
}),
(Ot.prototype.prepareForEval = function() {
this.valid_aabb || (this.valid_aabb = !0);
}),
(Ot.prototype.getAreas = function(t) {
if (this.valid_aabb)
return [
{
aabb: this.computeDistanceAABB(t),
bv: new Nt(
this.p1,
this.p2,
this.r1 + t,
this.r2 + t,
this.r1 / (this.r1 + t),
this.r2 / (this.r2 + t)
),
obj: this
}
];
throw "ERROR : Cannot get area of invalid primitive";
}),
(Ot.prototype.value = (function() {
var e = new t.Vector3(),
i = new t.Vector3();
return function(s, r) {
e.subVectors(s, this.p1);
var o = e.lengthSq(),
n = e.dot(this.unit_dir),
h =
n + (-Math.sqrt(Math.max(0, o - n * n)) / this.length) * (this.r1 - this.r2),
a = t.Math.clamp(h / this.length, 0, 1);
i.copy(this.p1).lerp(this.p2, a);
var c = e.subVectors(s, i).length();
(r.v = c - (a * this.r2 + (1 - a) * this.r1)),
r.g && r.g.copy(e).divideScalar(c);
};
})());
var Et = Ot,
qt = {
EdgeVMap: [
[0, 4],
[1, 5],
[2, 6],
[3, 7],
[0, 2],
[1, 3],
[4, 6],
[5, 7],
[0, 1],
[2, 3],
[4, 5],
[6, 7]
],
VertexTopo: [
[0, 0, 0],
[0, 0, 1],
[0, 1, 0],
[0, 1, 1],
[1, 0, 0],
[1, 0, 1],
[1, 1, 0],
[1, 1, 1]
]
},
jt = qt,
Rt = function(e, i, s, r) {
if ((t.Box2.call(this, e, i), null == s)) {
var o = Math.max(this.max.x - this.min.x, this.max.y - this.min.y);
this.nice_acc = o <= 0 ? 1e7 : o;
} else this.nice_acc = s;
this.raw_acc = null == r ? this.nice_acc : r;
};
((Rt.prototype = Object.create(t.Box2.prototype)).union = function(e) {
t.Box2.prototype.union.call(this, e),
(this.raw_acc = Math.min(e.raw_acc, this.raw_acc)),
(this.nice_acc = Math.min(e.nice_acc, this.nice_acc));
}),
(Rt.prototype.getRawAcc = function() {
return this.raw_acc;
}),
(Rt.prototype.getNiceAcc = function() {
return this.nice_acc;
}),
(Rt.prototype.setRawAcc = function(t) {
this.raw_acc = Math.max(0, t);
}),
(Rt.prototype.setNiceAcc = function(t) {
this.nice_acc = Math.max(0, t);
}),
(Rt.prototype.toString = function() {
return (
"(" +
this.min.x.toFixed(2) +
", " +
this.min.y.toFixed(2) +
") -> (" +
this.max.x.toFixed(2) +
", " +
this.max.y.toFixed(2) +
") "
);
}),
(Rt.prototype.set = function(t, e, i, s, r, o) {
this.min.set(t, e),
this.max.set(i, s),
void 0 !== r && (this.nice_acc = r),
void 0 !== o && (this.raw_acc = o);
}),
(Rt.prototype.getMinCorner = function() {
return this.min;
});
var Ct,
It,
Jt = function(e, i) {
i = i || {};
(this.blobtree = e),
(this.uniformZ = "uniform" === i.zResolution),
(this.detail_ratio = i.detailRatio ? Math.max(0.01, i.detailRatio) : 1),
i.convergence
? ((this.convergence = i.convergence),
  (this.convergence.ratio = this.convergence.ratio || 0.01),
  (this.convergence.step = this.convergence.step || 10))
: (this.convergence = null),
(this.progress = i.progress ? i.progress : function(t) {}),
(this.reso = new Int32Array(3)),
(this.steps = {x: null, y: null, z: null}),
(this.curr_steps = {x: 0, y: 0, z: 0}),
(this.curr_step_vol = 0),
(this.values_xy = [null, null]),
(this.vertices_xy = [null, null]),
(this.areas = []),
(this.min_acc = 1),
(this.values = new Array(8)),
(this.x = 0),
(this.y = 0),
(this.z = 0),
(this.mask = 0),
(this.edge_cross = [!1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1]),
(this.vertex = new t.Vector3(0, 0, 0)),
(this.vertex_n = new t.Vector3(0, 0, 0)),
(this.vertex_m = new m()),
(this.extended = !1),
(this.dis_o_aabb = new t.Box3()),
(this.ext_p = new t.Vector3()),
(this.geometry = null);
};
(Jt.prototype.initGeometry = function() {
this.geometry = {
position: [],
normal: [],
color: [],
metalness: [],
roughness: [],
nVertices: 0,
faces: [],
nFaces: 0,
addVertex: function(t) {
this.position.push(t.p.x, t.p.y, t.p.z),
this.normal.push(t.n.x, t.n.y, t.n.z),
this.color.push(t.c.r, t.c.g, t.c.b),
this.roughness.push(t.r),
this.metalness.push(t.m),
this.nVertices++;
},
addFace: function(t, e, i) {
this.faces.push(t, e, i), this.nFaces++;
}
};
}),
(Jt.prototype.buildResultingBufferGeometry = function() {
var e = new t.BufferGeometry();
return (
e.setAttribute(
"position",
new t.BufferAttribute(new Float32Array(this.geometry.position), 3)
),
e.setAttribute(
"normal",
new t.BufferAttribute(new Float32Array(this.geometry.normal), 3)
),
e.setAttribute(
"color",
new t.BufferAttribute(new Float32Array(this.geometry.color), 3)
),
e.setAttribute(
"roughness",
new t.BufferAttribute(new Float32Array(this.geometry.roughness), 1)
),
e.setAttribute(
"metalness",
new t.BufferAttribute(new Float32Array(this.geometry.metalness), 1)
),
e.setIndex(
new t.BufferAttribute(
this.geometry.nVertices > 65535
? new Uint32Array(this.geometry.faces)
: new Uint16Array(this.geometry.faces),
1
)
),
e
);
}),
(Jt.prototype.setFrontToZero = function() {
for (var t = 0; t < this.values_xy[1].length; ++t) this.values_xy[1][t] = 0;
}),
(Jt.prototype.setFrontToMinus = function() {
for (var t = 0; t < this.values_xy[1].length; ++t) this.values_xy[1][t] = -1;
}),
(Jt.prototype.setFrontToZeroIfMinus = function() {
for (var t = 0; t < this.values_xy[1].length; ++t)
-1 === this.values_xy[1][t] && (this.values_xy[1][t] = 0);
}),
(Jt.prototype.interpolateInBox = function(t, e, i, s, r, o, n) {
var h = this.values_xy[1],
a = r - s,
c = n - o;
if (a > 1)
for (
var p = h[(v = o * this.reso[0]) + s], l = (h[v + r] - p) / a, u = 1;
u < a;
++u
)
-1 === h[v + s + u] && (h[v + s + u] = p + u * l);
if (c > 1) {
var v;
for (
p = h[(v = n * this.reso[0]) + s], l = (h[v + r] - p) / a, u = 1;
u < a;
++u
)
-1 === h[v + s + u] && (h[v + s + u] = p + u * l);
for (u = 0; u <= a; ++u) {
(p = h[o * this.reso[0] + s + u]), (l = (h[n * this.reso[0] + s + u] - p) / c);
for (var m = 1; m < c; ++m)
-1 === h[(o + m) * this.reso[0] + s + u] &&
(h[(o + m) * this.reso[0] + s + u] = p + m * l);
}
}
}),
(Jt.prototype.computeFrontValAt = function(t, e, i, s, r) {
this.computeFrontValAtClosure(t, e, i, s, r);
}),
(Jt.prototype.computeFrontValAtClosure =
((Ct = {v: 0}),
(It = new t.Vector3()),
function(t, e, i, s, r) {
var o = r * this.reso[0] + s;
(Ct.v = this.blobtree.getNeutralValue()),
-1 === this.values_xy[1][o] &&
(It.set(t + s * this.min_acc, e + r * this.min_acc, i),
this.blobtree.value(It, Ct),
(this.values_xy[1][o] = Ct.v));
})),
(Jt.prototype.computeFrontValAtBoxCorners = function(t, e, i, s, r) {
this.computeFrontValAt(t, e, i, s.x, s.y),
this.computeFrontValAt(t, e, i, s.x, r.y),
this.computeFrontValAt(t, e, i, r.x, s.y),
this.computeFrontValAt(t, e, i, r.x, r.y);
}),
(Jt.prototype.computeFrontValInBox = function(t, e, i, s, r) {
for (var o = s.x; o <= r.x; ++o)
for (var n = s.y; n <= r.y; ++n) this.computeFrontValAt(t, e, i, o, n);
}),
(Jt.prototype.setFrontValZeroInBox = function(t, e) {
for (var i = t.x; i <= e.x; ++i)
for (var s = t.y; s <= e.y; ++s) this.values_xy[1][s * this.reso[0] + i] = 0;
}),
(Jt.prototype.computeBoxMask = function(t, e) {
var i = 0;
return (
(i |=
this.values_xy[1][t.y * this.reso[0] + t.x] > this.blobtree.getIsoValue()
? 1
: 0),
(i |=
this.values_xy[1][t.y * this.reso[0] + e.x] > this.blobtree.getIsoValue()
? 2
: 0),
(i |=
this.values_xy[1][e.y * this.reso[0] + e.x] > this.blobtree.getIsoValue()
? 4
: 0),
(i |=
this.values_xy[1][e.y * this.reso[0] + t.x] > this.blobtree.getIsoValue()
? 8
: 0)
);
}),
(Jt.prototype.checkZeroBox = function(t, e) {
return (
this.values_xy[1][t.y * this.reso[0] + t.x] +
this.values_xy[1][t.y * this.reso[0] + e.x] +
this.values_xy[1][e.y * this.reso[0] + e.x] +
this.values_xy[1][e.y * this.reso[0] + t.x]
);
}),
(Jt.prototype.recursiveBoxComputation = function(e, i, s, r, o) {
var n = null,
h = new t.Vector2(Math.round(r.max.x - r.min.x), Math.round(r.max.y - r.min.y));
if (h.x > 1 && h.x >= h.y) {
var a = r.min.x + Math.floor(h.x / 2);
(n = [
new Rt(r.min, new t.Vector2(a, r.max.y), 1e4, 1e4),
new Rt(new t.Vector2(a, r.min.y), r.max, 1e4, 1e4)
]),
this.computeFrontValAt(e, i, s, a, r.min.y),
this.computeFrontValAt(e, i, s, a, r.max.y);
} else {
if (!(h.y > 1)) return;
var c = r.min.y + Math.floor(h.y / 2);
(n = [
new Rt(r.min, new t.Vector2(r.max.x, c), 1e4, 1e4),
new Rt(new t.Vector2(r.min.x, c), r.max, 1e4, 1e4)
]),
this.computeFrontValAt(e, i, s, r.min.x, c),
this.computeFrontValAt(e, i, s, r.max.x, c);
}
for (var p = [[], []], l = 0; l < o.length; ++l)
for (var u = 0; u < n.length; ++u)
n[u].intersectsBox(o[l]) &&
(n[u].setRawAcc(Math.min(n[u].getRawAcc(), o[l].getRawAcc())),
n[u].setNiceAcc(Math.min(n[u].getNiceAcc(), o[l].getNiceAcc())),
p[u].push(o[l]));
for (u = 0; u < n.length; ++u) {
var v = n[u],
m = v.getSize(new t.Vector3());
if (0 === p[u].length) this.setFrontValZeroInBox(v.min, v.max);
else if (m.x <= v.getRawAcc() && m.y <= v.getRawAcc()) {
var g = this.computeBoxMask(v.min, v.max);
15 === g || 0 === g
? this.interpolateInBox(e, i, s, v.min.x, v.max.x, v.min.y, v.max.y)
: m.x <= v.getNiceAcc() && m.y <= v.getNiceAcc()
? this.interpolateInBox(e, i, s, v.min.x, v.max.x, v.min.y, v.max.y)
: this.recursiveBoxComputation(e, i, s, v, p[u]);
} else this.recursiveBoxComputation(e, i, s, v, p[u]);
}
}),
(Jt.prototype.computeFrontValues = function(e, i, s) {
this.setFrontToMinus();
var r = this.blobtree.getAreas(),
o = new Rt();
o.makeEmpty();
for (var n = [], h = 0; h < r.length; ++h) {
var a = Math.round((r[h].bv.getMinRawAcc() * this.detail_ratio) / this.min_acc),
c = Math.round((r[h].bv.getMinAcc() * this.detail_ratio) / this.min_acc),
p = Math.max(0, Math.floor((r[h].aabb.min.x - e) / this.min_acc)),
l = Math.max(0, Math.floor((r[h].aabb.min.y - i) / this.min_acc)),
u = Math.min(this.reso[0] - 1, Math.ceil((r[h].aabb.max.x - e) / this.min_acc)),
v = Math.min(this.reso[1] - 1, Math.ceil((r[h].aabb.max.y - i) / this.min_acc));
n.push(new Rt(new t.Vector2(p, l), new t.Vector2(u, v), c, a)),
o.union(n[n.length - 1]);
}
o.intersect(
new Rt(
new t.Vector2(0, 0),
new t.Vector2(this.reso[0], this.reso[1]),
o.getNiceAcc(),
o.getRawAcc()
)
),
this.computeFrontValAtBoxCorners(e, i, s, o.min, o.max),
this.recursiveBoxComputation(e, i, s, o, n),
this.setFrontToZeroIfMinus();
}),
(Jt.prototype.getMinAcc = function(t) {
for (
var e = this.blobtree.getAreas(), i = Number.MAX_VALUE, s = 0;
s < e.length;
s++
) {
var r = e[s];
if (r.aabb.intersectsBox(t) && r.bv) {
var o = r.bv.getMinAcc();
o < i && (i = o);
}
}
return i * this.detail_ratio;
}),
(Jt.prototype.getMaxAcc = function(t) {
for (var e = this.blobtree.getAreas(), i = 0, s = 0; s < e.length; s++) {
var r = e[s];
if (r.aabb.intersectsBox(t) && r.bv) {
var o = r.bv.getMinAcc();
o > i && (i = o);
}
}
return i * this.detail_ratio;
}),
(Jt.prototype.compute = function(e, i) {
this.initGeometry();
var s = new Date();
this.blobtree.prepareForEval();
var r = null;
if (
((r = e ? e.clone() : this.blobtree.getAABB()),
(this.extended = void 0 !== i && i),
this.extended)
) {
for (
var o = r.getSize(new t.Vector3()),
n = Math.min(Math.min(this.getMinAcc(r), o[0]), Math.min(o[1], o[2])),
h = r.clone(),
a = r.clone(),
c = ["x", "y", "z"],
p = 0;
p < c.length;
++p
) {
h.max[c[p]] = r.min[c[p]] + n;
var l = this.getMaxAcc(h);
0 !== l && (a.min[c[p]] = a.min[c[p]] - l),
(h.max[c[p]] = r.max[c[p]] - n),
0 !== (l = this.getMaxAcc(h)) && (a.max[c[p]] = a.max[c[p]] + l);
}
r.copy(a);
}
var u = [],
v = [];
if (
(e && (this.blobtree.externalTrim(r, u, v), this.blobtree.prepareForEval()),
(this.areas = this.blobtree.getAreas()),
0 === this.areas.length)
)
return this.progress(100), new t.BufferGeometry();
this.min_acc = 0 !== this.areas.length ? this.areas[0].bv.getMinAcc() : 1;
for (var m = 0; m < this.areas.length; ++m)
this.areas[m].bv.getMinAcc() < this.min_acc &&
(this.min_acc = this.areas[m].bv.getMinAcc());
this.min_acc = this.min_acc * this.detail_ratio;
var g = r.min,
_ = r.getSize(new t.Vector3());
this.steps.z = new Float32Array(Math.ceil(_.z / this.min_acc) + 2);
g.z;
this.steps.z[0] = g.z;
for (
var y = 1, d = this.blobtree.getAreas();
this.steps.z[y - 1] < g.z + _.z;

) {
var f = _.z;
if (this.uniformZ) f = this.min_acc;
else
for (m = 0; m < d.length; ++m)
f = Math.min(
f,
d[m].bv.getAxisProjectionMinStep("z", this.steps.z[y - 1]) * this.detail_ratio
);
(this.steps.z[y] = this.steps.z[y - 1] + f), y++;
}
if (
((this.reso[2] = y),
(this.reso[0] = Math.ceil(_.x / this.min_acc) + 2),
(this.reso[1] = Math.ceil(_.y / this.min_acc) + 2),
this.extended)
) {
m = 0;
for (
this.dis_o_aabb.set(new t.Vector3(-1, -1, -1), new t.Vector3(-1, -1, -1));
m < this.reso[2] && -1 === this.dis_o_aabb.min.z;

)
this.steps.z[m] >= e.min.z && (this.dis_o_aabb.min.z = m), m++;
for (
m > this.reso[2] - 1 && (this.dis_o_aabb.min.z = this.reso[2] - 1),
m = this.reso[2] - 1;
m >= 0 && -1 === this.dis_o_aabb.max.z;

)
this.steps.z[m] < e.max.z && (this.dis_o_aabb.max.z = m), m--;
m < 0 && (this.dis_o_aabb.max.z = 0),
(this.dis_o_aabb.min.x = Math.round((e.min.x - r.min.x) / this.min_acc)),
(this.dis_o_aabb.min.y = Math.round((e.min.y - r.min.y) / this.min_acc)),
(this.dis_o_aabb.max.x =
this.reso[0] - 2 - Math.round((r.max.x - e.max.x) / this.min_acc)),
(this.dis_o_aabb.max.y =
this.reso[1] - 2 - Math.round((r.max.y - e.max.y) / this.min_acc));
}
(this.values_xy[0] = new Float32Array(this.reso[0] * this.reso[1])),
(this.values_xy[1] = new Float32Array(this.reso[0] * this.reso[1])),
(this.vertices_xy[0] = new Int32Array(this.reso[0] * this.reso[1])),
(this.vertices_xy[1] = new Int32Array(this.reso[0] * this.reso[1]));
var b = new t.Box3();
this.computeFrontValues(g.x, g.y, g.z);
for (var w = 0, x = 0; x < this.reso[2] - 1; ++x) {
var V = this.values_xy[0];
(this.values_xy[0] = this.values_xy[1]),
(this.values_xy[1] = V),
(V = this.vertices_xy[0]),
(this.vertices_xy[0] = this.vertices_xy[1]),
(this.vertices_xy[1] = V);
var A = this.steps.z[x + 1];
b.set(
new t.Vector3(g.x, g.y, A - this.min_acc / 64),
new t.Vector3(
g.x + this.reso[0] * this.min_acc,
g.y + this.reso[1] * this.min_acc,
A + this.min_acc / 64
)
),
this.blobtree.internalTrim(b),
this.blobtree.prepareForEval(),
this.computeFrontValues(g.x, g.y, A),
this.blobtree.internalUntrim(b),
this.blobtree.prepareForEval(),
(this.z = this.steps.z[x]),
(this.curr_steps.z = this.steps.z[x + 1] - this.steps.z[x]),
(this.curr_steps.x = this.min_acc),
(this.curr_steps.y = this.min_acc),
(this.curr_step_vol =
this.curr_steps.x * this.curr_steps.y * this.curr_steps.z);
for (var S = 0; S < this.reso[1] - 1; ++S)
for (var M = 0; M < this.reso[0] - 1; ++M)
(this.y = g.y + S * this.min_acc), this.fetchAndTriangulate(M, S, x, g);
Math.round((100 * x) / this.reso[2]) > w &&
((w = Math.round((100 * x) / this.reso[2])), this.progress(w));
}
e && (this.blobtree.untrim(u, v), this.blobtree.prepareForEval());
var T = new Date();
return (
console.log("Sliding Marching Cubes computed in " + (T - s) + "ms"),
(this.values_xy[0] = null),
(this.values_xy[1] = null),
(this.vertices_xy[0] = null),
(this.vertices_xy[1] = null),
this.progress(100),
this.buildResultingBufferGeometry()
);
}),
(Jt.prototype.fetchAndTriangulate = function(t, e, i, s) {
var r = e * this.reso[0] + t,
o = (e + 1) * this.reso[0] + t;
(this.values[0] = this.values_xy[0][r]),
(this.values[1] = this.values_xy[1][r]),
(this.values[2] = this.values_xy[0][o]),
(this.values[3] = this.values_xy[1][o]),
(this.values[4] = this.values_xy[0][r + 1]),
(this.values[5] = this.values_xy[1][r + 1]),
(this.values[6] = this.values_xy[0][o + 1]),
(this.values[7] = this.values_xy[1][o + 1]),
this.computeMask(),
0 !== this.mask &&
255 !== this.mask &&
((this.x = s.x + t * this.min_acc),
this.computeVertex(),
this.geometry.addVertex({
p: this.vertex,
n: this.vertex_n,
c: this.vertex_m.getColor(),
r: this.vertex_m.getRoughness(),
m: this.vertex_m.getMetalness()
}),
(this.vertices_xy[1][r] = this.geometry.nVertices - 1),
this.triangulate(t, e, i));
}),
(Jt.prototype.pushDirectFaces = function(t, e, i, s) {
this.geometry.addFace(t, e, i), this.geometry.addFace(i, s, t);
}),
(Jt.prototype.pushUndirectFaces = function(t, e, i, s) {
this.geometry.addFace(i, e, t), this.geometry.addFace(t, s, i);
}),
(Jt.prototype.triangulate = function(t, e, i) {
var s = e * this.reso[0] + t;
if (this.edge_cross[0] && 0 !== e && 0 !== i) {
var r = this.vertices_xy[1][s],
o = this.vertices_xy[1][(e - 1) * this.reso[0] + t],
n = this.vertices_xy[0][(e - 1) * this.reso[0] + t],
h = this.vertices_xy[0][s];
1 & this.mask
? this.pushDirectFaces(r, o, n, h)
: this.pushUndirectFaces(r, o, n, h);
}
if (this.edge_cross[4] && 0 !== t && 0 !== i) {
(r = this.vertices_xy[1][s]),
(o = this.vertices_xy[0][s]),
(n = this.vertices_xy[0][s - 1]),
(h = this.vertices_xy[1][s - 1]);
1 & this.mask
? this.pushDirectFaces(r, o, n, h)
: this.pushUndirectFaces(r, o, n, h);
}
if (this.edge_cross[8] && 0 !== t && 0 !== e) {
(r = this.vertices_xy[1][s]),
(o = this.vertices_xy[1][s - 1]),
(n = this.vertices_xy[1][(e - 1) * this.reso[0] + t - 1]),
(h = this.vertices_xy[1][(e - 1) * this.reso[0] + t]);
1 & this.mask
? this.pushDirectFaces(r, o, n, h)
: this.pushUndirectFaces(r, o, n, h);
}
}),
(Jt.prototype.computeVertex = (function() {
var e = {v: null, g: new t.Vector3(0, 0, 0), m: new m()},
i = new t.Vector3();
return function() {
e.v = this.blobtree.getNeutralValue();
var t = 0;
this.vertex.set(0, 0, 0);
for (var s = 0; s < 12; ++s) {
var r = jt.EdgeVMap[s][0],
o = jt.EdgeVMap[s][1],
n = jt.VertexTopo[r],
h = jt.VertexTopo[o],
a = this.values[r],
c = this.values[o];
if (
((this.edge_cross[s] =
a > this.blobtree.getIsoValue() != c > this.blobtree.getIsoValue()),
this.edge_cross[s])
) {
++t;
var p = c - a,
l = 0;
Math.abs(p) > 1e-6 &&
((l = (this.blobtree.getIsoValue() - a) / p),
(this.vertex.x += (1 - l) * n[0] + l * h[0]),
(this.vertex.y += (1 - l) * n[1] + l * h[1]),
(this.vertex.z += (1 - l) * n[2] + l * h[2]));
}
}
(this.vertex.x = this.x + (this.curr_steps.x * this.vertex.x) / t),
(this.vertex.y = this.y + (this.curr_steps.y * this.vertex.y) / t),
(this.vertex.z = this.z + (this.curr_steps.z * this.vertex.z) / t),
this.convergence &&
(u.safeNewton3D(
this.blobtree,
this.vertex,
this.blobtree.getIsoValue(),
this.min_acc * this.convergence.ratio,
this.convergence.step,
this.min_acc,
i
),
this.vertex.copy(i)),
this.blobtree.value(this.vertex, e),
e.g.normalize(),
this.vertex_n.copy(e.g).multiplyScalar(-1),
this.vertex_m.copy(e.m);
};
})()),
(Jt.prototype.computeMask = function() {
this.mask = 0;
for (var t = 0; t < 8; ++t) {
var e = this.values[t];
this.mask |= e > this.blobtree.getIsoValue() ? 1 << t : 0;
}
});
var Kt = Jt,
Gt = function(e) {
if ((p.call(this), e)) {
var i = this;
e.forEach(function(t) {
i.addChild(t);
});
}
(this.tmp_res = {v: 0, g: null, m: null}),
(this.tmp_g = new t.Vector3()),
(this.tmp_m = new m());
};
((Gt.prototype = Object.create(p.prototype)).constructor = Gt),
(Gt.type = "MaxNode"),
r.register(Gt.type, Gt),
(Gt.prototype.getType = function() {
return Gt.type;
}),
(Gt.fromJSON = function(t) {
for (var e = new Gt(), i = 0; i < t.children.length; ++i)
e.addChild(r.fromJSON(t.children[i]));
return e;
}),
(Gt.prototype.prepareForEval = function() {
if (!this.valid_aabb) {
this.aabb = new t.Box3();
for (var e = 0; e < this.children.length; ++e) {
var i = this.children[e];
i.prepareForEval(), this.aabb.union(i.getAABB());
}
this.valid_aabb = !0;
}
}),
(Gt.prototype.value = function(t, e) {
var i = this.children.length,
s = this.tmp_res;
if (
((s.g = e.g ? this.tmp_g : null),
(s.m = e.m ? this.tmp_m : null),
(e.v = 0),
e.m && e.m.copy(m.defaultMaterial),
e.g ? e.g.set(0, 0, 0) : void 0 !== e.step && (e.step = 1e9),
this.aabb.containsPoint(t) && 0 !== i)
) {
e.v = Number.MAX_VALUE;
for (var r = 0; r < i; ++r) {
if (
(this.children[r].value(t, s),
s.v > e.v &&
((e.v = s.v),
e.g && e.g.copy(s.g),
e.m && e.m.copy(s.m),
e.step || e.stepOrtho))
)
throw "Not implemented";
e.v = Math.max(e.v, s.v);
}
} else if (e.steo || e.stepOrtho) throw "Not implemented";
});
var Ht = Gt,
Lt = function(t, e) {
e = e || {};
(this.blobtree = t),
(this.uniformRes = e.uniformRes || !1),
(this.min_acc = null),
(this.minAccs = []),
(this.subPolygonizer = e.subPolygonizer
? e.subPolygonizer
: {class: Kt, detailRatio: 1}),
(this.ricciThreshold = e.ricciThreshold || 64),
(this.progress = e.progress ? e.progress : function(t) {}),
(this.subtrees = []),
(this.progCoeff = []),
(this.totalCoeff = 0),
this.setBlobtree(t);
};
(Lt.prototype.constructor = Lt),
(Lt.prototype.setBlobtree = function(t) {
(this.blobtree = t), this.blobtree.prepareForEval();
var e = function(t) {
for (
var e = t.getAreas(), i = 0 !== e.length ? e[0].bv.getMinAcc() : null, s = 0;
s < e.length;
++s
)
e[s].bv.getMinAcc() < i && (i = e[s].bv.getMinAcc());
return i;
};
(this.min_acc = e(this.blobtree)),
(this.subtrees = []),
(this.progCoeff = []),
(this.totalCoeff = 0);
var i = this,
s = function(t) {
var s = null;
t instanceof M ? (s = t.clone()) : (s = new M()).addChild(t.clone()),
i.subtrees.push(s),
s.prepareForEval(),
i.minAccs.push(e(s)),
i.progCoeff.push(s.count(W) + s.count(it) + s.count(gt)),
(i.totalCoeff += i.progCoeff[i.progCoeff.length - 1]);
},
r = function(t) {
if (t instanceof A)
if (t.getRicciN() < i.ricciThreshold) 0 !== t.children.length && s(t);
else for (var e = 0; e < t.children.length; ++e) r(t.children[e]);
else if (t instanceof Ht)
for (e = 0; e < t.children.length; ++e) r(t.children[e]);
else s(t);
};
r(this.blobtree);
}),
(Lt.prototype.compute = function() {
this.blobtree.isValidAABB() || this.setBlobtree(this.blobtree);
var e = this;
this.progress(0);
for (var i = 0, s = [], r = 0; r < this.subtrees.length; ++r) {
var o = this.subPolygonizer.detailRatio || 1;
this.uniformRes &&
this.min_acc &&
(this.subPolygonizer.detailRatio = (o * this.min_acc) / this.minAccs[r]),
(this.subPolygonizer.progress = function(t) {
e.progress((100 * (i + (t / 100) * e.progCoeff[r])) / e.totalCoeff);
});
var n = new this.subPolygonizer.class(this.subtrees[r], this.subPolygonizer);
s.push(n.compute()),
(this.subPolygonizer.detailRatio = o),
(i += this.progCoeff[r]);
}
var h = t.BufferGeometryUtils.mergeBufferGeometries(s);
return this.progress(100), h;
});
var Ut = Lt,
Wt = function(t, e) {
if ((Kt.call(this, t, e), !e.metaBlobtree))
throw "Error : SplitSMC needs a meta blobtree in params (from which normals will be computed).";
(this.metaBlobtree = e.metaBlobtree), this.metaBlobtree.prepareForEval();
};
((Wt.prototype = Object.create(Kt.prototype)).constructor = Wt),
(Wt.prototype.computeVertex = (function() {
var e = {v: null, g: new t.Vector3(0, 0, 0), m: new m()},
i = new t.Vector3();
return function() {
e.v = this.blobtree.getNeutralValue();
var t = 0;
this.vertex.set(0, 0, 0);
for (var s = 0; s < 12; ++s) {
var r = jt.EdgeVMap[s][0],
o = jt.EdgeVMap[s][1],
n = jt.VertexTopo[r],
h = jt.VertexTopo[o],
a = this.values[r],
c = this.values[o];
if (
((this.edge_cross[s] =
a > this.blobtree.getIsoValue() != c > this.blobtree.getIsoValue()),
this.edge_cross[s])
) {
++t;
var p = c - a,
l = 0;
Math.abs(p) > 1e-6 &&
((l = (this.blobtree.getIsoValue() - a) / p),
(this.vertex.x += (1 - l) * n[0] + l * h[0]),
(this.vertex.y += (1 - l) * n[1] + l * h[1]),
(this.vertex.z += (1 - l) * n[2] + l * h[2]));
}
}
(this.vertex.x = this.x + (this.curr_steps.x * this.vertex.x) / t),
(this.vertex.y = this.y + (this.curr_steps.y * this.vertex.y) / t),
(this.vertex.z = this.z + (this.curr_steps.z * this.vertex.z) / t),
this.convergence &&
(u.safeNewton3D(
this.blobtree,
this.vertex,
this.blobtree.getIsoValue(),
this.min_acc * this.convergence.ratio,
this.convergence.step,
this.min_acc,
i
),
this.vertex.copy(i)),
this.metaBlobtree.value(this.vertex, e),
e.g.normalize(),
this.vertex_n.copy(e.g).multiplyScalar(-1),
this.vertex_m.copy(e.m);
};
})());
var Zt = Wt;
"122" !== t.REVISION &&
console.warn(
"Blobtree library is currently made for THREE revision 122. Using any other revision may lead to unexpected behavior."
);
var Xt = {version: "1.0.0"};
return (
(Xt.Types = r),
(Xt.Element = h),
(Xt.Node = p),
(Xt.RootNode = M),
(Xt.RicciNode = A),
(Xt.DifferenceNode = B),
(Xt.MinNode = N),
(Xt.MaxNode = N),
(Xt.Primitive = F),
(Xt.ScalisMath = z),
(Xt.ScalisPrimitive = E),
(Xt.ScalisPoint = W),
(Xt.ScalisSegment = it),
(Xt.ScalisTriangle = gt),
(Xt.ScalisVertex = R),
(Xt.DistanceFunctor = yt),
(Xt.Poly6DistanceFunctor = ft),
(Xt.SDFRootNode = At),
(Xt.SDFPrimitive = Mt),
(Xt.SDFPoint = Bt),
(Xt.SDFSegment = Ft),
(Xt.SDFSphere = zt),
(Xt.SDFCapsule = Et),
(Xt.Material = m),
(Xt.Accuracies = G),
(Xt.Area = J),
(Xt.AreaScalisSeg = tt),
(Xt.AreaScalisTri = vt),
(Xt.AreaSphere = L),
(Xt.AreaCapsule = Nt),
(Xt.SlidingMarchingCubes = Kt),
(Xt.SplitMaxPolygonizer = Ut),
(Xt.SplitSMC = Zt),
(t.Blobtree = Xt),
Xt
);
});
